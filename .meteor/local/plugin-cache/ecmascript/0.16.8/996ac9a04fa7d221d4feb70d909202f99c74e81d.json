{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/mongo_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/mongo/mongo_driver.js","filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/mongo_driver.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/styles","root":"/Users/nicholas/Desktop/projects/local-legends/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/mongo_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/mongo_driver.js"}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  let normalizeProjection;\n  module1.link(\"./mongo_utils\", {\n    normalizeProjection(v) {\n      normalizeProjection = v;\n    }\n  }, 0);\n  let DocFetcher;\n  module1.link(\"./doc_fetcher.js\", {\n    DocFetcher(v) {\n      DocFetcher = v;\n    }\n  }, 1);\n  let ASYNC_CURSOR_METHODS, getAsyncMethodName;\n  module1.link(\"meteor/minimongo/constants\", {\n    ASYNC_CURSOR_METHODS(v) {\n      ASYNC_CURSOR_METHODS = v;\n    },\n    getAsyncMethodName(v) {\n      getAsyncMethodName = v;\n    }\n  }, 2);\n  /**\n   * Provide a synchronous Collection API using fibers, backed by\n   * MongoDB.  This is only for use on the server, and mostly identical\n   * to the client API.\n   *\n   * NOTE: the public API methods must be run within a fiber. If you call\n   * these outside of a fiber they will explode!\n   */\n\n  const path = require(\"path\");\n  const util = require(\"util\");\n\n  /** @type {import('mongodb')} */\n  var MongoDB = NpmModuleMongodb;\n  var Future = Npm.require('fibers/future');\n  MongoInternals = {};\n  MongoInternals.NpmModules = {\n    mongodb: {\n      version: NpmModuleMongodbVersion,\n      module: MongoDB\n    }\n  };\n\n  // Older version of what is now available via\n  // MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n  // people do use it.\n  // XXX COMPAT WITH 1.0.3.2\n  MongoInternals.NpmModule = MongoDB;\n  const FILE_ASSET_SUFFIX = 'Asset';\n  const ASSETS_FOLDER = 'assets';\n  const APP_FOLDER = 'app';\n\n  // This is used to add or remove EJSON from the beginning of everything nested\n  // inside an EJSON custom type. It should only be called on pure JSON!\n  var replaceNames = function (filter, thing) {\n    if (typeof thing === \"object\" && thing !== null) {\n      if (_.isArray(thing)) {\n        return _.map(thing, _.bind(replaceNames, null, filter));\n      }\n      var ret = {};\n      _.each(thing, function (value, key) {\n        ret[filter(key)] = replaceNames(filter, value);\n      });\n      return ret;\n    }\n    return thing;\n  };\n\n  // Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n  // doing a structural clone).\n  // XXX how ok is this? what if there are multiple copies of MongoDB loaded?\n  MongoDB.Timestamp.prototype.clone = function () {\n    // Timestamps should be immutable.\n    return this;\n  };\n  var makeMongoLegal = function (name) {\n    return \"EJSON\" + name;\n  };\n  var unmakeMongoLegal = function (name) {\n    return name.substr(5);\n  };\n  var replaceMongoAtomWithMeteor = function (document) {\n    if (document instanceof MongoDB.Binary) {\n      // for backwards compatibility\n      if (document.sub_type !== 0) {\n        return document;\n      }\n      var buffer = document.value(true);\n      return new Uint8Array(buffer);\n    }\n    if (document instanceof MongoDB.ObjectID) {\n      return new Mongo.ObjectID(document.toHexString());\n    }\n    if (document instanceof MongoDB.Decimal128) {\n      return Decimal(document.toString());\n    }\n    if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n      return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n    }\n    if (document instanceof MongoDB.Timestamp) {\n      // For now, the Meteor representation of a Mongo timestamp type (not a date!\n      // this is a weird internal thing used in the oplog!) is the same as the\n      // Mongo representation. We need to do this explicitly or else we would do a\n      // structural clone and lose the prototype.\n      return document;\n    }\n    return undefined;\n  };\n  var replaceMeteorAtomWithMongo = function (document) {\n    if (EJSON.isBinary(document)) {\n      // This does more copies than we'd like, but is necessary because\n      // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n      // serialize it correctly).\n      return new MongoDB.Binary(Buffer.from(document));\n    }\n    if (document instanceof MongoDB.Binary) {\n      return document;\n    }\n    if (document instanceof Mongo.ObjectID) {\n      return new MongoDB.ObjectID(document.toHexString());\n    }\n    if (document instanceof MongoDB.Timestamp) {\n      // For now, the Meteor representation of a Mongo timestamp type (not a date!\n      // this is a weird internal thing used in the oplog!) is the same as the\n      // Mongo representation. We need to do this explicitly or else we would do a\n      // structural clone and lose the prototype.\n      return document;\n    }\n    if (document instanceof Decimal) {\n      return MongoDB.Decimal128.fromString(document.toString());\n    }\n    if (EJSON._isCustomType(document)) {\n      return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n    }\n    // It is not ordinarily possible to stick dollar-sign keys into mongo\n    // so we don't bother checking for things that need escaping at this time.\n    return undefined;\n  };\n  var replaceTypes = function (document, atomTransformer) {\n    if (typeof document !== 'object' || document === null) return document;\n    var replacedTopLevelAtom = atomTransformer(document);\n    if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;\n    var ret = document;\n    _.each(document, function (val, key) {\n      var valReplaced = replaceTypes(val, atomTransformer);\n      if (val !== valReplaced) {\n        // Lazy clone. Shallow copy.\n        if (ret === document) ret = _.clone(document);\n        ret[key] = valReplaced;\n      }\n    });\n    return ret;\n  };\n  MongoConnection = function (url, options) {\n    var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n    var self = this;\n    options = options || {};\n    self._observeMultiplexers = {};\n    self._onFailoverHook = new Hook();\n    const userOptions = _objectSpread(_objectSpread({}, Mongo._connectionOptions || {}), ((_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.mongo) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.options) || {});\n    var mongoOptions = Object.assign({\n      ignoreUndefined: true\n    }, userOptions);\n\n    // Internally the oplog connections specify their own maxPoolSize\n    // which we don't want to overwrite with any user defined value\n    if (_.has(options, 'maxPoolSize')) {\n      // If we just set this for \"server\", replSet will override it. If we just\n      // set it for replSet, it will be ignored if we're not using a replSet.\n      mongoOptions.maxPoolSize = options.maxPoolSize;\n    }\n\n    // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n    // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n    Object.entries(mongoOptions || {}).filter(_ref => {\n      let [key] = _ref;\n      return key && key.endsWith(FILE_ASSET_SUFFIX);\n    }).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(), ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n    self.db = null;\n    self._oplogHandle = null;\n    self._docFetcher = null;\n    self.client = new MongoDB.MongoClient(url, mongoOptions);\n    self.db = self.client.db();\n    self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n      // When the connection is no longer against the primary node, execute all\n      // failover hooks. This is important for the driver as it has to re-pool the\n      // query when it happens.\n      if (event.previousDescription.type !== 'RSPrimary' && event.newDescription.type === 'RSPrimary') {\n        self._onFailoverHook.each(callback => {\n          callback();\n          return true;\n        });\n      }\n    }));\n    if (options.oplogUrl && !Package['disable-oplog']) {\n      self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n      self._docFetcher = new DocFetcher(self);\n    }\n    Promise.await(self.client.connect());\n  };\n  MongoConnection.prototype.close = function () {\n    var self = this;\n    if (!self.db) throw Error(\"close called before Connection created?\");\n\n    // XXX probably untested\n    var oplogHandle = self._oplogHandle;\n    self._oplogHandle = null;\n    if (oplogHandle) oplogHandle.stop();\n\n    // Use Future.wrap so that errors get thrown. This happens to\n    // work even outside a fiber since the 'close' method is not\n    // actually asynchronous.\n    Future.wrap(_.bind(self.client.close, self.client))(true).wait();\n  };\n\n  // Returns the Mongo Collection object; may yield.\n  MongoConnection.prototype.rawCollection = function (collectionName) {\n    var self = this;\n    if (!self.db) throw Error(\"rawCollection called before Connection created?\");\n    return self.db.collection(collectionName);\n  };\n  MongoConnection.prototype._createCappedCollection = function (collectionName, byteSize, maxDocuments) {\n    var self = this;\n    if (!self.db) throw Error(\"_createCappedCollection called before Connection created?\");\n    var future = new Future();\n    self.db.createCollection(collectionName, {\n      capped: true,\n      size: byteSize,\n      max: maxDocuments\n    }, future.resolver());\n    future.wait();\n  };\n\n  // This should be called synchronously with a write, to create a\n  // transaction on the current write fence, if any. After we can read\n  // the write, and after observers have been notified (or at least,\n  // after the observer notifiers have added themselves to the write\n  // fence), you should call 'committed()' on the object returned.\n  MongoConnection.prototype._maybeBeginWrite = function () {\n    var fence = DDPServer._CurrentWriteFence.get();\n    if (fence) {\n      return fence.beginWrite();\n    } else {\n      return {\n        committed: function () {}\n      };\n    }\n  };\n\n  // Internal interface: adds a callback which is called when the Mongo primary\n  // changes. Returns a stop handle.\n  MongoConnection.prototype._onFailover = function (callback) {\n    return this._onFailoverHook.register(callback);\n  };\n\n  //////////// Public API //////////\n\n  // The write methods block until the database has confirmed the write (it may\n  // not be replicated or stable on disk, but one server has confirmed it) if no\n  // callback is provided. If a callback is provided, then they call the callback\n  // when the write is confirmed. They return nothing on success, and raise an\n  // exception on failure.\n  //\n  // After making a write (with insert, update, remove), observers are\n  // notified asynchronously. If you want to receive a callback once all\n  // of the observer notifications have landed for your write, do the\n  // writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n  // _WriteFence, and then set a callback on the write fence.)\n  //\n  // Since our execution environment is single-threaded, this is\n  // well-defined -- a write \"has been made\" if it's returned, and an\n  // observer \"has been notified\" if its callback has returned.\n\n  var writeCallback = function (write, refresh, callback) {\n    return function (err, result) {\n      if (!err) {\n        // XXX We don't have to run this on error, right?\n        try {\n          refresh();\n        } catch (refreshErr) {\n          if (callback) {\n            callback(refreshErr);\n            return;\n          } else {\n            throw refreshErr;\n          }\n        }\n      }\n      write.committed();\n      if (callback) {\n        callback(err, result);\n      } else if (err) {\n        throw err;\n      }\n    };\n  };\n  var bindEnvironmentForWrite = function (callback) {\n    return Meteor.bindEnvironment(callback, \"Mongo write\");\n  };\n  MongoConnection.prototype._insert = function (collection_name, document, callback) {\n    var self = this;\n    var sendError = function (e) {\n      if (callback) return callback(e);\n      throw e;\n    };\n    if (collection_name === \"___meteor_failure_test_collection\") {\n      var e = new Error(\"Failure test\");\n      e._expectedByTest = true;\n      sendError(e);\n      return;\n    }\n    if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n      sendError(new Error(\"Only plain objects may be inserted into MongoDB\"));\n      return;\n    }\n    var write = self._maybeBeginWrite();\n    var refresh = function () {\n      Meteor.refresh({\n        collection: collection_name,\n        id: document._id\n      });\n    };\n    callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n    try {\n      var collection = self.rawCollection(collection_name);\n      collection.insertOne(replaceTypes(document, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(_ref3 => {\n        let {\n          insertedId\n        } = _ref3;\n        callback(null, insertedId);\n      }).catch(e => {\n        callback(e, null);\n      });\n    } catch (err) {\n      write.committed();\n      throw err;\n    }\n  };\n\n  // Cause queries that may be affected by the selector to poll in this write\n  // fence.\n  MongoConnection.prototype._refresh = function (collectionName, selector) {\n    var refreshKey = {\n      collection: collectionName\n    };\n    // If we know which documents we're removing, don't poll queries that are\n    // specific to other documents. (Note that multiple notifications here should\n    // not cause multiple polls, since all our listener is doing is enqueueing a\n    // poll.)\n    var specificIds = LocalCollection._idsMatchedBySelector(selector);\n    if (specificIds) {\n      _.each(specificIds, function (id) {\n        Meteor.refresh(_.extend({\n          id: id\n        }, refreshKey));\n      });\n    } else {\n      Meteor.refresh(refreshKey);\n    }\n  };\n  MongoConnection.prototype._remove = function (collection_name, selector, callback) {\n    var self = this;\n    if (collection_name === \"___meteor_failure_test_collection\") {\n      var e = new Error(\"Failure test\");\n      e._expectedByTest = true;\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n    var write = self._maybeBeginWrite();\n    var refresh = function () {\n      self._refresh(collection_name, selector);\n    };\n    callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n    try {\n      var collection = self.rawCollection(collection_name);\n      collection.deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(_ref4 => {\n        let {\n          deletedCount\n        } = _ref4;\n        callback(null, transformResult({\n          result: {\n            modifiedCount: deletedCount\n          }\n        }).numberAffected);\n      }).catch(err => {\n        callback(err);\n      });\n    } catch (err) {\n      write.committed();\n      throw err;\n    }\n  };\n  MongoConnection.prototype._dropCollection = function (collectionName, cb) {\n    var self = this;\n    var write = self._maybeBeginWrite();\n    var refresh = function () {\n      Meteor.refresh({\n        collection: collectionName,\n        id: null,\n        dropCollection: true\n      });\n    };\n    cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n    try {\n      var collection = self.rawCollection(collectionName);\n      collection.drop(cb);\n    } catch (e) {\n      write.committed();\n      throw e;\n    }\n  };\n\n  // For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n  // because it lets the test's fence wait for it to be complete.\n  MongoConnection.prototype._dropDatabase = function (cb) {\n    var self = this;\n    var write = self._maybeBeginWrite();\n    var refresh = function () {\n      Meteor.refresh({\n        dropDatabase: true\n      });\n    };\n    cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n    try {\n      self.db.dropDatabase(cb);\n    } catch (e) {\n      write.committed();\n      throw e;\n    }\n  };\n  MongoConnection.prototype._update = function (collection_name, selector, mod, options, callback) {\n    var self = this;\n    if (!callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n    if (collection_name === \"___meteor_failure_test_collection\") {\n      var e = new Error(\"Failure test\");\n      e._expectedByTest = true;\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    // explicit safety check. null and undefined can crash the mongo\n    // driver. Although the node driver and minimongo do 'support'\n    // non-object modifier in that they don't crash, they are not\n    // meaningful operations and do not do anything. Defensively throw an\n    // error here.\n    if (!mod || typeof mod !== 'object') throw new Error(\"Invalid modifier. Modifier must be an object.\");\n    if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n      throw new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");\n    }\n    if (!options) options = {};\n    var write = self._maybeBeginWrite();\n    var refresh = function () {\n      self._refresh(collection_name, selector);\n    };\n    callback = writeCallback(write, refresh, callback);\n    try {\n      var collection = self.rawCollection(collection_name);\n      var mongoOpts = {\n        safe: true\n      };\n      // Add support for filtered positional operator\n      if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n      // explictly enumerate options that minimongo supports\n      if (options.upsert) mongoOpts.upsert = true;\n      if (options.multi) mongoOpts.multi = true;\n      // Lets you get a more more full result from MongoDB. Use with caution:\n      // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n      // with simulated upsert.\n      if (options.fullResult) mongoOpts.fullResult = true;\n      var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n      var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n      var isModify = LocalCollection._isModificationMod(mongoMod);\n      if (options._forbidReplace && !isModify) {\n        var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n\n      // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n      // selector and mod.  We assume it doesn't matter, as far as\n      // the behavior of modifiers is concerned, whether `_modify`\n      // is run on EJSON or on mongo-converted EJSON.\n\n      // Run this code up front so that it fails fast if someone uses\n      // a Mongo update operator we don't support.\n      let knownId;\n      if (options.upsert) {\n        try {\n          let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n          knownId = newDoc._id;\n        } catch (err) {\n          if (callback) {\n            return callback(err);\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (options.upsert && !isModify && !knownId && options.insertedId && !(options.insertedId instanceof Mongo.ObjectID && options.generatedId)) {\n        // In case of an upsert with a replacement, where there is no _id defined\n        // in either the query or the replacement doc, mongo will generate an id itself.\n        // Therefore we need this special strategy if we want to control the id ourselves.\n\n        // We don't need to do this when:\n        // - This is not a replacement, so we can add an _id to $setOnInsert\n        // - The id is defined by query or mod we can just add it to the replacement doc\n        // - The user did not specify any id preference and the id is a Mongo ObjectId,\n        //     then we can just let Mongo generate the id\n\n        simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options,\n        // This callback does not need to be bindEnvironment'ed because\n        // simulateUpsertWithInsertedId() wraps it and then passes it through\n        // bindEnvironmentForWrite.\n        function (error, result) {\n          // If we got here via a upsert() call, then options._returnObject will\n          // be set and we should return the whole object. Otherwise, we should\n          // just return the number of affected docs to match the mongo API.\n          if (result && !options._returnObject) {\n            callback(error, result.numberAffected);\n          } else {\n            callback(error, result);\n          }\n        });\n      } else {\n        if (options.upsert && !knownId && options.insertedId && isModify) {\n          if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n            mongoMod.$setOnInsert = {};\n          }\n          knownId = options.insertedId;\n          Object.assign(mongoMod.$setOnInsert, replaceTypes({\n            _id: options.insertedId\n          }, replaceMeteorAtomWithMongo));\n        }\n        const strings = Object.keys(mongoMod).filter(key => !key.startsWith(\"$\"));\n        let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n        updateMethod = updateMethod === 'updateMany' && !mongoOpts.multi ? 'updateOne' : updateMethod;\n        collection[updateMethod].bind(collection)(mongoSelector, mongoMod, mongoOpts,\n        // mongo driver now returns undefined for err in the callback\n        bindEnvironmentForWrite(function () {\n          let err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          let result = arguments.length > 1 ? arguments[1] : undefined;\n          if (!err) {\n            var meteorResult = transformResult({\n              result\n            });\n            if (meteorResult && options._returnObject) {\n              // If this was an upsert() call, and we ended up\n              // inserting a new doc and we know its id, then\n              // return that id as well.\n              if (options.upsert && meteorResult.insertedId) {\n                if (knownId) {\n                  meteorResult.insertedId = knownId;\n                } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                  meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n                }\n              }\n              callback(err, meteorResult);\n            } else {\n              callback(err, meteorResult.numberAffected);\n            }\n          } else {\n            callback(err);\n          }\n        }));\n      }\n    } catch (e) {\n      write.committed();\n      throw e;\n    }\n  };\n  var transformResult = function (driverResult) {\n    var meteorResult = {\n      numberAffected: 0\n    };\n    if (driverResult) {\n      var mongoResult = driverResult.result;\n      // On updates with upsert:true, the inserted values come as a list of\n      // upserted values -- even with options.multi, when the upsert does insert,\n      // it only inserts one element.\n      if (mongoResult.upsertedCount) {\n        meteorResult.numberAffected = mongoResult.upsertedCount;\n        if (mongoResult.upsertedId) {\n          meteorResult.insertedId = mongoResult.upsertedId;\n        }\n      } else {\n        // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n        // field and so we are using modifiedCount instead\n        meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n      }\n    }\n    return meteorResult;\n  };\n  var NUM_OPTIMISTIC_TRIES = 3;\n\n  // exposed for testing\n  MongoConnection._isCannotChangeIdError = function (err) {\n    // Mongo 3.2.* returns error as next Object:\n    // {name: String, code: Number, errmsg: String}\n    // Older Mongo returns:\n    // {name: String, code: Number, err: String}\n    var error = err.errmsg || err.err;\n\n    // We don't use the error code here\n    // because the error code we observed it producing (16837) appears to be\n    // a far more generic error code based on examining the source.\n    if (error.indexOf('The _id field cannot be changed') === 0 || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n      return true;\n    }\n    return false;\n  };\n  var simulateUpsertWithInsertedId = function (collection, selector, mod, options, callback) {\n    // STRATEGY: First try doing an upsert with a generated ID.\n    // If this throws an error about changing the ID on an existing document\n    // then without affecting the database, we know we should probably try\n    // an update without the generated ID. If it affected 0 documents,\n    // then without affecting the database, we the document that first\n    // gave the error is probably removed and we need to try an insert again\n    // We go back to step one and repeat.\n    // Like all \"optimistic write\" schemes, we rely on the fact that it's\n    // unlikely our writes will continue to be interfered with under normal\n    // circumstances (though sufficiently heavy contention with writers\n    // disagreeing on the existence of an object will cause writes to fail\n    // in theory).\n\n    var insertedId = options.insertedId; // must exist\n    var mongoOptsForUpdate = {\n      safe: true,\n      multi: options.multi\n    };\n    var mongoOptsForInsert = {\n      safe: true,\n      upsert: true\n    };\n    var replacementWithId = Object.assign(replaceTypes({\n      _id: insertedId\n    }, replaceMeteorAtomWithMongo), mod);\n    var tries = NUM_OPTIMISTIC_TRIES;\n    var doUpdate = function () {\n      tries--;\n      if (!tries) {\n        callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n      } else {\n        let method = collection.updateMany;\n        if (!Object.keys(mod).some(key => key.startsWith(\"$\"))) {\n          method = collection.replaceOne.bind(collection);\n        }\n        method(selector, mod, mongoOptsForUpdate, bindEnvironmentForWrite(function (err, result) {\n          if (err) {\n            callback(err);\n          } else if (result && (result.modifiedCount || result.upsertedCount)) {\n            callback(null, {\n              numberAffected: result.modifiedCount || result.upsertedCount,\n              insertedId: result.upsertedId || undefined\n            });\n          } else {\n            doConditionalInsert();\n          }\n        }));\n      }\n    };\n    var doConditionalInsert = function () {\n      collection.replaceOne(selector, replacementWithId, mongoOptsForInsert, bindEnvironmentForWrite(function (err, result) {\n        if (err) {\n          // figure out if this is a\n          // \"cannot change _id of document\" error, and\n          // if so, try doUpdate() again, up to 3 times.\n          if (MongoConnection._isCannotChangeIdError(err)) {\n            doUpdate();\n          } else {\n            callback(err);\n          }\n        } else {\n          callback(null, {\n            numberAffected: result.upsertedCount,\n            insertedId: result.upsertedId\n          });\n        }\n      }));\n    };\n    doUpdate();\n  };\n  _.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n    MongoConnection.prototype[method] = function /* arguments */\n    () {\n      var self = this;\n      return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n    };\n  });\n\n  // XXX MongoConnection.upsert() does not return the id of the inserted document\n  // unless you set it explicitly in the selector or modifier (as a replacement\n  // doc).\n  MongoConnection.prototype.upsert = function (collectionName, selector, mod, options, callback) {\n    var self = this;\n    if (typeof options === \"function\" && !callback) {\n      callback = options;\n      options = {};\n    }\n    return self.update(collectionName, selector, mod, _.extend({}, options, {\n      upsert: true,\n      _returnObject: true\n    }), callback);\n  };\n  MongoConnection.prototype.find = function (collectionName, selector, options) {\n    var self = this;\n    if (arguments.length === 1) selector = {};\n    return new Cursor(self, new CursorDescription(collectionName, selector, options));\n  };\n  MongoConnection.prototype.findOneAsync = function (collection_name, selector, options) {\n    return Promise.asyncApply(() => {\n      var self = this;\n      if (arguments.length === 1) selector = {};\n      options = options || {};\n      options.limit = 1;\n      return Promise.await(self.find(collection_name, selector, options).fetchAsync())[0];\n    });\n  };\n  MongoConnection.prototype.findOne = function (collection_name, selector, options) {\n    var self = this;\n    return Future.fromPromise(self.findOneAsync(collection_name, selector, options)).wait();\n  };\n  MongoConnection.prototype.createIndexAsync = function (collectionName, index, options) {\n    var self = this;\n\n    // We expect this function to be called at startup, not from within a method,\n    // so we don't interact with the write fence.\n    var collection = self.rawCollection(collectionName);\n    return collection.createIndex(index, options);\n  };\n\n  // We'll actually design an index API later. For now, we just pass through to\n  // Mongo's, but make it synchronous.\n  MongoConnection.prototype.createIndex = function (collectionName, index, options) {\n    var self = this;\n    return Future.fromPromise(self.createIndexAsync(collectionName, index, options));\n  };\n  MongoConnection.prototype.countDocuments = function (collectionName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n    const collection = this.rawCollection(collectionName);\n    return collection.countDocuments(...args);\n  };\n  MongoConnection.prototype.estimatedDocumentCount = function (collectionName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n    const collection = this.rawCollection(collectionName);\n    return collection.estimatedDocumentCount(...args);\n  };\n  MongoConnection.prototype._ensureIndex = MongoConnection.prototype.createIndex;\n  MongoConnection.prototype._dropIndex = function (collectionName, index) {\n    var self = this;\n\n    // This function is only used by test code, not within a method, so we don't\n    // interact with the write fence.\n    var collection = self.rawCollection(collectionName);\n    var future = new Future();\n    var indexName = collection.dropIndex(index, future.resolver());\n    future.wait();\n  };\n\n  // CURSORS\n\n  // There are several classes which relate to cursors:\n  //\n  // CursorDescription represents the arguments used to construct a cursor:\n  // collectionName, selector, and (find) options.  Because it is used as a key\n  // for cursor de-dup, everything in it should either be JSON-stringifiable or\n  // not affect observeChanges output (eg, options.transform functions are not\n  // stringifiable but do not affect observeChanges).\n  //\n  // SynchronousCursor is a wrapper around a MongoDB cursor\n  // which includes fully-synchronous versions of forEach, etc.\n  //\n  // Cursor is the cursor object returned from find(), which implements the\n  // documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n  // SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n  // like fetch or forEach on it).\n  //\n  // ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n  // reference to an ObserveMultiplexer.\n  //\n  // ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n  // single observe driver.\n  //\n  // There are two \"observe drivers\" which drive ObserveMultiplexers:\n  //   - PollingObserveDriver caches the results of a query and reruns it when\n  //     necessary.\n  //   - OplogObserveDriver follows the Mongo operation log to directly observe\n  //     database changes.\n  // Both implementations follow the same simple interface: when you create them,\n  // they start sending observeChanges callbacks (and a ready() invocation) to\n  // their ObserveMultiplexer, and you stop them by calling their stop() method.\n\n  CursorDescription = function (collectionName, selector, options) {\n    var self = this;\n    self.collectionName = collectionName;\n    self.selector = Mongo.Collection._rewriteSelector(selector);\n    self.options = options || {};\n  };\n  Cursor = function (mongo, cursorDescription) {\n    var self = this;\n    self._mongo = mongo;\n    self._cursorDescription = cursorDescription;\n    self._synchronousCursor = null;\n  };\n  function setupSynchronousCursor(cursor, method) {\n    // You can only observe a tailable cursor.\n    if (cursor._cursorDescription.options.tailable) throw new Error('Cannot call ' + method + ' on a tailable cursor');\n    if (!cursor._synchronousCursor) {\n      cursor._synchronousCursor = cursor._mongo._createSynchronousCursor(cursor._cursorDescription, {\n        // Make sure that the \"cursor\" argument to forEach/map callbacks is the\n        // Cursor, not the SynchronousCursor.\n        selfForIteration: cursor,\n        useTransform: true\n      });\n    }\n    return cursor._synchronousCursor;\n  }\n  Cursor.prototype.count = function () {\n    const collection = this._mongo.rawCollection(this._cursorDescription.collectionName);\n    return Promise.await(collection.countDocuments(replaceTypes(this._cursorDescription.selector, replaceMeteorAtomWithMongo), replaceTypes(this._cursorDescription.options, replaceMeteorAtomWithMongo)));\n  };\n  [...ASYNC_CURSOR_METHODS, Symbol.iterator, Symbol.asyncIterator].forEach(methodName => {\n    // count is handled specially since we don't want to create a cursor.\n    // it is still included in ASYNC_CURSOR_METHODS because we still want an async version of it to exist.\n    if (methodName !== 'count') {\n      Cursor.prototype[methodName] = function () {\n        const cursor = setupSynchronousCursor(this, methodName);\n        return cursor[methodName](...arguments);\n      };\n    }\n\n    // These methods are handled separately.\n    if (methodName === Symbol.iterator || methodName === Symbol.asyncIterator) {\n      return;\n    }\n    const methodNameAsync = getAsyncMethodName(methodName);\n    Cursor.prototype[methodNameAsync] = function () {\n      try {\n        this[methodName].isCalledFromAsync = true;\n        return Promise.resolve(this[methodName](...arguments));\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    };\n  });\n  Cursor.prototype.getTransform = function () {\n    return this._cursorDescription.options.transform;\n  };\n\n  // When you call Meteor.publish() with a function that returns a Cursor, we need\n  // to transmute it into the equivalent subscription.  This is the function that\n  // does that.\n\n  Cursor.prototype._publishCursor = function (sub) {\n    var self = this;\n    var collection = self._cursorDescription.collectionName;\n    return Mongo.Collection._publishCursor(self, sub, collection);\n  };\n\n  // Used to guarantee that publish functions return at most one cursor per\n  // collection. Private, because we might later have cursors that include\n  // documents from multiple collections somehow.\n  Cursor.prototype._getCollectionName = function () {\n    var self = this;\n    return self._cursorDescription.collectionName;\n  };\n  Cursor.prototype.observe = function (callbacks) {\n    var self = this;\n    return LocalCollection._observeFromObserveChanges(self, callbacks);\n  };\n  Cursor.prototype.observeChanges = function (callbacks) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var self = this;\n    var methods = ['addedAt', 'added', 'changedAt', 'changed', 'removedAt', 'removed', 'movedTo'];\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n    let exceptionName = callbacks._fromObserve ? 'observe' : 'observeChanges';\n    exceptionName += ' callback';\n    methods.forEach(function (method) {\n      if (callbacks[method] && typeof callbacks[method] == \"function\") {\n        callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n      }\n    });\n    return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks, options.nonMutatingCallbacks);\n  };\n  MongoConnection.prototype._createSynchronousCursor = function (cursorDescription, options) {\n    var self = this;\n    options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n    var collection = self.rawCollection(cursorDescription.collectionName);\n    var cursorOptions = cursorDescription.options;\n    var mongoOptions = {\n      sort: cursorOptions.sort,\n      limit: cursorOptions.limit,\n      skip: cursorOptions.skip,\n      projection: cursorOptions.fields || cursorOptions.projection,\n      readPreference: cursorOptions.readPreference\n    };\n\n    // Do we want a tailable cursor (which only works on capped collections)?\n    if (cursorOptions.tailable) {\n      mongoOptions.numberOfRetries = -1;\n    }\n    var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), mongoOptions);\n\n    // Do we want a tailable cursor (which only works on capped collections)?\n    if (cursorOptions.tailable) {\n      // We want a tailable cursor...\n      dbCursor.addCursorFlag(\"tailable\", true);\n      // ... and for the server to wait a bit if any getMore has no data (rather\n      // than making us put the relevant sleeps in the client)...\n      dbCursor.addCursorFlag(\"awaitData\", true);\n\n      // And if this is on the oplog collection and the cursor specifies a 'ts',\n      // then set the undocumented oplog replay flag, which does a special scan to\n      // find the first document (instead of creating an index on ts). This is a\n      // very hard-coded Mongo flag which only works on the oplog collection and\n      // only works with the ts field.\n      if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n        dbCursor.addCursorFlag(\"oplogReplay\", true);\n      }\n    }\n    if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n      dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n    }\n    if (typeof cursorOptions.hint !== 'undefined') {\n      dbCursor = dbCursor.hint(cursorOptions.hint);\n    }\n    return new SynchronousCursor(dbCursor, cursorDescription, options, collection);\n  };\n  var SynchronousCursor = function (dbCursor, cursorDescription, options, collection) {\n    var self = this;\n    options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n    self._dbCursor = dbCursor;\n    self._cursorDescription = cursorDescription;\n    // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n    // inside a user-visible Cursor, we want to provide the outer cursor!\n    self._selfForIteration = options.selfForIteration || self;\n    if (options.useTransform && cursorDescription.options.transform) {\n      self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);\n    } else {\n      self._transform = null;\n    }\n    self._synchronousCount = Future.wrap(collection.countDocuments.bind(collection, replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), replaceTypes(cursorDescription.options, replaceMeteorAtomWithMongo)));\n    self._visitedIds = new LocalCollection._IdMap();\n  };\n  _.extend(SynchronousCursor.prototype, {\n    // Returns a Promise for the next object from the underlying cursor (before\n    // the Mongo->Meteor type replacement).\n    _rawNextObjectPromise: function () {\n      const self = this;\n      return new Promise((resolve, reject) => {\n        self._dbCursor.next((err, doc) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(doc);\n          }\n        });\n      });\n    },\n    // Returns a Promise for the next object from the cursor, skipping those whose\n    // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n    _nextObjectPromise: function () {\n      return Promise.asyncApply(() => {\n        var self = this;\n        while (true) {\n          var doc = Promise.await(self._rawNextObjectPromise());\n          if (!doc) return null;\n          doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n          if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n            // Did Mongo give us duplicate documents in the same cursor? If so,\n            // ignore this one. (Do this before the transform, since transform might\n            // return some unrelated value.) We don't do this for tailable cursors,\n            // because we want to maintain O(1) memory usage. And if there isn't _id\n            // for some reason (maybe it's the oplog), then we don't do this either.\n            // (Be careful to do this for falsey but existing _id, though.)\n            if (self._visitedIds.has(doc._id)) continue;\n            self._visitedIds.set(doc._id, true);\n          }\n          if (self._transform) doc = self._transform(doc);\n          return doc;\n        }\n      });\n    },\n    // Returns a promise which is resolved with the next object (like with\n    // _nextObjectPromise) or rejected if the cursor doesn't return within\n    // timeoutMS ms.\n    _nextObjectPromiseWithTimeout: function (timeoutMS) {\n      const self = this;\n      if (!timeoutMS) {\n        return self._nextObjectPromise();\n      }\n      const nextObjectPromise = self._nextObjectPromise();\n      const timeoutErr = new Error('Client-side timeout waiting for next object');\n      const timeoutPromise = new Promise((resolve, reject) => {\n        const timer = setTimeout(() => {\n          reject(timeoutErr);\n        }, timeoutMS);\n      });\n      return Promise.race([nextObjectPromise, timeoutPromise]).catch(err => {\n        if (err === timeoutErr) {\n          self.close();\n        }\n        throw err;\n      });\n    },\n    _nextObject: function () {\n      var self = this;\n      return self._nextObjectPromise().await();\n    },\n    forEach: function (callback, thisArg) {\n      var self = this;\n      const wrappedFn = Meteor.wrapFn(callback);\n\n      // Get back to the beginning.\n      self._rewind();\n\n      // We implement the loop ourself instead of using self._dbCursor.each,\n      // because \"each\" will call its callback outside of a fiber which makes it\n      // much more complex to make this function synchronous.\n      var index = 0;\n      while (true) {\n        var doc = self._nextObject();\n        if (!doc) return;\n        wrappedFn.call(thisArg, doc, index++, self._selfForIteration);\n      }\n    },\n    // XXX Allow overlapping callback executions if callback yields.\n    map: function (callback, thisArg) {\n      var self = this;\n      const wrappedFn = Meteor.wrapFn(callback);\n      var res = [];\n      self.forEach(function (doc, index) {\n        res.push(wrappedFn.call(thisArg, doc, index, self._selfForIteration));\n      });\n      return res;\n    },\n    _rewind: function () {\n      var self = this;\n\n      // known to be synchronous\n      self._dbCursor.rewind();\n      self._visitedIds = new LocalCollection._IdMap();\n    },\n    // Mostly usable for tailable cursors.\n    close: function () {\n      var self = this;\n      self._dbCursor.close();\n    },\n    fetch: function () {\n      var self = this;\n      return self.map(_.identity);\n    },\n    count: function () {\n      var self = this;\n      return self._synchronousCount().wait();\n    },\n    // This method is NOT wrapped in Cursor.\n    getRawObjects: function (ordered) {\n      var self = this;\n      if (ordered) {\n        return self.fetch();\n      } else {\n        var results = new LocalCollection._IdMap();\n        self.forEach(function (doc) {\n          results.set(doc._id, doc);\n        });\n        return results;\n      }\n    }\n  });\n  SynchronousCursor.prototype[Symbol.iterator] = function () {\n    var self = this;\n\n    // Get back to the beginning.\n    self._rewind();\n    return {\n      next() {\n        const doc = self._nextObject();\n        return doc ? {\n          value: doc\n        } : {\n          done: true\n        };\n      }\n    };\n  };\n  SynchronousCursor.prototype[Symbol.asyncIterator] = function () {\n    const syncResult = this[Symbol.iterator]();\n    return {\n      next() {\n        return Promise.asyncApply(() => {\n          return Promise.resolve(syncResult.next());\n        });\n      }\n    };\n  };\n\n  // Tails the cursor described by cursorDescription, most likely on the\n  // oplog. Calls docCallback with each document found. Ignores errors and just\n  // restarts the tail on error.\n  //\n  // If timeoutMS is set, then if we don't get a new document every timeoutMS,\n  // kill and restart the cursor. This is primarily a workaround for #8598.\n  MongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n    var self = this;\n    if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");\n    var cursor = self._createSynchronousCursor(cursorDescription);\n    var stopped = false;\n    var lastTS;\n    var loop = function () {\n      var doc = null;\n      while (true) {\n        if (stopped) return;\n        try {\n          doc = cursor._nextObjectPromiseWithTimeout(timeoutMS).await();\n        } catch (err) {\n          // There's no good way to figure out if this was actually an error from\n          // Mongo, or just client-side (including our own timeout error). Ah\n          // well. But either way, we need to retry the cursor (unless the failure\n          // was because the observe got stopped).\n          doc = null;\n        }\n        // Since we awaited a promise above, we need to check again to see if\n        // we've been stopped before calling the callback.\n        if (stopped) return;\n        if (doc) {\n          // If a tailable cursor contains a \"ts\" field, use it to recreate the\n          // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n          // the oplog, and there's a special flag that lets you do binary search\n          // on it instead of needing to use an index.)\n          lastTS = doc.ts;\n          docCallback(doc);\n        } else {\n          var newSelector = _.clone(cursorDescription.selector);\n          if (lastTS) {\n            newSelector.ts = {\n              $gt: lastTS\n            };\n          }\n          cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options));\n          // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n          // setTimeout, we peg the CPU at 100% and never notice the actual\n          // failover.\n          Meteor.setTimeout(loop, 100);\n          break;\n        }\n      }\n    };\n    Meteor.defer(loop);\n    return {\n      stop: function () {\n        stopped = true;\n        cursor.close();\n      }\n    };\n  };\n  MongoConnection.prototype._observeChanges = function (cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n    var self = this;\n    if (cursorDescription.options.tailable) {\n      return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n    }\n\n    // You may not filter out _id when observing changes, because the id is a core\n    // part of the observeChanges API.\n    const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n    if (fieldsOptions && (fieldsOptions._id === 0 || fieldsOptions._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n    var observeKey = EJSON.stringify(_.extend({\n      ordered: ordered\n    }, cursorDescription));\n    var multiplexer, observeDriver;\n    var firstHandle = false;\n\n    // Find a matching ObserveMultiplexer, or create a new one. This next block is\n    // guaranteed to not yield (and it doesn't call anything that can observe a\n    // new query), so no other calls to this function can interleave with it.\n    Meteor._noYieldsAllowed(function () {\n      if (_.has(self._observeMultiplexers, observeKey)) {\n        multiplexer = self._observeMultiplexers[observeKey];\n      } else {\n        firstHandle = true;\n        // Create a new ObserveMultiplexer.\n        multiplexer = new ObserveMultiplexer({\n          ordered: ordered,\n          onStop: function () {\n            delete self._observeMultiplexers[observeKey];\n            observeDriver.stop();\n          }\n        });\n        self._observeMultiplexers[observeKey] = multiplexer;\n      }\n    });\n    var observeHandle = new ObserveHandle(multiplexer, callbacks, nonMutatingCallbacks);\n    if (firstHandle) {\n      var matcher, sorter;\n      var canUseOplog = _.all([function () {\n        // At a bare minimum, using the oplog requires us to have an oplog, to\n        // want unordered callbacks, and to not want a callback on the polls\n        // that won't happen.\n        return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;\n      }, function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }, function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      }, function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort) return true;\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }], function (f) {\n        return f();\n      }); // invoke each function\n\n      var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n      observeDriver = new driverClass({\n        cursorDescription: cursorDescription,\n        mongoHandle: self,\n        multiplexer: multiplexer,\n        ordered: ordered,\n        matcher: matcher,\n        // ignored by polling\n        sorter: sorter,\n        // ignored by polling\n        _testOnlyPollCallback: callbacks._testOnlyPollCallback\n      });\n\n      // This field is only set for use in tests.\n      multiplexer._observeDriver = observeDriver;\n    }\n\n    // Blocks until the initial adds have been sent.\n    multiplexer.addHandleAndSendInitialAdds(observeHandle);\n    return observeHandle;\n  };\n\n  // Listen for the invalidation messages that will trigger us to poll the\n  // database for changes. If this selector specifies specific IDs, specify them\n  // here, so that updates to different specific IDs don't cause us to poll.\n  // listenCallback is the same kind of (notification, complete) callback passed\n  // to InvalidationCrossbar.listen.\n\n  listenAll = function (cursorDescription, listenCallback) {\n    var listeners = [];\n    forEachTrigger(cursorDescription, function (trigger) {\n      listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback));\n    });\n    return {\n      stop: function () {\n        _.each(listeners, function (listener) {\n          listener.stop();\n        });\n      }\n    };\n  };\n  forEachTrigger = function (cursorDescription, triggerCallback) {\n    var key = {\n      collection: cursorDescription.collectionName\n    };\n    var specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector);\n    if (specificIds) {\n      _.each(specificIds, function (id) {\n        triggerCallback(_.extend({\n          id: id\n        }, key));\n      });\n      triggerCallback(_.extend({\n        dropCollection: true,\n        id: null\n      }, key));\n    } else {\n      triggerCallback(key);\n    }\n    // Everyone cares about the database being dropped.\n    triggerCallback({\n      dropDatabase: true\n    });\n  };\n\n  // observeChanges for tailable cursors on capped collections.\n  //\n  // Some differences from normal cursors:\n  //   - Will never produce anything other than 'added' or 'addedBefore'. If you\n  //     do update a document that has already been produced, this will not notice\n  //     it.\n  //   - If you disconnect and reconnect from Mongo, it will essentially restart\n  //     the query, which will lead to duplicate results. This is pretty bad,\n  //     but if you include a field called 'ts' which is inserted as\n  //     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n  //     current Mongo-style timestamp), we'll be able to find the place to\n  //     restart properly. (This field is specifically understood by Mongo with an\n  //     optimization which allows it to find the right place to start without\n  //     an index on ts. It's how the oplog works.)\n  //   - No callbacks are triggered synchronously with the call (there's no\n  //     differentiation between \"initial data\" and \"later changes\"; everything\n  //     that matches the query gets sent asynchronously).\n  //   - De-duplication is not implemented.\n  //   - Does not yet interact with the write fence. Probably, this should work by\n  //     ignoring removes (which don't work on capped collections) and updates\n  //     (which don't affect tailable cursors), and just keeping track of the ID\n  //     of the inserted object, and closing the write fence once you get to that\n  //     ID (or timestamp?).  This doesn't work well if the document doesn't match\n  //     the query, though.  On the other hand, the write fence can close\n  //     immediately if it does not match the query. So if we trust minimongo\n  //     enough to accurately evaluate the query against the write fence, we\n  //     should be able to do this...  Of course, minimongo doesn't even support\n  //     Mongo Timestamps yet.\n  MongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n    var self = this;\n\n    // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n    // error if you didn't provide them.\n    if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n      throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n    }\n    return self.tail(cursorDescription, function (doc) {\n      var id = doc._id;\n      delete doc._id;\n      // The ts is an implementation detail. Hide it.\n      delete doc.ts;\n      if (ordered) {\n        callbacks.addedBefore(id, doc, null);\n      } else {\n        callbacks.added(id, doc);\n      }\n    });\n  };\n\n  // XXX We probably need to find a better way to expose this. Right now\n  // it's only used by tests, but in fact you need it in normal\n  // operation to interact with capped collections.\n  MongoInternals.MongoTimestamp = MongoDB.Timestamp;\n  MongoInternals.Connection = MongoConnection;\n}.call(this, module);","map":{"version":3,"names":["_objectSpread","module1","link","default","v","normalizeProjection","DocFetcher","ASYNC_CURSOR_METHODS","getAsyncMethodName","path","require","util","MongoDB","NpmModuleMongodb","Future","Npm","MongoInternals","NpmModules","mongodb","version","NpmModuleMongodbVersion","module","NpmModule","FILE_ASSET_SUFFIX","ASSETS_FOLDER","APP_FOLDER","replaceNames","filter","thing","_","isArray","map","bind","ret","each","value","key","Timestamp","prototype","clone","makeMongoLegal","name","unmakeMongoLegal","substr","replaceMongoAtomWithMeteor","document","Binary","sub_type","buffer","Uint8Array","ObjectID","Mongo","toHexString","Decimal128","Decimal","toString","size","EJSON","fromJSONValue","undefined","replaceMeteorAtomWithMongo","isBinary","Buffer","from","fromString","_isCustomType","toJSONValue","replaceTypes","atomTransformer","replacedTopLevelAtom","val","valReplaced","MongoConnection","url","options","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","self","_observeMultiplexers","_onFailoverHook","Hook","userOptions","_connectionOptions","Meteor","settings","packages","mongo","mongoOptions","Object","assign","ignoreUndefined","has","maxPoolSize","entries","_ref","endsWith","forEach","_ref2","optionName","replace","join","Assets","getServerDir","db","_oplogHandle","_docFetcher","client","MongoClient","on","bindEnvironment","event","previousDescription","type","newDescription","callback","oplogUrl","Package","OplogHandle","databaseName","Promise","await","connect","close","Error","oplogHandle","stop","wrap","wait","rawCollection","collectionName","collection","_createCappedCollection","byteSize","maxDocuments","future","createCollection","capped","max","resolver","_maybeBeginWrite","fence","DDPServer","_CurrentWriteFence","get","beginWrite","committed","_onFailover","register","writeCallback","write","refresh","err","result","refreshErr","bindEnvironmentForWrite","_insert","collection_name","sendError","e","_expectedByTest","LocalCollection","_isPlainObject","id","_id","insertOne","safe","then","_ref3","insertedId","catch","_refresh","selector","refreshKey","specificIds","_idsMatchedBySelector","extend","_remove","deleteMany","_ref4","deletedCount","transformResult","modifiedCount","numberAffected","_dropCollection","cb","dropCollection","drop","_dropDatabase","dropDatabase","_update","mod","Function","mongoOpts","arrayFilters","upsert","multi","fullResult","mongoSelector","mongoMod","isModify","_isModificationMod","_forbidReplace","knownId","newDoc","_createUpsertDocument","generatedId","simulateUpsertWithInsertedId","error","_returnObject","hasOwnProperty","$setOnInsert","strings","keys","startsWith","updateMethod","length","arguments","meteorResult","driverResult","mongoResult","upsertedCount","upsertedId","n","matchedCount","NUM_OPTIMISTIC_TRIES","_isCannotChangeIdError","errmsg","indexOf","mongoOptsForUpdate","mongoOptsForInsert","replacementWithId","tries","doUpdate","method","updateMany","some","replaceOne","doConditionalInsert","wrapAsync","apply","update","find","Cursor","CursorDescription","findOneAsync","asyncApply","limit","fetchAsync","findOne","fromPromise","createIndexAsync","index","createIndex","countDocuments","_len","args","Array","_key","arg","estimatedDocumentCount","_len2","_key2","_ensureIndex","_dropIndex","indexName","dropIndex","Collection","_rewriteSelector","cursorDescription","_mongo","_cursorDescription","_synchronousCursor","setupSynchronousCursor","cursor","tailable","_createSynchronousCursor","selfForIteration","useTransform","count","Symbol","iterator","asyncIterator","methodName","methodNameAsync","isCalledFromAsync","resolve","reject","getTransform","transform","_publishCursor","sub","_getCollectionName","observe","callbacks","_observeFromObserveChanges","observeChanges","methods","ordered","_observeChangesCallbacksAreOrdered","exceptionName","_fromObserve","_observeChanges","nonMutatingCallbacks","pick","cursorOptions","sort","skip","projection","fields","readPreference","numberOfRetries","dbCursor","addCursorFlag","OPLOG_COLLECTION","ts","maxTimeMs","maxTimeMS","hint","SynchronousCursor","_dbCursor","_selfForIteration","_transform","wrapTransform","_synchronousCount","_visitedIds","_IdMap","_rawNextObjectPromise","next","doc","_nextObjectPromise","set","_nextObjectPromiseWithTimeout","timeoutMS","nextObjectPromise","timeoutErr","timeoutPromise","timer","setTimeout","race","_nextObject","thisArg","wrappedFn","wrapFn","_rewind","call","res","push","rewind","fetch","identity","getRawObjects","results","done","syncResult","tail","docCallback","stopped","lastTS","loop","newSelector","$gt","defer","_observeChangesTailable","fieldsOptions","observeKey","stringify","multiplexer","observeDriver","firstHandle","_noYieldsAllowed","ObserveMultiplexer","onStop","observeHandle","ObserveHandle","matcher","sorter","canUseOplog","all","_testOnlyPollCallback","Minimongo","Matcher","OplogObserveDriver","cursorSupported","Sorter","f","driverClass","PollingObserveDriver","mongoHandle","_observeDriver","addHandleAndSendInitialAdds","listenAll","listenCallback","listeners","forEachTrigger","trigger","_InvalidationCrossbar","listen","listener","triggerCallback","addedBefore","added","MongoTimestamp","Connection"],"sources":["packages/mongo/mongo_driver.js"],"sourcesContent":["import { normalizeProjection } from \"./mongo_utils\";\n\n/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */\n\nconst path = require(\"path\");\nconst util = require(\"util\");\n\n/** @type {import('mongodb')} */\nvar MongoDB = NpmModuleMongodb;\nvar Future = Npm.require('fibers/future');\nimport { DocFetcher } from \"./doc_fetcher.js\";\nimport {\n  ASYNC_CURSOR_METHODS,\n  getAsyncMethodName\n} from \"meteor/minimongo/constants\";\n\nMongoInternals = {};\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = MongoDB;\n\nconst FILE_ASSET_SUFFIX = 'Asset';\nconst ASSETS_FOLDER = 'assets';\nconst APP_FOLDER = 'app';\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\nvar replaceNames = function (filter, thing) {\n  if (typeof thing === \"object\" && thing !== null) {\n    if (_.isArray(thing)) {\n      return _.map(thing, _.bind(replaceNames, null, filter));\n    }\n    var ret = {};\n    _.each(thing, function (value, key) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n};\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) { return \"EJSON\" + name; };\nvar unmakeMongoLegal = function (name) { return name.substr(5); };\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    // for backwards compatibility\n    if (document.sub_type !== 0) {\n      return document;\n    }\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Decimal128) {\n    return Decimal(document.toString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(Buffer.from(document));\n  }\n  if (document instanceof MongoDB.Binary) {\n     return document;\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (document instanceof Decimal) {\n    return MongoDB.Decimal128.fromString(document.toString());\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  _.each(document, function (val, key) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = _.clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  const userOptions = {\n    ...(Mongo._connectionOptions || {}),\n    ...(Meteor.settings?.packages?.mongo?.options || {})\n  };\n\n  var mongoOptions = Object.assign({\n    ignoreUndefined: true,\n  }, userOptions);\n\n\n\n  // Internally the oplog connections specify their own maxPoolSize\n  // which we don't want to overwrite with any user defined value\n  if (_.has(options, 'maxPoolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.maxPoolSize = options.maxPoolSize;\n  }\n\n  // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n  // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n  Object.entries(mongoOptions || {})\n    .filter(([key]) => key && key.endsWith(FILE_ASSET_SUFFIX))\n    .forEach(([key, value]) => {\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(),\n        ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n\n  self.db = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n  self.client = new MongoDB.MongoClient(url, mongoOptions);\n  self.db = self.client.db();\n\n  self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n    // When the connection is no longer against the primary node, execute all\n    // failover hooks. This is important for the driver as it has to re-pool the\n    // query when it happens.\n    if (\n      event.previousDescription.type !== 'RSPrimary' &&\n      event.newDescription.type === 'RSPrimary'\n    ) {\n      self._onFailoverHook.each(callback => {\n        callback();\n        return true;\n      });\n    }\n  }));\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n  Promise.await(self.client.connect())\n};\n\nMongoConnection.prototype.close = function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  Future.wrap(_.bind(self.client.close, self.client))(true).wait();\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  return self.db.collection(collectionName);\n};\n\nMongoConnection.prototype._createCappedCollection = function (\n    collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"_createCappedCollection called before Connection created?\");\n\n\n  var future = new Future();\n  self.db.createCollection(\n    collectionName,\n    { capped: true, size: byteSize, max: maxDocuments },\n    future.resolver());\n  future.wait();\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  var fence = DDPServer._CurrentWriteFence.get();\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {committed: function () {}};\n  }\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\n\n//////////// Public API //////////\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype._insert = function (collection_name, document,\n                                              callback) {\n  var self = this;\n\n  var sendError = function (e) {\n    if (callback)\n      return callback(e);\n    throw e;\n  };\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    sendError(e);\n    return;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n        !EJSON._isCustomType(document))) {\n    sendError(new Error(\n      \"Only plain objects may be inserted into MongoDB\"));\n    return;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.insertOne(\n      replaceTypes(document, replaceMeteorAtomWithMongo),\n      {\n        safe: true,\n      }\n    ).then(({insertedId}) => {\n      callback(null, insertedId);\n    }).catch((e) => {\n      callback(e, null)\n    });\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = function (collectionName, selector) {\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      Meteor.refresh(_.extend({id: id}, refreshKey));\n    });\n  } else {\n    Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype._remove = function (collection_name, selector,\n                                              callback) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection\n      .deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n        safe: true,\n      })\n      .then(({ deletedCount }) => {\n        callback(null, transformResult({ result : {modifiedCount : deletedCount} }).numberAffected);\n      }).catch((err) => {\n      callback(err);\n    });\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {\n  var self = this;\n\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collectionName, id: null,\n                    dropCollection: true});\n  };\n\n\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    var collection = self.rawCollection(collectionName);\n    collection.drop(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype._dropDatabase = function (cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ dropDatabase: true });\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    self.db.dropDatabase(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._update = function (collection_name, selector, mod,\n                                              options, callback) {\n  var self = this;\n\n\n\n  if (! callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object')\n    throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n  if (!(LocalCollection._isPlainObject(mod) &&\n        !EJSON._isCustomType(mod))) {\n    throw new Error(\n      \"Only plain objects may be used as replacement\" +\n        \" documents in MongoDB\");\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = writeCallback(write, refresh, callback);\n  try {\n    var collection = self.rawCollection(collection_name);\n    var mongoOpts = {safe: true};\n    // Add support for filtered positional operator\n    if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n    // explictly enumerate options that minimongo supports\n    if (options.upsert) mongoOpts.upsert = true;\n    if (options.multi) mongoOpts.multi = true;\n    // Lets you get a more more full result from MongoDB. Use with caution:\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n    // with simulated upsert.\n    if (options.fullResult) mongoOpts.fullResult = true;\n\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n    var isModify = LocalCollection._isModificationMod(mongoMod);\n\n    if (options._forbidReplace && !isModify) {\n      var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n      if (callback) {\n        return callback(err);\n      } else {\n        throw err;\n      }\n    }\n\n    // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n    // selector and mod.  We assume it doesn't matter, as far as\n    // the behavior of modifiers is concerned, whether `_modify`\n    // is run on EJSON or on mongo-converted EJSON.\n\n    // Run this code up front so that it fails fast if someone uses\n    // a Mongo update operator we don't support.\n    let knownId;\n    if (options.upsert) {\n      try {\n        let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n        knownId = newDoc._id;\n      } catch (err) {\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    if (options.upsert &&\n        ! isModify &&\n        ! knownId &&\n        options.insertedId &&\n        ! (options.insertedId instanceof Mongo.ObjectID &&\n           options.generatedId)) {\n      // In case of an upsert with a replacement, where there is no _id defined\n      // in either the query or the replacement doc, mongo will generate an id itself.\n      // Therefore we need this special strategy if we want to control the id ourselves.\n\n      // We don't need to do this when:\n      // - This is not a replacement, so we can add an _id to $setOnInsert\n      // - The id is defined by query or mod we can just add it to the replacement doc\n      // - The user did not specify any id preference and the id is a Mongo ObjectId,\n      //     then we can just let Mongo generate the id\n\n      simulateUpsertWithInsertedId(\n        collection, mongoSelector, mongoMod, options,\n        // This callback does not need to be bindEnvironment'ed because\n        // simulateUpsertWithInsertedId() wraps it and then passes it through\n        // bindEnvironmentForWrite.\n        function (error, result) {\n          // If we got here via a upsert() call, then options._returnObject will\n          // be set and we should return the whole object. Otherwise, we should\n          // just return the number of affected docs to match the mongo API.\n          if (result && ! options._returnObject) {\n            callback(error, result.numberAffected);\n          } else {\n            callback(error, result);\n          }\n        }\n      );\n    } else {\n\n      if (options.upsert && !knownId && options.insertedId && isModify) {\n        if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n          mongoMod.$setOnInsert = {};\n        }\n        knownId = options.insertedId;\n        Object.assign(mongoMod.$setOnInsert, replaceTypes({_id: options.insertedId}, replaceMeteorAtomWithMongo));\n      }\n\n      const strings = Object.keys(mongoMod).filter((key) => !key.startsWith(\"$\"));\n      let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n      updateMethod =\n        updateMethod === 'updateMany' && !mongoOpts.multi\n          ? 'updateOne'\n          : updateMethod;\n      collection[updateMethod].bind(collection)(\n        mongoSelector, mongoMod, mongoOpts,\n          // mongo driver now returns undefined for err in the callback\n          bindEnvironmentForWrite(function (err = null, result) {\n          if (! err) {\n            var meteorResult = transformResult({result});\n            if (meteorResult && options._returnObject) {\n              // If this was an upsert() call, and we ended up\n              // inserting a new doc and we know its id, then\n              // return that id as well.\n              if (options.upsert && meteorResult.insertedId) {\n                if (knownId) {\n                  meteorResult.insertedId = knownId;\n                } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                  meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n                }\n              }\n\n              callback(err, meteorResult);\n            } else {\n              callback(err, meteorResult.numberAffected);\n            }\n          } else {\n            callback(err);\n          }\n        }));\n    }\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nvar transformResult = function (driverResult) {\n  var meteorResult = { numberAffected: 0 };\n  if (driverResult) {\n    var mongoResult = driverResult.result;\n    // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n    if (mongoResult.upsertedCount) {\n      meteorResult.numberAffected = mongoResult.upsertedCount;\n\n      if (mongoResult.upsertedId) {\n        meteorResult.insertedId = mongoResult.upsertedId;\n      }\n    } else {\n      // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n      // field and so we are using modifiedCount instead\n      meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n    }\n  }\n\n  return meteorResult;\n};\n\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err;\n\n  // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (error.indexOf('The _id field cannot be changed') === 0\n    || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = function (collection, selector, mod,\n                                             options, callback) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents,\n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var replacementWithId = Object.assign(\n    replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n    mod);\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = function () {\n    tries--;\n    if (! tries) {\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n    } else {\n      let method = collection.updateMany;\n      if(!Object.keys(mod).some(key => key.startsWith(\"$\"))){\n        method = collection.replaceOne.bind(collection);\n      }\n      method(\n        selector,\n        mod,\n        mongoOptsForUpdate,\n        bindEnvironmentForWrite(function(err, result) {\n          if (err) {\n            callback(err);\n          } else if (result && (result.modifiedCount || result.upsertedCount)) {\n            callback(null, {\n              numberAffected: result.modifiedCount || result.upsertedCount,\n              insertedId: result.upsertedId || undefined,\n            });\n          } else {\n            doConditionalInsert();\n          }\n        })\n      );\n    }\n  };\n\n  var doConditionalInsert = function() {\n    collection.replaceOne(\n      selector,\n      replacementWithId,\n      mongoOptsForInsert,\n      bindEnvironmentForWrite(function(err, result) {\n        if (err) {\n          // figure out if this is a\n          // \"cannot change _id of document\" error, and\n          // if so, try doUpdate() again, up to 3 times.\n          if (MongoConnection._isCannotChangeIdError(err)) {\n            doUpdate();\n          } else {\n            callback(err);\n          }\n        } else {\n          callback(null, {\n            numberAffected: result.upsertedCount,\n            insertedId: result.upsertedId,\n          });\n        }\n      })\n    );\n  };\n\n  doUpdate();\n};\n\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n  MongoConnection.prototype[method] = function (/* arguments */) {\n    var self = this;\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n  };\n});\n\n// XXX MongoConnection.upsert() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsert = function (collectionName, selector, mod,\n                                             options, callback) {\n  var self = this;\n\n\n  \n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(collectionName, selector, mod,\n                     _.extend({}, options, {\n                       upsert: true,\n                       _returnObject: true\n                     }), callback);\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOneAsync = async function (collection_name, selector,\n                                               options) {\n  var self = this;\n  if (arguments.length === 1)\n    selector = {};\n\n  options = options || {};\n  options.limit = 1;\n  return (await self.find(collection_name, selector, options).fetchAsync())[0];\n};\n\nMongoConnection.prototype.findOne = function (collection_name, selector,\n                                              options) {\n  var self = this;\n\n  return Future.fromPromise(self.findOneAsync(collection_name, selector, options)).wait();\n};\n\nMongoConnection.prototype.createIndexAsync = function (collectionName, index,\n                                                  options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  return collection.createIndex(index, options);\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype.createIndex = function (collectionName, index,\n                                                   options) {\n  var self = this;\n  \n\n  return Future.fromPromise(self.createIndexAsync(collectionName, index, options));\n};\n\nMongoConnection.prototype.countDocuments = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.countDocuments(...args);\n};\n\nMongoConnection.prototype.estimatedDocumentCount = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.estimatedDocumentCount(...args);\n};\n\nMongoConnection.prototype._ensureIndex = MongoConnection.prototype.createIndex;\n\nMongoConnection.prototype._dropIndex = function (collectionName, index) {\n  var self = this;\n\n  \n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.dropIndex(index, future.resolver());\n  future.wait();\n};\n\n// CURSORS\n\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\nfunction setupSynchronousCursor(cursor, method) {\n  // You can only observe a tailable cursor.\n  if (cursor._cursorDescription.options.tailable)\n    throw new Error('Cannot call ' + method + ' on a tailable cursor');\n\n  if (!cursor._synchronousCursor) {\n    cursor._synchronousCursor = cursor._mongo._createSynchronousCursor(\n      cursor._cursorDescription,\n      {\n        // Make sure that the \"cursor\" argument to forEach/map callbacks is the\n        // Cursor, not the SynchronousCursor.\n        selfForIteration: cursor,\n        useTransform: true,\n      }\n    );\n  }\n\n  return cursor._synchronousCursor;\n}\n\n\nCursor.prototype.count = function () {\n\n  const collection = this._mongo.rawCollection(this._cursorDescription.collectionName);\n  return Promise.await(collection.countDocuments(\n    replaceTypes(this._cursorDescription.selector, replaceMeteorAtomWithMongo),\n    replaceTypes(this._cursorDescription.options, replaceMeteorAtomWithMongo),\n  ));\n};\n\n[...ASYNC_CURSOR_METHODS, Symbol.iterator, Symbol.asyncIterator].forEach(methodName => {\n  // count is handled specially since we don't want to create a cursor.\n  // it is still included in ASYNC_CURSOR_METHODS because we still want an async version of it to exist.\n  if (methodName !== 'count') {\n    Cursor.prototype[methodName] = function (...args) {\n      const cursor = setupSynchronousCursor(this, methodName);\n      return cursor[methodName](...args);\n    };\n  }\n\n  // These methods are handled separately.\n  if (methodName === Symbol.iterator || methodName === Symbol.asyncIterator) {\n    return;\n  }\n\n  const methodNameAsync = getAsyncMethodName(methodName);\n  Cursor.prototype[methodNameAsync] = function (...args) {\n    try {\n      this[methodName].isCalledFromAsync = true;\n      return Promise.resolve(this[methodName](...args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n};\n\n// When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\n\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n};\n\n// Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n};\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeChanges = function (callbacks, options = {}) {\n  var self = this;\n  var methods = [\n    'addedAt',\n    'added',\n    'changedAt',\n    'changed',\n    'removedAt',\n    'removed',\n    'movedTo'\n  ];\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n\n  let exceptionName = callbacks._fromObserve ? 'observe' : 'observeChanges';\n  exceptionName += ' callback';\n  methods.forEach(function (method) {\n    if (callbacks[method] && typeof callbacks[method] == \"function\") {\n      callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n    }\n  });\n\n  return self._mongo._observeChanges(\n    self._cursorDescription, ordered, callbacks, options.nonMutatingCallbacks);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function(\n    cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip,\n    projection: cursorOptions.fields || cursorOptions.projection,\n    readPreference: cursorOptions.readPreference,\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    mongoOptions.numberOfRetries = -1;\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    mongoOptions);\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    dbCursor.addCursorFlag(\"tailable\", true)\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    dbCursor.addCursorFlag(\"awaitData\", true)\n\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n        cursorDescription.selector.ts) {\n      dbCursor.addCursorFlag(\"oplogReplay\", true)\n    }\n  }\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new SynchronousCursor(dbCursor, cursorDescription, options, collection);\n};\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options, collection) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription;\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n  self._selfForIteration = options.selfForIteration || self;\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(\n      cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  }\n\n  self._synchronousCount = Future.wrap(\n    collection.countDocuments.bind(\n      collection,\n      replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n      replaceTypes(cursorDescription.options, replaceMeteorAtomWithMongo),\n    )\n  );\n  self._visitedIds = new LocalCollection._IdMap;\n};\n\n_.extend(SynchronousCursor.prototype, {\n  // Returns a Promise for the next object from the underlying cursor (before\n  // the Mongo->Meteor type replacement).\n  _rawNextObjectPromise: function () {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self._dbCursor.next((err, doc) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(doc);\n        }\n      });\n    });\n  },\n\n  // Returns a Promise for the next object from the cursor, skipping those whose\n  // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n  _nextObjectPromise: async function () {\n    var self = this;\n\n    while (true) {\n      var doc = await self._rawNextObjectPromise();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform)\n        doc = self._transform(doc);\n\n      return doc;\n    }\n  },\n\n  // Returns a promise which is resolved with the next object (like with\n  // _nextObjectPromise) or rejected if the cursor doesn't return within\n  // timeoutMS ms.\n  _nextObjectPromiseWithTimeout: function (timeoutMS) {\n    const self = this;\n    if (!timeoutMS) {\n      return self._nextObjectPromise();\n    }\n    const nextObjectPromise = self._nextObjectPromise();\n    const timeoutErr = new Error('Client-side timeout waiting for next object');\n    const timeoutPromise = new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(timeoutErr);\n      }, timeoutMS);\n    });\n    return Promise.race([nextObjectPromise, timeoutPromise])\n      .catch((err) => {\n        if (err === timeoutErr) {\n          self.close();\n        }\n        throw err;\n      });\n  },\n\n  _nextObject: function () {\n    var self = this;\n    return self._nextObjectPromise().await();\n  },\n\n  forEach: function (callback, thisArg) {\n    var self = this;\n    const wrappedFn = Meteor.wrapFn(callback);\n\n    // Get back to the beginning.\n    self._rewind();\n\n    // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n    var index = 0;\n    while (true) {\n      var doc = self._nextObject();\n      if (!doc) return;\n      wrappedFn.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    const wrappedFn = Meteor.wrapFn(callback);\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(wrappedFn.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n\n  _rewind: function () {\n    var self = this;\n\n    // known to be synchronous\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap;\n  },\n\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n\n  fetch: function () {\n    var self = this;\n    return self.map(_.identity);\n  },\n\n  count: function () {\n    var self = this;\n    return self._synchronousCount().wait();\n  },\n\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nSynchronousCursor.prototype[Symbol.iterator] = function () {\n  var self = this;\n\n  // Get back to the beginning.\n  self._rewind();\n\n  return {\n    next() {\n      const doc = self._nextObject();\n      return doc ? {\n        value: doc\n      } : {\n        done: true\n      };\n    }\n  };\n};\n\nSynchronousCursor.prototype[Symbol.asyncIterator] = function () {\n  const syncResult = this[Symbol.iterator]();\n  return {\n    async next() {\n      return Promise.resolve(syncResult.next());\n    }\n  };\n}\n\n// Tails the cursor described by cursorDescription, most likely on the\n// oplog. Calls docCallback with each document found. Ignores errors and just\n// restarts the tail on error.\n//\n// If timeoutMS is set, then if we don't get a new document every timeoutMS,\n// kill and restart the cursor. This is primarily a workaround for #8598.\nMongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n  var loop = function () {\n    var doc = null;\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        doc = cursor._nextObjectPromiseWithTimeout(timeoutMS).await();\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error from\n        // Mongo, or just client-side (including our own timeout error). Ah\n        // well. But either way, we need to retry the cursor (unless the failure\n        // was because the observe got stopped).\n        doc = null;\n      }\n      // Since we awaited a promise above, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = _.clone(cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createSynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        Meteor.setTimeout(loop, 100);\n        break;\n      }\n    }\n  };\n\n  Meteor.defer(loop);\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nMongoConnection.prototype._observeChanges = function (\n    cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n  var self = this;\n\n  if (cursorDescription.options.tailable) {\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n  }\n\n  // You may not filter out _id when observing changes, because the id is a core\n  // part of the observeChanges API.\n  const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n  if (fieldsOptions &&\n      (fieldsOptions._id === 0 ||\n       fieldsOptions._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n  }\n\n  var observeKey = EJSON.stringify(\n    _.extend({ordered: ordered}, cursorDescription));\n\n  var multiplexer, observeDriver;\n  var firstHandle = false;\n\n  // Find a matching ObserveMultiplexer, or create a new one. This next block is\n  // guaranteed to not yield (and it doesn't call anything that can observe a\n  // new query), so no other calls to this function can interleave with it.\n  Meteor._noYieldsAllowed(function () {\n    if (_.has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          observeDriver.stop();\n        }\n      });\n      self._observeMultiplexers[observeKey] = multiplexer;\n    }\n  });\n\n  var observeHandle = new ObserveHandle(multiplexer,\n    callbacks,\n    nonMutatingCallbacks,\n  );\n\n  if (firstHandle) {\n    var matcher, sorter;\n    var canUseOplog = _.all([\n      function () {\n        // At a bare minimum, using the oplog requires us to have an oplog, to\n        // want unordered callbacks, and to not want a callback on the polls\n        // that won't happen.\n        return self._oplogHandle && !ordered &&\n          !callbacks._testOnlyPollCallback;\n      }, function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }, function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      }, function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort)\n          return true;\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }], function (f) { return f(); });  // invoke each function\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher,  // ignored by polling\n      sorter: sorter,  // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n    });\n\n    // This field is only set for use in tests.\n    multiplexer._observeDriver = observeDriver;\n  }\n\n  // Blocks until the initial adds have been sent.\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n  return observeHandle;\n};\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nlistenAll = function (cursorDescription, listenCallback) {\n  var listeners = [];\n  forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(\n      trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      _.each(listeners, function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = function (cursorDescription, triggerCallback) {\n  var key = {collection: cursorDescription.collectionName};\n  var specificIds = LocalCollection._idsMatchedBySelector(\n    cursorDescription.selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      triggerCallback(_.extend({id: id}, key));\n    });\n    triggerCallback(_.extend({dropCollection: true, id: null}, key));\n  } else {\n    triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  triggerCallback({ dropDatabase: true });\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n      (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n                    + \" tailable cursor without a \"\n                    + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n\nMongoInternals.Connection = MongoConnection;\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"996ac9a04fa7d221d4feb70d909202f99c74e81d"}
