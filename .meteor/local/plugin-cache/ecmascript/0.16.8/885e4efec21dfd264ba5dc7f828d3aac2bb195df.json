{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/polling_observe_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/mongo/polling_observe_driver.js","filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/polling_observe_driver.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/styles","root":"/Users/nicholas/Desktop/projects/local-legends/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/polling_observe_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/polling_observe_driver.js"}},"code":"var POLLING_THROTTLE_MS = +process.env.METEOR_POLLING_THROTTLE_MS || 50;\nvar POLLING_INTERVAL_MS = +process.env.METEOR_POLLING_INTERVAL_MS || 10 * 1000;\nPollingObserveDriver = function (options) {\n  var self = this;\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(self._cursorDescription);\n\n  // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n  self._results = null;\n\n  // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n  self._ensurePollIsScheduled = _.throttle(self._unthrottledEnsurePollIsScheduled, self._cursorDescription.options.pollingThrottleMs || POLLING_THROTTLE_MS /* ms */);\n\n  // XXX figure out if we still need a queue\n  self._taskQueue = new Meteor._SynchronousQueue();\n  var listenersHandle = listenAll(self._cursorDescription, function (notification) {\n    // When someone does a transaction that might affect us, schedule a poll\n    // of the database. If that transaction happens inside of a write fence,\n    // block the fence until we've polled and notified observers.\n    var fence = DDPServer._CurrentWriteFence.get();\n    if (fence) self._pendingWrites.push(fence.beginWrite());\n    // Ensure a poll is scheduled... but if we already know that one is,\n    // don't hit the throttled _ensurePollIsScheduled function (which might\n    // lead to us calling it unnecessarily in <pollingThrottleMs> ms).\n    if (self._pollsScheduledButNotStarted === 0) self._ensurePollIsScheduled();\n  });\n  self._stopCallbacks.push(function () {\n    listenersHandle.stop();\n  });\n\n  // every once and a while, poll even if we don't think we're dirty, for\n  // eventual consistency with database writes from outside the Meteor\n  // universe.\n  //\n  // For testing, there's an undocumented callback argument to observeChanges\n  // which disables time-based polling and gets called at the beginning of each\n  // poll.\n  if (options._testOnlyPollCallback) {\n    self._testOnlyPollCallback = options._testOnlyPollCallback;\n  } else {\n    var pollingInterval = self._cursorDescription.options.pollingIntervalMs || self._cursorDescription.options._pollingInterval ||\n    // COMPAT with 1.2\n    POLLING_INTERVAL_MS;\n    var intervalHandle = Meteor.setInterval(_.bind(self._ensurePollIsScheduled, self), pollingInterval);\n    self._stopCallbacks.push(function () {\n      Meteor.clearInterval(intervalHandle);\n    });\n  }\n\n  // Make sure we actually poll soon!\n  self._unthrottledEnsurePollIsScheduled();\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", 1);\n};\n_.extend(PollingObserveDriver.prototype, {\n  // This is always called through _.throttle (except once at startup).\n  _unthrottledEnsurePollIsScheduled: function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0) return;\n    ++self._pollsScheduledButNotStarted;\n    self._taskQueue.queueTask(function () {\n      self._pollMongo();\n    });\n  },\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function () {\n    var self = this;\n    // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n    ++self._pollsScheduledButNotStarted;\n    // Now block until all currently running or scheduled polls are done.\n    self._taskQueue.runTask(function () {});\n\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: function () {\n    var self = this;\n    // We should be in the same state as in the end of _suspendPolling.\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n    self._taskQueue.runTask(function () {\n      self._pollMongo();\n    });\n  },\n  _pollMongo: function () {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n    if (self._stopped) return;\n    var first = false;\n    var newResults;\n    var oldResults = self._results;\n    if (!oldResults) {\n      first = true;\n      // XXX maybe use OrderedDict instead?\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap();\n    }\n    self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n    // Save the list of pending writes which this round will commit.\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = [];\n\n    // Get the new query results. (This yields.)\n    try {\n      newResults = self._synchronousCursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof e.code === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        self._multiplexer.queryError(new Error(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.message));\n        return;\n      }\n\n      // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n      Meteor._debug(\"Exception while polling query \" + JSON.stringify(self._cursorDescription), e);\n      return;\n    }\n\n    // Run diffs.\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(self._ordered, oldResults, newResults, self._multiplexer);\n    }\n\n    // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n    if (first) self._multiplexer.ready();\n\n    // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n    self._results = newResults;\n\n    // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n    self._multiplexer.onFlush(function () {\n      _.each(writesForCycle, function (w) {\n        w.committed();\n      });\n    });\n  },\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n    _.each(self._stopCallbacks, function (c) {\n      c();\n    });\n    // Release any write fences that are waiting on us.\n    _.each(self._pendingWrites, function (w) {\n      w.committed();\n    });\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});","map":{"version":3,"names":["POLLING_THROTTLE_MS","process","env","METEOR_POLLING_THROTTLE_MS","POLLING_INTERVAL_MS","METEOR_POLLING_INTERVAL_MS","PollingObserveDriver","options","self","_cursorDescription","cursorDescription","_mongoHandle","mongoHandle","_ordered","ordered","_multiplexer","multiplexer","_stopCallbacks","_stopped","_synchronousCursor","_createSynchronousCursor","_results","_pollsScheduledButNotStarted","_pendingWrites","_ensurePollIsScheduled","_","throttle","_unthrottledEnsurePollIsScheduled","pollingThrottleMs","_taskQueue","Meteor","_SynchronousQueue","listenersHandle","listenAll","notification","fence","DDPServer","_CurrentWriteFence","get","push","beginWrite","stop","_testOnlyPollCallback","pollingInterval","pollingIntervalMs","_pollingInterval","intervalHandle","setInterval","bind","clearInterval","Package","Facts","incrementServerFact","extend","prototype","queueTask","_pollMongo","_suspendPolling","runTask","Error","_resumePolling","first","newResults","oldResults","LocalCollection","_IdMap","writesForCycle","getRawObjects","e","code","queryError","JSON","stringify","message","Array","apply","_debug","_diffQueryChanges","ready","onFlush","each","w","committed","c"],"sources":["packages/mongo/polling_observe_driver.js"],"sourcesContent":["var POLLING_THROTTLE_MS = +process.env.METEOR_POLLING_THROTTLE_MS || 50;\nvar POLLING_INTERVAL_MS = +process.env.METEOR_POLLING_INTERVAL_MS || 10 * 1000;\n\nPollingObserveDriver = function (options) {\n  var self = this;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(\n    self._cursorDescription);\n\n  // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n  self._results = null;\n\n  // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n  self._ensurePollIsScheduled = _.throttle(\n    self._unthrottledEnsurePollIsScheduled,\n    self._cursorDescription.options.pollingThrottleMs || POLLING_THROTTLE_MS /* ms */);\n\n  // XXX figure out if we still need a queue\n  self._taskQueue = new Meteor._SynchronousQueue();\n\n  var listenersHandle = listenAll(\n    self._cursorDescription, function (notification) {\n      // When someone does a transaction that might affect us, schedule a poll\n      // of the database. If that transaction happens inside of a write fence,\n      // block the fence until we've polled and notified observers.\n      var fence = DDPServer._CurrentWriteFence.get();\n      if (fence)\n        self._pendingWrites.push(fence.beginWrite());\n      // Ensure a poll is scheduled... but if we already know that one is,\n      // don't hit the throttled _ensurePollIsScheduled function (which might\n      // lead to us calling it unnecessarily in <pollingThrottleMs> ms).\n      if (self._pollsScheduledButNotStarted === 0)\n        self._ensurePollIsScheduled();\n    }\n  );\n  self._stopCallbacks.push(function () { listenersHandle.stop(); });\n\n  // every once and a while, poll even if we don't think we're dirty, for\n  // eventual consistency with database writes from outside the Meteor\n  // universe.\n  //\n  // For testing, there's an undocumented callback argument to observeChanges\n  // which disables time-based polling and gets called at the beginning of each\n  // poll.\n  if (options._testOnlyPollCallback) {\n    self._testOnlyPollCallback = options._testOnlyPollCallback;\n  } else {\n    var pollingInterval =\n          self._cursorDescription.options.pollingIntervalMs ||\n          self._cursorDescription.options._pollingInterval || // COMPAT with 1.2\n          POLLING_INTERVAL_MS;\n    var intervalHandle = Meteor.setInterval(\n      _.bind(self._ensurePollIsScheduled, self), pollingInterval);\n    self._stopCallbacks.push(function () {\n      Meteor.clearInterval(intervalHandle);\n    });\n  }\n\n  // Make sure we actually poll soon!\n  self._unthrottledEnsurePollIsScheduled();\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-polling\", 1);\n};\n\n_.extend(PollingObserveDriver.prototype, {\n  // This is always called through _.throttle (except once at startup).\n  _unthrottledEnsurePollIsScheduled: function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0)\n      return;\n    ++self._pollsScheduledButNotStarted;\n    self._taskQueue.queueTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function() {\n    var self = this;\n    // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n    ++self._pollsScheduledButNotStarted;\n    // Now block until all currently running or scheduled polls are done.\n    self._taskQueue.runTask(function() {});\n\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: function() {\n    var self = this;\n    // We should be in the same state as in the end of _suspendPolling.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n    self._taskQueue.runTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  _pollMongo: function () {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n\n    if (self._stopped)\n      return;\n\n    var first = false;\n    var newResults;\n    var oldResults = self._results;\n    if (!oldResults) {\n      first = true;\n      // XXX maybe use OrderedDict instead?\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n    // Save the list of pending writes which this round will commit.\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = [];\n\n    // Get the new query results. (This yields.)\n    try {\n      newResults = self._synchronousCursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof(e.code) === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        self._multiplexer.queryError(\n          new Error(\n            \"Exception while polling query \" +\n              JSON.stringify(self._cursorDescription) + \": \" + e.message));\n        return;\n      }\n\n      // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n      Meteor._debug(\"Exception while polling query \" +\n                    JSON.stringify(self._cursorDescription), e);\n      return;\n    }\n\n    // Run diffs.\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(\n        self._ordered, oldResults, newResults, self._multiplexer);\n    }\n\n    // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n    if (first)\n      self._multiplexer.ready();\n\n    // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n    self._results = newResults;\n\n    // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n    self._multiplexer.onFlush(function () {\n      _.each(writesForCycle, function (w) {\n        w.committed();\n      });\n    });\n  },\n\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n    _.each(self._stopCallbacks, function (c) { c(); });\n    // Release any write fences that are waiting on us.\n    _.each(self._pendingWrites, function (w) {\n      w.committed();\n    });\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"885e4efec21dfd264ba5dc7f828d3aac2bb195df"}
