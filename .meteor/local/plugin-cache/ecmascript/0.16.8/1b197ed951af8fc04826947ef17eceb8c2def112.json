{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/client/styles/packages/mdg:meteor-apm-agent/lib/models/pubsub.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/mdg:meteor-apm-agent/lib/models/pubsub.js","filename":"/Users/nicholas/Desktop/projects/local-legends/client/styles/packages/mdg:meteor-apm-agent/lib/models/pubsub.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/client/styles","root":"/Users/nicholas/Desktop/projects/local-legends/client/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/client/styles/packages/mdg:meteor-apm-agent/lib/models/pubsub.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mdg:meteor-apm-agent/lib/models/pubsub.js"}},"code":"let size, each, get;\nmodule.link(\"../utils.js\", {\n  size(v) {\n    size = v;\n  },\n  each(v) {\n    each = v;\n  },\n  get(v) {\n    get = v;\n  }\n}, 0);\nvar logger = Npm.require('debug')('kadira:pubsub');\nPubsubModel = function () {\n  this.metricsByMinute = Object.create(null);\n  this.subscriptions = Object.create(null);\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60,\n    //process traces every minute\n    maxTotalPoints: 30,\n    //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n  });\n  this.tracerStore.start();\n};\nPubsubModel.prototype._trackSub = function (session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n  var publication = this._getPublicationName(msg.name);\n  var subscriptionId = msg.id;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication: publication,\n    params: msg.params,\n    id: msg.id\n  };\n\n  //set session startedTime\n  session._startTime = session._startTime || timestamp;\n};\nObject.assign(PubsubModel.prototype, KadiraModel.prototype);\nPubsubModel.prototype._trackUnsub = function (session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var subscriptionState = this.subscriptions[subscriptionId];\n  var startTime = null;\n  //sometime, we don't have these states\n  if (subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    //if this is null subscription, which is started automatically\n    //hence, we don't have a state\n    startTime = session._startTime;\n  }\n\n  //in case, we can't get the startTime\n  if (startTime) {\n    var timestamp = Ntp._now();\n    var metrics = this._getMetrics(timestamp, publication);\n    //track the count\n    if (sub._name != null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    }\n    //use the current date to get the lifeTime of the subscription\n    metrics.lifeTime += timestamp - startTime;\n    //this is place we can clean the subscriptionState if exists\n    delete this.subscriptions[subscriptionId];\n  }\n};\nPubsubModel.prototype._trackReady = function (session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n  var subscriptionState = this.subscriptions[subscriptionId];\n  if (subscriptionState && !subscriptionState.readyTracked) {\n    metrics.resTime += timestamp - subscriptionState.startTime;\n    subscriptionState.readyTracked = true;\n  }\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\nPubsubModel.prototype._trackError = function (session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n  metrics.errors++;\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\nPubsubModel.prototype._getMetrics = function (timestamp, publication) {\n  var dateId = this._getDateId(timestamp);\n  if (!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: Object.create(null)\n    };\n  }\n  if (!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      errors: 0,\n      observerLifetime: 0,\n      polledDocuments: 0,\n      oplogUpdatedDocuments: 0,\n      oplogInsertedDocuments: 0,\n      oplogDeletedDocuments: 0,\n      initiallyAddedDocuments: 0,\n      liveAddedDocuments: 0,\n      liveChangedDocuments: 0,\n      liveRemovedDocuments: 0,\n      polledDocSize: 0,\n      fetchedDocSize: 0,\n      initiallyFetchedDocSize: 0,\n      liveFetchedDocSize: 0,\n      initiallySentMsgSize: 0,\n      liveSentMsgSize: 0\n    };\n  }\n  return this.metricsByMinute[dateId].pubs[publication];\n};\nPubsubModel.prototype._getPublicationName = function (name) {\n  return name || \"null(autopublish)\";\n};\nPubsubModel.prototype._getSubscriptionInfo = function () {\n  var self = this;\n  var activeSubs = Object.create(null);\n  var activeDocs = Object.create(null);\n  var totalDocsSent = Object.create(null);\n  var totalDataSent = Object.create(null);\n  var totalObservers = Object.create(null);\n  var cachedObservers = Object.create(null);\n  each(Meteor.server.sessions, session => {\n    each(session._namedSubs, countSubData);\n    each(session._universalSubs, countSubData);\n  });\n  var avgObserverReuse = Object.create(null);\n  _.each(totalObservers, function (value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n  return {\n    activeSubs: activeSubs,\n    activeDocs: activeDocs,\n    avgObserverReuse: avgObserverReuse\n  };\n  function countSubData(sub) {\n    var publication = self._getPublicationName(sub._name);\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countObservers(sub, publication);\n  }\n  function countSubscriptions(sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n  function countDocuments(sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    each(sub._documents, document => {\n      activeDocs[publication] += size(document);\n    });\n  }\n  function countObservers(sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n};\nPubsubModel.prototype.buildPayload = function (buildDetailInfo) {\n  var metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = Object.create(null);\n  var payload = {\n    pubMetrics: []\n  };\n  var subscriptionData = this._getSubscriptionInfo();\n  var activeSubs = subscriptionData.activeSubs;\n  var activeDocs = subscriptionData.activeDocs;\n  var avgObserverReuse = subscriptionData.avgObserverReuse;\n\n  //to the averaging\n  for (var dateId in metricsByMinute) {\n    var dateMetrics = metricsByMinute[dateId];\n    // We need to convert startTime into actual serverTime\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n    for (var publication in metricsByMinute[dateId].pubs) {\n      var singlePubMetrics = metricsByMinute[dateId].pubs[publication];\n      // We only calculate resTime for new subscriptions\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\n      // We only track lifeTime in the unsubs\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\n\n      // Count the average for observer lifetime\n      if (singlePubMetrics.deletedObservers > 0) {\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\n      }\n\n      // If there are two ore more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  }\n\n  //collect traces and send them with the payload\n  payload.pubRequests = this.tracerStore.collectTraces();\n  return payload;\n};\nPubsubModel.prototype.incrementHandleCount = function (trace, isCached) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(trace.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  var session = get(Meteor.server.sessions, trace.session);\n  if (session) {\n    var sub = get(session._namedSubs, trace.id);\n    if (sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  }\n  // not sure, we need to do this? But I don't need to break the however\n  sub = sub || {\n    _totalObservers: 0,\n    _cachedObservers: 0\n  };\n  publication.totalObservers++;\n  sub._totalObservers++;\n  if (isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n};\nPubsubModel.prototype.trackCreatedObserver = function (info) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.createdObservers++;\n};\nPubsubModel.prototype.trackDeletedObserver = function (info) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.deletedObservers++;\n  publication.observerLifetime += new Date().getTime() - info.startTime;\n};\nPubsubModel.prototype.trackDocumentChanges = function (info, op) {\n  // It's possibel that info to be null\n  // Specially when getting changes at the very begining.\n  // This may be false, but nice to have a check\n  if (!info) {\n    return;\n  }\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  if (op.op === \"d\") {\n    publication.oplogDeletedDocuments++;\n  } else if (op.op === \"i\") {\n    publication.oplogInsertedDocuments++;\n  } else if (op.op === \"u\") {\n    publication.oplogUpdatedDocuments++;\n  }\n};\nPubsubModel.prototype.trackPolledDocuments = function (info, count) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.polledDocuments += count;\n};\nPubsubModel.prototype.trackLiveUpdates = function (info, type, count) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  if (type === \"_addPublished\") {\n    publication.liveAddedDocuments += count;\n  } else if (type === \"_removePublished\") {\n    publication.liveRemovedDocuments += count;\n  } else if (type === \"_changePublished\") {\n    publication.liveChangedDocuments += count;\n  } else if (type === \"_initialAdds\") {\n    publication.initiallyAddedDocuments += count;\n  } else {\n    throw new Error(\"Kadira: Unknown live update type\");\n  }\n};\nPubsubModel.prototype.trackDocSize = function (name, type, size) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  if (type === \"polledFetches\") {\n    publication.polledDocSize += size;\n  } else if (type === \"liveFetches\") {\n    publication.liveFetchedDocSize += size;\n  } else if (type === \"cursorFetches\") {\n    publication.fetchedDocSize += size;\n  } else if (type === \"initialFetches\") {\n    publication.initiallyFetchedDocSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n};\nPubsubModel.prototype.trackMsgSize = function (name, type, size) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  if (type === \"liveSent\") {\n    publication.liveSentMsgSize += size;\n  } else if (type === \"initialSent\") {\n    publication.initiallySentMsgSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n};","map":{"version":3,"names":["size","each","get","module","link","v","logger","Npm","require","PubsubModel","metricsByMinute","Object","create","subscriptions","tracerStore","TracerStore","interval","maxTotalPoints","archiveEvery","start","prototype","_trackSub","session","msg","id","name","params","publication","_getPublicationName","subscriptionId","timestamp","Ntp","_now","metrics","_getMetrics","subs","startTime","_startTime","assign","KadiraModel","_trackUnsub","sub","_subscriptionId","_name","subscriptionState","unsubs","lifeTime","_trackReady","trace","readyTracked","resTime","addTrace","_trackError","errors","dateId","_getDateId","pubs","activeSubs","activeDocs","totalObservers","cachedObservers","createdObservers","deletedObservers","observerLifetime","polledDocuments","oplogUpdatedDocuments","oplogInsertedDocuments","oplogDeletedDocuments","initiallyAddedDocuments","liveAddedDocuments","liveChangedDocuments","liveRemovedDocuments","polledDocSize","fetchedDocSize","initiallyFetchedDocSize","liveFetchedDocSize","initiallySentMsgSize","liveSentMsgSize","_getSubscriptionInfo","self","totalDocsSent","totalDataSent","Meteor","server","sessions","_namedSubs","countSubData","_universalSubs","avgObserverReuse","_","value","countSubscriptions","countDocuments","countObservers","_documents","document","_totalObservers","_cachedObservers","buildPayload","buildDetailInfo","payload","pubMetrics","subscriptionData","dateMetrics","Kadira","syncedDate","syncTime","singlePubMetrics","push","pubRequests","collectTraces","incrementHandleCount","isCached","publicationName","trackCreatedObserver","info","trackDeletedObserver","Date","getTime","trackDocumentChanges","op","trackPolledDocuments","count","trackLiveUpdates","type","Error","trackDocSize","trackMsgSize"],"sources":["packages/mdg:meteor-apm-agent/lib/models/pubsub.js"],"sourcesContent":["var logger = Npm.require('debug')('kadira:pubsub');\n\nimport { size, each, get } from \"../utils.js\";\n\nPubsubModel = function() {\n  this.metricsByMinute = Object.create(null);\n  this.subscriptions = Object.create(null);\n\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60, //process traces every minute\n    maxTotalPoints: 30, //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n  });\n\n  this.tracerStore.start();\n}\n\nPubsubModel.prototype._trackSub = function(session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n  var publication = this._getPublicationName(msg.name);\n  var subscriptionId = msg.id;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication: publication,\n    params: msg.params,\n    id: msg.id\n  };\n\n  //set session startedTime\n  session._startTime = session._startTime || timestamp;\n};\n\nObject.assign(PubsubModel.prototype, KadiraModel.prototype);\n\nPubsubModel.prototype._trackUnsub = function(session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var subscriptionState = this.subscriptions[subscriptionId];\n\n  var startTime = null;\n  //sometime, we don't have these states\n  if(subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    //if this is null subscription, which is started automatically\n    //hence, we don't have a state\n    startTime = session._startTime;\n  }\n\n  //in case, we can't get the startTime\n  if(startTime) {\n    var timestamp = Ntp._now();\n    var metrics = this._getMetrics(timestamp, publication);\n    //track the count\n    if(sub._name != null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    }\n    //use the current date to get the lifeTime of the subscription\n    metrics.lifeTime += timestamp - startTime;\n    //this is place we can clean the subscriptionState if exists\n    delete this.subscriptions[subscriptionId];\n  }\n};\n\nPubsubModel.prototype._trackReady = function(session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  var subscriptionState = this.subscriptions[subscriptionId];\n  if(subscriptionState && !subscriptionState.readyTracked) {\n    metrics.resTime += timestamp - subscriptionState.startTime;\n    subscriptionState.readyTracked = true;\n  }\n\n  if(trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._trackError = function(session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.errors++;\n\n  if(trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._getMetrics = function(timestamp, publication) {\n  var dateId = this._getDateId(timestamp);\n\n  if(!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: Object.create(null)\n    };\n  }\n\n  if(!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      errors: 0,\n      observerLifetime: 0,\n      polledDocuments: 0,\n      oplogUpdatedDocuments: 0,\n      oplogInsertedDocuments: 0,\n      oplogDeletedDocuments: 0,\n      initiallyAddedDocuments: 0,\n      liveAddedDocuments: 0,\n      liveChangedDocuments: 0,\n      liveRemovedDocuments: 0,\n      polledDocSize: 0,\n      fetchedDocSize: 0,\n      initiallyFetchedDocSize: 0,\n      liveFetchedDocSize: 0,\n      initiallySentMsgSize: 0,\n      liveSentMsgSize: 0\n    };\n  }\n\n  return this.metricsByMinute[dateId].pubs[publication];\n};\n\nPubsubModel.prototype._getPublicationName = function(name) {\n  return name || \"null(autopublish)\";\n};\n\nPubsubModel.prototype._getSubscriptionInfo = function() {\n  var self = this;\n  var activeSubs = Object.create(null);\n  var activeDocs = Object.create(null);\n  var totalDocsSent = Object.create(null);\n  var totalDataSent = Object.create(null);\n  var totalObservers = Object.create(null);\n  var cachedObservers = Object.create(null);\n\n  each(Meteor.server.sessions, session => {\n    each(session._namedSubs, countSubData);\n    each(session._universalSubs, countSubData);\n  });\n\n  var avgObserverReuse = Object.create(null);\n  _.each(totalObservers, function(value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n\n  return {\n    activeSubs: activeSubs,\n    activeDocs: activeDocs,\n    avgObserverReuse: avgObserverReuse\n  };\n\n  function countSubData (sub) {\n    var publication = self._getPublicationName(sub._name);\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countObservers(sub, publication);\n  }\n\n  function countSubscriptions (sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n\n  function countDocuments (sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    each(sub._documents, document => {\n      activeDocs[publication] += size(document);\n    });\n  }\n\n  function countObservers(sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n}\n\nPubsubModel.prototype.buildPayload = function(buildDetailInfo) {\n  var metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = Object.create(null);\n\n  var payload = {\n    pubMetrics: []\n  };\n\n  var subscriptionData = this._getSubscriptionInfo();\n  var activeSubs = subscriptionData.activeSubs;\n  var activeDocs = subscriptionData.activeDocs;\n  var avgObserverReuse = subscriptionData.avgObserverReuse;\n\n  //to the averaging\n  for(var dateId in metricsByMinute) {\n    var dateMetrics = metricsByMinute[dateId];\n    // We need to convert startTime into actual serverTime\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n\n    for(var publication in metricsByMinute[dateId].pubs) {\n      var singlePubMetrics = metricsByMinute[dateId].pubs[publication];\n      // We only calculate resTime for new subscriptions\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\n      // We only track lifeTime in the unsubs\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\n\n      // Count the average for observer lifetime\n      if(singlePubMetrics.deletedObservers > 0) {\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\n      }\n\n      // If there are two ore more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  }\n\n  //collect traces and send them with the payload\n  payload.pubRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n\nPubsubModel.prototype.incrementHandleCount = function(trace, isCached) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(trace.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  var session = get(Meteor.server.sessions, trace.session);\n  if (session) {\n    var sub = get(session._namedSubs, trace.id);\n    if (sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  }\n  // not sure, we need to do this? But I don't need to break the however\n  sub = sub || {_totalObservers:0 , _cachedObservers: 0};\n\n  publication.totalObservers++;\n  sub._totalObservers++;\n  if(isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n}\n\nPubsubModel.prototype.trackCreatedObserver = function(info) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.createdObservers++;\n}\n\nPubsubModel.prototype.trackDeletedObserver = function(info) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.deletedObservers++;\n  publication.observerLifetime += (new Date()).getTime() - info.startTime;\n}\n\nPubsubModel.prototype.trackDocumentChanges = function(info, op) {\n  // It's possibel that info to be null\n  // Specially when getting changes at the very begining.\n  // This may be false, but nice to have a check\n  if(!info) {\n    return\n  }\n\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  if(op.op === \"d\") {\n    publication.oplogDeletedDocuments++;\n  } else if(op.op === \"i\") {\n    publication.oplogInsertedDocuments++;\n  } else if(op.op === \"u\") {\n    publication.oplogUpdatedDocuments++;\n  }\n}\n\nPubsubModel.prototype.trackPolledDocuments = function(info, count) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.polledDocuments += count;\n}\n\nPubsubModel.prototype.trackLiveUpdates = function(info, type, count) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if(type === \"_addPublished\") {\n    publication.liveAddedDocuments += count;\n  } else if(type === \"_removePublished\") {\n    publication.liveRemovedDocuments += count;\n  } else if(type === \"_changePublished\") {\n    publication.liveChangedDocuments += count;\n  } else if(type === \"_initialAdds\") {\n    publication.initiallyAddedDocuments += count;\n  } else {\n    throw new Error(\"Kadira: Unknown live update type\");\n  }\n}\n\nPubsubModel.prototype.trackDocSize = function(name, type, size) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if(type === \"polledFetches\") {\n    publication.polledDocSize += size;\n  } else if(type === \"liveFetches\") {\n    publication.liveFetchedDocSize += size;\n  } else if(type === \"cursorFetches\") {\n    publication.fetchedDocSize += size;\n  } else if(type === \"initialFetches\") {\n    publication.initiallyFetchedDocSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n}\n\nPubsubModel.prototype.trackMsgSize = function(name, type, size) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if(type === \"liveSent\") {\n    publication.liveSentMsgSize += size;\n  } else if(type === \"initialSent\") {\n    publication.initiallySentMsgSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n}\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"1b197ed951af8fc04826947ef17eceb8c2def112"}
