{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/minimongo/minimongo_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/minimongo/minimongo_server.js","filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/minimongo/minimongo_server.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/styles","root":"/Users/nicholas/Desktop/projects/local-legends/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/minimongo/minimongo_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/minimongo_server.js"}},"code":"module.link(\"./minimongo_common.js\");\nlet hasOwn, isNumericKey, isOperatorObject, pathsToTree, projectionDetails;\nmodule.link(\"./common.js\", {\n  hasOwn(v) {\n    hasOwn = v;\n  },\n  isNumericKey(v) {\n    isNumericKey = v;\n  },\n  isOperatorObject(v) {\n    isOperatorObject = v;\n  },\n  pathsToTree(v) {\n    pathsToTree = v;\n  },\n  projectionDetails(v) {\n    projectionDetails = v;\n  }\n}, 0);\nMinimongo._pathsElidingNumericKeys = paths => paths.map(path => path.split('.').filter(part => !isNumericKey(part)).join('.'));\n\n// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({\n    $set: {},\n    $unset: {}\n  }, modifier);\n  const meaningfulPaths = this._getPaths();\n  const modifiedPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n  return modifiedPaths.some(path => {\n    const mod = path.split('.');\n    return meaningfulPaths.some(meaningfulPath => {\n      const sel = meaningfulPath.split('.');\n      let i = 0,\n        j = 0;\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      }\n\n      // One is a prefix of another, taking numeric fields into account\n      return true;\n    });\n  });\n};\n\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n  if (!this.isSimple()) {\n    return true;\n  }\n  modifier = Object.assign({\n    $set: {},\n    $unset: {}\n  }, modifier);\n  const modifierPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n  if (this._getPaths().some(pathHasNumericKeys) || modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  }\n\n  // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n  const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n    if (!isOperatorObject(this._selector[path])) {\n      return false;\n    }\n    return modifierPaths.some(modifierPath => modifierPath.startsWith(\"\".concat(path, \".\")));\n  });\n  if (expectedScalarIsObject) {\n    return false;\n  }\n\n  // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n  const matchingDocument = EJSON.clone(this.matchingDocument());\n\n  // The selector is too complex, anything can happen.\n  if (matchingDocument === null) {\n    return true;\n  }\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n    throw error;\n  }\n  return this.documentMatches(matchingDocument).result;\n};\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {\n  const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\n// Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\nMinimongo.Matcher.prototype.matchingDocument = function () {\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  }\n\n  // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n  let fallback = false;\n  this._matchingDocument = pathsToTree(this._getPaths(), path => {\n    const valueSelector = this._selector[path];\n    if (isOperatorObject(valueSelector)) {\n      // if there is a strict equality, there is a good\n      // chance we can use one of those as \"matching\"\n      // dummy value\n      if (valueSelector.$eq) {\n        return valueSelector.$eq;\n      }\n      if (valueSelector.$in) {\n        const matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        });\n\n        // Return anything from $in that matches the whole selector for this\n        // path. If nothing matches, returns `undefined` as nothing can make\n        // this selector into `true`.\n        return valueSelector.$in.find(placeholder => matcher.documentMatches({\n          placeholder\n        }).result);\n      }\n      if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n        let lowerBound = -Infinity;\n        let upperBound = Infinity;\n        ['$lte', '$lt'].forEach(op => {\n          if (hasOwn.call(valueSelector, op) && valueSelector[op] < upperBound) {\n            upperBound = valueSelector[op];\n          }\n        });\n        ['$gte', '$gt'].forEach(op => {\n          if (hasOwn.call(valueSelector, op) && valueSelector[op] > lowerBound) {\n            lowerBound = valueSelector[op];\n          }\n        });\n        const middle = (lowerBound + upperBound) / 2;\n        const matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        });\n        if (!matcher.documentMatches({\n          placeholder: middle\n        }).result && (middle === lowerBound || middle === upperBound)) {\n          fallback = true;\n        }\n        return middle;\n      }\n      if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n        // Since this._isSimple makes sure $nin and $ne are not combined with\n        // objects or arrays, we can confidently return an empty object as it\n        // never matches any scalar.\n        return {};\n      }\n      fallback = true;\n    }\n    return this._selector[path];\n  }, x => x);\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n  return this._matchingDocument;\n};\n\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\nMinimongo.Sorter.prototype.combineIntoProjection = function (projection) {\n  return combineImportantPathsIntoProjection(Minimongo._pathsElidingNumericKeys(this._getPaths()), projection);\n};\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  const details = projectionDetails(projection);\n\n  // merge the paths to include\n  const tree = pathsToTree(paths, path => true, (node, path, fullPath) => true, details.tree);\n  const mergedProjection = treeToPaths(tree);\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  }\n\n  // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n  const mergedExclProjection = {};\n  Object.keys(mergedProjection).forEach(path => {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n  return mergedExclProjection;\n}\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths);\n\n  // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n}\n\n// A helper to ensure object has only certain keys\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(k => keys.includes(k));\n}\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n}\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nfunction treeToPaths(tree) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  const result = {};\n  Object.keys(tree).forEach(key => {\n    const value = tree[key];\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, \"\".concat(prefix + key, \".\")));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["module","link","hasOwn","isNumericKey","isOperatorObject","pathsToTree","projectionDetails","v","Minimongo","_pathsElidingNumericKeys","paths","map","path","split","filter","part","join","Matcher","prototype","affectedByModifier","modifier","Object","assign","$set","$unset","meaningfulPaths","_getPaths","modifiedPaths","concat","keys","some","mod","meaningfulPath","sel","i","j","length","canBecomeTrueByModifier","isSimple","modifierPaths","pathHasNumericKeys","expectedScalarIsObject","_selector","modifierPath","startsWith","matchingDocument","EJSON","clone","LocalCollection","_modify","error","name","setPropertyError","documentMatches","result","combineIntoProjection","projection","selectorPaths","includes","combineImportantPathsIntoProjection","_matchingDocument","undefined","fallback","valueSelector","$eq","$in","matcher","placeholder","find","onlyContainsKeys","lowerBound","Infinity","upperBound","forEach","op","call","middle","x","Sorter","_selectorForAffectedByModifier","details","tree","node","fullPath","mergedProjection","treeToPaths","including","mergedExclProjection","getPaths","selector","_paths","obj","every","k","prefix","arguments","key","value"],"sources":["packages/minimongo/minimongo_server.js"],"sourcesContent":["import './minimongo_common.js';\nimport {\n  hasOwn,\n  isNumericKey,\n  isOperatorObject,\n  pathsToTree,\n  projectionDetails,\n} from './common.js';\n\nMinimongo._pathsElidingNumericKeys = paths => paths.map(path =>\n  path.split('.').filter(part => !isNumericKey(part)).join('.')\n);\n\n// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function(modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const meaningfulPaths = this._getPaths();\n  const modifiedPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  return modifiedPaths.some(path => {\n    const mod = path.split('.');\n\n    return meaningfulPaths.some(meaningfulPath => {\n      const sel = meaningfulPath.split('.');\n\n      let i = 0, j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      }\n\n      // One is a prefix of another, taking numeric fields into account\n      return true;\n    });\n  });\n};\n\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function(modifier) {\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n\n  if (!this.isSimple()) {\n    return true;\n  }\n\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const modifierPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  if (this._getPaths().some(pathHasNumericKeys) ||\n      modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  }\n\n  // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n  const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n    if (!isOperatorObject(this._selector[path])) {\n      return false;\n    }\n\n    return modifierPaths.some(modifierPath =>\n      modifierPath.startsWith(`${path}.`)\n    );\n  });\n\n  if (expectedScalarIsObject) {\n    return false;\n  }\n\n  // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n  const matchingDocument = EJSON.clone(this.matchingDocument());\n\n  // The selector is too complex, anything can happen.\n  if (matchingDocument === null) {\n    return true;\n  }\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n\n    throw error;\n  }\n\n  return this.documentMatches(matchingDocument).result;\n};\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function(projection) {\n  const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\n// Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\nMinimongo.Matcher.prototype.matchingDocument = function() {\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  }\n\n  // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n  let fallback = false;\n\n  this._matchingDocument = pathsToTree(\n    this._getPaths(),\n    path => {\n      const valueSelector = this._selector[path];\n\n      if (isOperatorObject(valueSelector)) {\n        // if there is a strict equality, there is a good\n        // chance we can use one of those as \"matching\"\n        // dummy value\n        if (valueSelector.$eq) {\n          return valueSelector.$eq;\n        }\n\n        if (valueSelector.$in) {\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          // Return anything from $in that matches the whole selector for this\n          // path. If nothing matches, returns `undefined` as nothing can make\n          // this selector into `true`.\n          return valueSelector.$in.find(placeholder =>\n            matcher.documentMatches({placeholder}).result\n          );\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n          let lowerBound = -Infinity;\n          let upperBound = Infinity;\n\n          ['$lte', '$lt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] < upperBound) {\n              upperBound = valueSelector[op];\n            }\n          });\n\n          ['$gte', '$gt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] > lowerBound) {\n              lowerBound = valueSelector[op];\n            }\n          });\n\n          const middle = (lowerBound + upperBound) / 2;\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          if (!matcher.documentMatches({placeholder: middle}).result &&\n              (middle === lowerBound || middle === upperBound)) {\n            fallback = true;\n          }\n\n          return middle;\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n          // Since this._isSimple makes sure $nin and $ne are not combined with\n          // objects or arrays, we can confidently return an empty object as it\n          // never matches any scalar.\n          return {};\n        }\n\n        fallback = true;\n      }\n\n      return this._selector[path];\n    },\n    x => x);\n\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n\n  return this._matchingDocument;\n};\n\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\nMinimongo.Sorter.prototype.affectedByModifier = function(modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\nMinimongo.Sorter.prototype.combineIntoProjection = function(projection) {\n  return combineImportantPathsIntoProjection(\n    Minimongo._pathsElidingNumericKeys(this._getPaths()),\n    projection\n  );\n};\n\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  const details = projectionDetails(projection);\n\n  // merge the paths to include\n  const tree = pathsToTree(\n    paths,\n    path => true,\n    (node, path, fullPath) => true,\n    details.tree\n  );\n  const mergedProjection = treeToPaths(tree);\n\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  }\n\n  // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n  const mergedExclProjection = {};\n\n  Object.keys(mergedProjection).forEach(path => {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n\n  return mergedExclProjection;\n}\n\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths);\n\n  // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n}\n\n// A helper to ensure object has only certain keys\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(k => keys.includes(k));\n}\n\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n}\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nfunction treeToPaths(tree, prefix = '') {\n  const result = {};\n\n  Object.keys(tree).forEach(key => {\n    const value = tree[key];\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, `${prefix + key}.`));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n\n  return result;\n}\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"dd9e7ef171f54312480fa45b2c06d1ea81a44275"}
