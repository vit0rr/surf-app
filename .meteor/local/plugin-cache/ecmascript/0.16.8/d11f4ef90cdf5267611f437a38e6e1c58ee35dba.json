{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/oplog_tailing.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/mongo/oplog_tailing.js","filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/oplog_tailing.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/styles","root":"/Users/nicholas/Desktop/projects/local-legends/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/oplog_tailing.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_tailing.js"}},"code":"let NpmModuleMongodb;\nmodule.link(\"meteor/npm-mongo\", {\n  NpmModuleMongodb(v) {\n    NpmModuleMongodb = v;\n  }\n}, 0);\nvar Future = Npm.require('fibers/future');\nconst {\n  Long\n} = NpmModuleMongodb;\nOPLOG_COLLECTION = 'oplog.rs';\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\nvar TAIL_TIMEOUT = +process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000;\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\nidForOp = function (op) {\n  if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\",\n    factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp(\"^(?:\" + [Meteor._escapeRegExp(self._dbName + \".\"), Meteor._escapeRegExp(\"admin.$cmd\")].join(\"|\") + \")\"),\n    $or: [{\n      op: {\n        $in: ['i', 'u', 'd']\n      }\n    },\n    // drop collection\n    {\n      op: 'c',\n      'o.drop': {\n        $exists: true\n      }\n    }, {\n      op: 'c',\n      'o.dropDatabase': 1\n    }, {\n      op: 'c',\n      'o.applyOps': {\n        $exists: true\n      }\n    }]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n  self._startTailing();\n};\nObject.assign(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped) return;\n    self._stopped = true;\n    if (self._tailHandle) self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    self._readyFuture.wait();\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      originalCallback(notification);\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    self._readyFuture.wait();\n    var lastEntry;\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        lastEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, self._baseOplogSelector, {\n          projection: {\n            ts: 1\n          },\n          sort: {\n            $natural: -1\n          }\n        });\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry\", e);\n        Meteor._sleepForMs(100);\n      }\n    }\n    if (self._stopped) return;\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n    var ts = lastEntry.ts;\n    if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpFutures.length;\n    while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    var f = new Future();\n    self._catchingUpFutures.splice(insertAfter, 0, {\n      ts: ts,\n      future: f\n    });\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(self._oplogUrl, {\n      maxPoolSize: 1\n    });\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, {\n      maxPoolSize: 1\n    });\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    // More on the isMasterDoc\n    // https://docs.mongodb.com/manual/reference/command/isMaster/\n    var f = new Future();\n    self._oplogLastEntryConnection.db.admin().command({\n      ismaster: 1\n    }, f.resolver());\n    var isMasterDoc = f.wait();\n    if (!(isMasterDoc && isMasterDoc.setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, {}, {\n      sort: {\n        $natural: -1\n      },\n      projection: {\n        ts: 1\n      }\n    });\n    var oplogSelector = _.clone(self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {\n        $gt: lastOplogEntry.ts\n      };\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n    var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, {\n      tailable: true\n    });\n\n    // Start tailing the oplog.\n    //\n    // We restart the low-level oplog query every 30 seconds if we didn't get a\n    // doc. This is a workaround for #8598: the Node Mongo driver has at least\n    // one bug that can lead to query callbacks never getting called (even with\n    // an error) when leadership failover occur.\n    self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {\n      self._entryQueue.push(doc);\n      self._maybeStartWorker();\n    }, TAIL_TIMEOUT);\n    self._readyFuture.return();\n  },\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive) return;\n    self._workerActive = true;\n    Meteor.defer(function () {\n      // May be called recursively in case of transactions.\n      function handleDoc(doc) {\n        if (doc.ns === \"admin.$cmd\") {\n          if (doc.o.applyOps) {\n            // This was a successful transaction, so we need to apply the\n            // operations that were involved.\n            let nextTimestamp = doc.ts;\n            doc.o.applyOps.forEach(op => {\n              // See https://github.com/meteor/meteor/issues/10420.\n              if (!op.ts) {\n                op.ts = nextTimestamp;\n                nextTimestamp = nextTimestamp.add(Long.ONE);\n              }\n              handleDoc(op);\n            });\n            return;\n          }\n          throw new Error(\"Unknown command \" + EJSON.stringify(doc));\n        }\n        const trigger = {\n          dropCollection: false,\n          dropDatabase: false,\n          op: doc\n        };\n        if (typeof doc.ns === \"string\" && doc.ns.startsWith(self._dbName + \".\")) {\n          trigger.collection = doc.ns.slice(self._dbName.length + 1);\n        }\n\n        // Is it a special command and the collection name is hidden\n        // somewhere in operator?\n        if (trigger.collection === \"$cmd\") {\n          if (doc.o.dropDatabase) {\n            delete trigger.collection;\n            trigger.dropDatabase = true;\n          } else if (_.has(doc.o, \"drop\")) {\n            trigger.collection = doc.o.drop;\n            trigger.dropCollection = true;\n            trigger.id = null;\n          } else if (\"create\" in doc.o && \"idIndex\" in doc.o) {\n            // A collection got implicitly created within a transaction. There's\n            // no need to do anything about it.\n          } else {\n            throw Error(\"Unknown command \" + EJSON.stringify(doc));\n          }\n        } else {\n          // All other ops have an id.\n          trigger.id = idForOp(doc);\n        }\n        self._crossbar.fire(trigger);\n      }\n      try {\n        while (!self._stopped && !self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n          const doc = self._entryQueue.shift();\n\n          // Fire trigger(s) for this doc.\n          handleDoc(doc);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (doc.ts) {\n            self._setLastProcessedTS(doc.ts);\n          } else {\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          }\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n      sequencer.future.return();\n    }\n  },\n  //Methods used on tests to dinamically change TOO_FAR_BEHIND\n  _defineTooFarBehind: function (value) {\n    TOO_FAR_BEHIND = value;\n  },\n  _resetTooFarBehind: function () {\n    TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n  }\n});","map":{"version":3,"names":["NpmModuleMongodb","module","link","v","Future","Npm","require","Long","OPLOG_COLLECTION","TOO_FAR_BEHIND","process","env","METEOR_OPLOG_TOO_FAR_BEHIND","TAIL_TIMEOUT","METEOR_OPLOG_TAIL_TIMEOUT","showTS","ts","getHighBits","getLowBits","idForOp","op","o","_id","o2","Error","EJSON","stringify","OplogHandle","oplogUrl","dbName","self","_oplogUrl","_dbName","_oplogLastEntryConnection","_oplogTailConnection","_stopped","_tailHandle","_readyFuture","_crossbar","DDPServer","_Crossbar","factPackage","factName","_baseOplogSelector","ns","RegExp","Meteor","_escapeRegExp","join","$or","$in","$exists","_catchingUpFutures","_lastProcessedTS","_onSkippedEntriesHook","Hook","debugPrintExceptions","_entryQueue","_DoubleEndedQueue","_workerActive","_startTailing","Object","assign","prototype","stop","onOplogEntry","trigger","callback","wait","originalCallback","bindEnvironment","notification","err","_debug","listenHandle","listen","onSkippedEntries","register","waitUntilCaughtUp","lastEntry","findOne","projection","sort","$natural","e","_sleepForMs","lessThanOrEqual","insertAfter","length","greaterThan","f","splice","future","mongodbUri","parse","database","MongoConnection","maxPoolSize","db","admin","command","ismaster","resolver","isMasterDoc","setName","lastOplogEntry","oplogSelector","_","clone","$gt","cursorDescription","CursorDescription","tailable","tail","doc","push","_maybeStartWorker","return","defer","handleDoc","applyOps","nextTimestamp","forEach","add","ONE","dropCollection","dropDatabase","startsWith","collection","slice","has","drop","id","fire","isEmpty","pop","clear","each","_setLastProcessedTS","shift","sequencer","_defineTooFarBehind","value","_resetTooFarBehind"],"sources":["packages/mongo/oplog_tailing.js"],"sourcesContent":["var Future = Npm.require('fibers/future');\n\nimport { NpmModuleMongodb } from \"meteor/npm-mongo\";\nconst { Long } = NpmModuleMongodb;\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\nvar TAIL_TIMEOUT = +process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000;\n\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function (op) {\n  if (op.op === 'd')\n    return op.o._id;\n  else if (op.op === 'i')\n    return op.o._id;\n  else if (op.op === 'u')\n    return op.o2._id;\n  else if (op.op === 'c')\n    throw Error(\"Operator 'c' doesn't supply an object with id: \" +\n                EJSON.stringify(op));\n  else\n    throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp(\"^(?:\" + [\n      Meteor._escapeRegExp(self._dbName + \".\"),\n      Meteor._escapeRegExp(\"admin.$cmd\"),\n    ].join(\"|\") + \")\"),\n\n    $or: [\n      { op: { $in: ['i', 'u', 'd'] } },\n      // drop collection\n      { op: 'c', 'o.drop': { $exists: true } },\n      { op: 'c', 'o.dropDatabase': 1 },\n      { op: 'c', 'o.applyOps': { $exists: true } },\n    ]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\nObject.assign(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    if (self._tailHandle)\n      self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    self._readyFuture.wait();\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      originalCallback(notification);\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    self._readyFuture.wait();\n    var lastEntry;\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        lastEntry = self._oplogLastEntryConnection.findOne(\n          OPLOG_COLLECTION, self._baseOplogSelector,\n          {projection: {ts: 1}, sort: {$natural: -1}});\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry\", e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts)\n      throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpFutures.length;\n    while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    var f = new Future;\n    self._catchingUpFutures.splice(insertAfter, 0, {ts: ts, future: f});\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(\n      self._oplogUrl, {maxPoolSize: 1});\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(\n      self._oplogUrl, {maxPoolSize: 1});\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    // More on the isMasterDoc\n    // https://docs.mongodb.com/manual/reference/command/isMaster/\n    var f = new Future;\n    self._oplogLastEntryConnection.db.admin().command(\n      { ismaster: 1 }, f.resolver());\n    var isMasterDoc = f.wait();\n\n    if (!(isMasterDoc && isMasterDoc.setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(\n      OPLOG_COLLECTION, {}, {sort: {$natural: -1}, projection: {ts: 1}});\n\n    var oplogSelector = _.clone(self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {$gt: lastOplogEntry.ts};\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    var cursorDescription = new CursorDescription(\n      OPLOG_COLLECTION, oplogSelector, {tailable: true});\n\n    // Start tailing the oplog.\n    //\n    // We restart the low-level oplog query every 30 seconds if we didn't get a\n    // doc. This is a workaround for #8598: the Node Mongo driver has at least\n    // one bug that can lead to query callbacks never getting called (even with\n    // an error) when leadership failover occur.\n    self._tailHandle = self._oplogTailConnection.tail(\n      cursorDescription,\n      function (doc) {\n        self._entryQueue.push(doc);\n        self._maybeStartWorker();\n      },\n      TAIL_TIMEOUT\n    );\n    self._readyFuture.return();\n  },\n\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive) return;\n    self._workerActive = true;\n\n    Meteor.defer(function () {\n      // May be called recursively in case of transactions.\n      function handleDoc(doc) {\n        if (doc.ns === \"admin.$cmd\") {\n          if (doc.o.applyOps) {\n            // This was a successful transaction, so we need to apply the\n            // operations that were involved.\n            let nextTimestamp = doc.ts;\n            doc.o.applyOps.forEach(op => {\n              // See https://github.com/meteor/meteor/issues/10420.\n              if (!op.ts) {\n                op.ts = nextTimestamp;\n                nextTimestamp = nextTimestamp.add(Long.ONE);\n              }\n              handleDoc(op);\n            });\n            return;\n          }\n          throw new Error(\"Unknown command \" + EJSON.stringify(doc));\n        }\n\n        const trigger = {\n          dropCollection: false,\n          dropDatabase: false,\n          op: doc,\n        };\n\n        if (typeof doc.ns === \"string\" &&\n            doc.ns.startsWith(self._dbName + \".\")) {\n          trigger.collection = doc.ns.slice(self._dbName.length + 1);\n        }\n\n        // Is it a special command and the collection name is hidden\n        // somewhere in operator?\n        if (trigger.collection === \"$cmd\") {\n          if (doc.o.dropDatabase) {\n            delete trigger.collection;\n            trigger.dropDatabase = true;\n          } else if (_.has(doc.o, \"drop\")) {\n            trigger.collection = doc.o.drop;\n            trigger.dropCollection = true;\n            trigger.id = null;\n          } else if (\"create\" in doc.o && \"idIndex\" in doc.o) {\n            // A collection got implicitly created within a transaction. There's\n            // no need to do anything about it.\n          } else {\n            throw Error(\"Unknown command \" + EJSON.stringify(doc));\n          }\n\n        } else {\n          // All other ops have an id.\n          trigger.id = idForOp(doc);\n        }\n\n        self._crossbar.fire(trigger);\n      }\n\n      try {\n        while (! self._stopped &&\n               ! self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          const doc = self._entryQueue.shift();\n\n          // Fire trigger(s) for this doc.\n          handleDoc(doc);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (doc.ts) {\n            self._setLastProcessedTS(doc.ts);\n          } else {\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          }\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n      sequencer.future.return();\n    }\n  },\n\n  //Methods used on tests to dinamically change TOO_FAR_BEHIND\n  _defineTooFarBehind: function(value) {\n    TOO_FAR_BEHIND = value;\n  },\n  _resetTooFarBehind: function() {\n    TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n  }\n});\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"d11f4ef90cdf5267611f437a38e6e1c58ee35dba"}
