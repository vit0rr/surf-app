{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/minimongo/local_collection.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/minimongo/local_collection.js","filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/minimongo/local_collection.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/styles","root":"/Users/nicholas/Desktop/projects/local-legends/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/minimongo/local_collection.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/local_collection.js"}},"code":"let _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n}, 0);\nmodule.export({\n  default: () => LocalCollection\n});\nlet Cursor;\nmodule.link(\"./cursor.js\", {\n  default(v) {\n    Cursor = v;\n  }\n}, 0);\nlet ObserveHandle;\nmodule.link(\"./observe_handle.js\", {\n  default(v) {\n    ObserveHandle = v;\n  }\n}, 1);\nlet hasOwn, isIndexable, isNumericKey, isOperatorObject, populateDocumentWithQueryFields, projectionDetails;\nmodule.link(\"./common.js\", {\n  hasOwn(v) {\n    hasOwn = v;\n  },\n  isIndexable(v) {\n    isIndexable = v;\n  },\n  isNumericKey(v) {\n    isNumericKey = v;\n  },\n  isOperatorObject(v) {\n    isOperatorObject = v;\n  },\n  populateDocumentWithQueryFields(v) {\n    populateDocumentWithQueryFields = v;\n  },\n  projectionDetails(v) {\n    projectionDetails = v;\n  }\n}, 2);\nclass LocalCollection {\n  constructor(name) {\n    this.name = name;\n    // _id -> document (also containing id)\n    this._docs = new LocalCollection._IdMap();\n    this._observeQueue = new Meteor._SynchronousQueue();\n    this.next_qid = 1; // live query id generator\n\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n    this.queries = Object.create(null);\n\n    // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n    this._savedOriginals = null;\n\n    // True when observers are paused and we should not send callbacks.\n    this.paused = false;\n  }\n  countDocuments(selector, options) {\n    return this.find(selector !== null && selector !== void 0 ? selector : {}, options).countAsync();\n  }\n  estimatedDocumentCount(options) {\n    return this.find({}, options).countAsync();\n  }\n\n  // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n  find(selector, options) {\n    // default syntax for everything is to omit the selector argument.\n    // but if selector is explicitly passed in as false or undefined, we\n    // want a selector that matches nothing.\n    if (arguments.length === 0) {\n      selector = {};\n    }\n    return new LocalCollection.Cursor(this, selector, options);\n  }\n  findOne(selector) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    // NOTE: by setting limit 1 here, we end up using very inefficient\n    // code that recomputes the whole query on each update. The upside is\n    // that when you reactively depend on a findOne you only get\n    // invalidated when the found object changes, not any object in the\n    // collection. Most findOne will be by id, which has a fast path, so\n    // this might not be a big deal. In most cases, invalidation causes\n    // the called to re-query anyway, so this should be a net performance\n    // improvement.\n    options.limit = 1;\n    return this.find(selector, options).fetch()[0];\n  }\n\n  // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n  insert(doc, callback) {\n    doc = EJSON.clone(doc);\n    assertHasValidFieldNames(doc);\n\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    if (!hasOwn.call(doc, '_id')) {\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n    }\n    const id = doc._id;\n    if (this._docs.has(id)) {\n      throw MinimongoError(\"Duplicate _id '\".concat(id, \"'\"));\n    }\n    this._saveOriginal(id, undefined);\n    this._docs.set(id, doc);\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      if (query.dirty) {\n        return;\n      }\n      const matchResult = query.matcher.documentMatches(doc);\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          LocalCollection._insertInResults(query, doc);\n        }\n      }\n    });\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n    this._observeQueue.drain();\n\n    // Defer because the caller likely doesn't expect the callback to be run\n    // immediately.\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n    return id;\n  }\n\n  // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n  pauseObservers() {\n    // No-op if already paused.\n    if (this.paused) {\n      return;\n    }\n\n    // Set the 'paused' flag such that new observer messages don't fire.\n    this.paused = true;\n\n    // Take a snapshot of the query results for each query.\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      query.resultsSnapshot = EJSON.clone(query.results);\n    });\n  }\n  remove(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      const result = this._docs.size();\n      this._docs.clear();\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n        if (query.ordered) {\n          query.results = [];\n        } else {\n          query.results.clear();\n        }\n      });\n      if (callback) {\n        Meteor.defer(() => {\n          callback(null, result);\n        });\n      }\n      return result;\n    }\n    const matcher = new Minimongo.Matcher(selector);\n    const remove = [];\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\n      if (matcher.documentMatches(doc).result) {\n        remove.push(id);\n      }\n    });\n    const queriesToRecompute = [];\n    const queryRemove = [];\n    for (let i = 0; i < remove.length; i++) {\n      const removeId = remove[i];\n      const removeDoc = this._docs.get(removeId);\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n        if (query.dirty) {\n          return;\n        }\n        if (query.matcher.documentMatches(removeDoc).result) {\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            queryRemove.push({\n              qid,\n              doc: removeDoc\n            });\n          }\n        }\n      });\n      this._saveOriginal(removeId, removeDoc);\n      this._docs.remove(removeId);\n    }\n\n    // run live query callbacks _after_ we've removed the documents.\n    queryRemove.forEach(remove => {\n      const query = this.queries[remove.qid];\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        LocalCollection._removeFromResults(query, remove.doc);\n      }\n    });\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n    this._observeQueue.drain();\n    const result = remove.length;\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n    return result;\n  }\n\n  // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n  resumeObservers() {\n    // No-op if not paused.\n    if (!this.paused) {\n      return;\n    }\n\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\n    // observer methods won't actually fire when we trigger them.\n    this.paused = false;\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      if (query.dirty) {\n        query.dirty = false;\n\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\n        // automatically.\n        this._recomputeResults(query, query.resultsSnapshot);\n      } else {\n        // Diff the current results against the snapshot and send to observers.\n        // pass the query object for its observer callbacks.\n        LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n          projectionFn: query.projectionFn\n        });\n      }\n      query.resultsSnapshot = null;\n    });\n    this._observeQueue.drain();\n  }\n  retrieveOriginals() {\n    if (!this._savedOriginals) {\n      throw new Error('Called retrieveOriginals without saveOriginals');\n    }\n    const originals = this._savedOriginals;\n    this._savedOriginals = null;\n    return originals;\n  }\n\n  // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n  saveOriginals() {\n    if (this._savedOriginals) {\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\n    }\n    this._savedOriginals = new LocalCollection._IdMap();\n  }\n\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  update(selector, mod, options, callback) {\n    if (!callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n    if (!options) {\n      options = {};\n    }\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    // Save the original results of any query that we might need to\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n    // it. (We don't need to save the original results of paused queries because\n    // they already have a resultsSnapshot and we won't be diffing in\n    // _recomputeResults.)\n    const qidToOriginalResults = {};\n\n    // We should only clone each document once, even if it appears in multiple\n    // queries\n    const docMap = new LocalCollection._IdMap();\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      if ((query.cursor.skip || query.cursor.limit) && !this.paused) {\n        // Catch the case of a reactive `count()` on a cursor with skip\n        // or limit, which registers an unordered observe. This is a\n        // pretty rare case, so we just clone the entire result set with\n        // no optimizations for documents that appear in these result\n        // sets and other queries.\n        if (query.results instanceof LocalCollection._IdMap) {\n          qidToOriginalResults[qid] = query.results.clone();\n          return;\n        }\n        if (!(query.results instanceof Array)) {\n          throw new Error('Assertion failed: query.results not an array');\n        }\n\n        // Clones a document to be stored in `qidToOriginalResults`\n        // because it may be modified before the new and old result sets\n        // are diffed. But if we know exactly which document IDs we're\n        // going to modify, then we only need to clone those.\n        const memoizedCloneIfNeeded = doc => {\n          if (docMap.has(doc._id)) {\n            return docMap.get(doc._id);\n          }\n          const docToMemoize = idsMatched && !idsMatched.some(id => EJSON.equals(id, doc._id)) ? doc : EJSON.clone(doc);\n          docMap.set(doc._id, docToMemoize);\n          return docToMemoize;\n        };\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n      }\n    });\n    const recomputeQids = {};\n    let updateCount = 0;\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        this._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n        ++updateCount;\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n      return true;\n    });\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n    this._observeQueue.drain();\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (!doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n      insertedId = this.insert(doc);\n      updateCount = 1;\n    }\n\n    // Return the number of affected documents, or in the upsert case, an object\n    // containing the number of affected docs and the id of the doc that was\n    // inserted, if any.\n    let result;\n    if (options._returnObject) {\n      result = {\n        numberAffected: updateCount\n      };\n      if (insertedId !== undefined) {\n        result.insertedId = insertedId;\n      }\n    } else {\n      result = updateCount;\n    }\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n    return result;\n  }\n\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n  upsert(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    return this.update(selector, mod, Object.assign({}, options, {\n      upsert: true,\n      _returnObject: true\n    }), callback);\n  }\n\n  // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n  _eachPossiblyMatchingDoc(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n    if (specificIds) {\n      specificIds.some(id => {\n        const doc = this._docs.get(id);\n        if (doc) {\n          return fn(doc, id) === false;\n        }\n      });\n    } else {\n      this._docs.forEach(fn);\n    }\n  }\n  _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\n    const matched_before = {};\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      if (query.dirty) {\n        return;\n      }\n      if (query.ordered) {\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\n      } else {\n        // Because we don't support skip or limit (yet) in unordered queries, we\n        // can just do a direct lookup.\n        matched_before[qid] = query.results.has(doc._id);\n      }\n    });\n    const old_doc = EJSON.clone(doc);\n    LocalCollection._modify(doc, mod, {\n      arrayIndices\n    });\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      if (query.dirty) {\n        return;\n      }\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        LocalCollection._removeFromResults(query, doc);\n      } else if (!before && after) {\n        LocalCollection._insertInResults(query, doc);\n      } else if (before && after) {\n        LocalCollection._updateInResults(query, doc, old_doc);\n      }\n    });\n  }\n\n  // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n  _recomputeResults(query, oldResults) {\n    if (this.paused) {\n      // There's no reason to recompute the results now as we're still paused.\n      // By flagging the query as \"dirty\", the recompute will be performed\n      // when resumeObservers is called.\n      query.dirty = true;\n      return;\n    }\n    if (!this.paused && !oldResults) {\n      oldResults = query.results;\n    }\n    if (query.distances) {\n      query.distances.clear();\n    }\n    query.results = query.cursor._getRawObjects({\n      distances: query.distances,\n      ordered: query.ordered\n    });\n    if (!this.paused) {\n      LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n        projectionFn: query.projectionFn\n      });\n    }\n  }\n  _saveOriginal(id, doc) {\n    // Are we even trying to save originals?\n    if (!this._savedOriginals) {\n      return;\n    }\n\n    // Have we previously mutated the original (and so 'doc' is not actually\n    // original)?  (Note the 'has' check rather than truth: we store undefined\n    // here for inserted docs!)\n    if (this._savedOriginals.has(id)) {\n      return;\n    }\n    this._savedOriginals.set(id, EJSON.clone(doc));\n  }\n}\nLocalCollection.Cursor = Cursor;\nLocalCollection.ObserveHandle = ObserveHandle;\n\n// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const orderedFromCallbacks = options.callbacks && LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n    const callbacks = options.callbacks || {};\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: (id, fields, before) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = _objectSpread({}, fields);\n          doc._id = id;\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(this, id, EJSON.clone(fields), before);\n          }\n\n          // This line triggers if we provide added with movedBefore.\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n          this.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: (id, before) => {\n          const doc = this.docs.get(id);\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(this, id, before);\n          }\n          this.docs.moveBefore(id, before || null);\n        }\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap();\n      this.applyChange = {\n        added: (id, fields) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = _objectSpread({}, fields);\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n          doc._id = id;\n          this.docs.set(id, doc);\n        }\n      };\n    }\n\n    // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n    this.applyChange.changed = (id, fields) => {\n      const doc = this.docs.get(id);\n      if (!doc) {\n        throw new Error(\"Unknown id for changed: \".concat(id));\n      }\n      if (callbacks.changed) {\n        callbacks.changed.call(this, id, EJSON.clone(fields));\n      }\n      DiffSequence.applyChanges(doc, fields);\n    };\n    this.applyChange.removed = id => {\n      if (callbacks.removed) {\n        callbacks.removed.call(this, id);\n      }\n      this.docs.remove(id);\n    };\n  }\n};\nLocalCollection._IdMap = class _IdMap extends IdMap {\n  constructor() {\n    super(MongoID.idStringify, MongoID.idParse);\n  }\n};\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = transform => {\n  if (!transform) {\n    return null;\n  }\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n  const wrapped = doc => {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n    const id = doc._id;\n\n    // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n    const transformed = Tracker.nonreactive(() => transform(doc));\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n    return transformed;\n  };\n  wrapped.__wrappedTransform__ = true;\n  return wrapped;\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = (cmp, array, value) => {\n  let first = 0;\n  let range = array.length;\n  while (range > 0) {\n    const halfRange = Math.floor(range / 2);\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n  return first;\n};\nLocalCollection._checkSupportedProjection = fields => {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n  Object.keys(fields).forEach(keyPath => {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError('Minimongo doesn\\'t support $ operator in projections yet.');\n    }\n    const value = fields[keyPath];\n    if (typeof value === 'object' && ['$elemMatch', '$meta', '$slice'].some(key => hasOwn.call(value, key))) {\n      throw MinimongoError('Minimongo doesn\\'t support operators in projections yet.');\n    }\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError('Projection values should be one of 1, 0, true, or false');\n    }\n  });\n};\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = fields => {\n  LocalCollection._checkSupportedProjection(fields);\n  const _idProjection = fields._id === undefined ? true : fields._id;\n  const details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  const transform = (doc, ruleTree) => {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(subdoc => transform(subdoc, ruleTree));\n    }\n    const result = details.including ? {} : EJSON.clone(doc);\n    Object.keys(ruleTree).forEach(key => {\n      if (doc == null || !hasOwn.call(doc, key)) {\n        return;\n      }\n      const rule = ruleTree[key];\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n    return doc != null ? result : doc;\n  };\n  return doc => {\n    const result = transform(doc, details.tree);\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n    return result;\n  };\n};\n\n// Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\nLocalCollection._createUpsertDocument = (selector, modifier) => {\n  const selectorDocument = populateDocumentWithQueryFields(selector);\n  const isModify = LocalCollection._isModificationMod(modifier);\n  const newDoc = {};\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  }\n\n  // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n  LocalCollection._modify(newDoc, {\n    $set: selectorDocument\n  });\n  LocalCollection._modify(newDoc, modifier, {\n    isInsert: true\n  });\n  if (isModify) {\n    return newDoc;\n  }\n\n  // Replacement can take _id from query document\n  const replacement = Object.assign({}, modifier);\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n  return replacement;\n};\nLocalCollection._diffObjects = (left, right, callbacks) => {\n  return DiffSequence.diffObjects(left, right, callbacks);\n};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) => DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) => DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) => DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\nLocalCollection._findInOrderedResults = (query, doc) => {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n  for (let i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n  throw Error('object missing from query');\n};\n\n// If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\nLocalCollection._idsMatchedBySelector = selector => {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n  if (!selector) {\n    return null;\n  }\n\n  // Do we have an _id clause?\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    }\n\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n    if (selector._id && Array.isArray(selector._id.$in) && selector._id.$in.length && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n    return null;\n  }\n\n  // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n  if (Array.isArray(selector.$and)) {\n    for (let i = 0; i < selector.$and.length; ++i) {\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n  return null;\n};\nLocalCollection._insertInResults = (query, doc) => {\n  const fields = EJSON.clone(doc);\n  delete fields._id;\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\nLocalCollection._insertInSortedList = (cmp, array, value) => {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n  const i = LocalCollection._binarySearch(cmp, array, value);\n  array.splice(i, 0, value);\n  return i;\n};\nLocalCollection._isModificationMod = mod => {\n  let isModify = false;\n  let isReplace = false;\n  Object.keys(mod).forEach(key => {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n  if (isModify && isReplace) {\n    throw new Error('Update parameter cannot have both modifier and non-modifier fields.');\n  }\n  return isModify;\n};\n\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\nLocalCollection._isPlainObject = x => {\n  return x && LocalCollection._f._type(x) === 3;\n};\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = function (doc, modifier) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  }\n\n  // Make sure the caller can't mutate our data structures.\n  modifier = EJSON.clone(modifier);\n  const isModifier = isOperatorObject(modifier);\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(operator => {\n      // Treat $setOnInsert as $set if this is an insert.\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      const operand = modifier[operator];\n      if (!modFunc) {\n        throw MinimongoError(\"Invalid modifier specified \".concat(operator));\n      }\n      Object.keys(operand).forEach(keypath => {\n        const arg = operand[keypath];\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n        const keyparts = keypath.split('.');\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\"The update path '\".concat(keypath, \"' contains an empty field name, \") + 'which is not allowed.');\n        }\n        const target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\"After applying the update to the document {_id: \\\"\".concat(doc._id, \"\\\", ...},\") + ' the (immutable) field \\'_id\\' was found to have been altered to ' + \"_id: \\\"\".concat(newDoc._id, \"\\\"\"));\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\"The _id field cannot be changed from {_id: \\\"\".concat(doc._id, \"\\\"} to \") + \"{_id: \\\"\".concat(modifier._id, \"\\\"}\"));\n    }\n\n    // replace the whole document\n    assertHasValidFieldNames(modifier);\n  }\n\n  // move new document into place.\n  Object.keys(doc).forEach(key => {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n  Object.keys(newDoc).forEach(key => {\n    doc[key] = newDoc[key];\n  });\n};\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\n  const transform = cursor.getTransform() || (doc => doc);\n  let suppressed = !!observeCallbacks._suppress_initial;\n  let observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    const indices = !observeCallbacks._no_indices;\n    observeChangesCallbacks = {\n      addedBefore(id, fields, before) {\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\n          return;\n        }\n        const doc = transform(Object.assign(fields, {\n          _id: id\n        }));\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(doc, indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1, before);\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed(id, fields) {\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n        let doc = EJSON.clone(this.docs.get(id));\n        if (!doc) {\n          throw new Error(\"Unknown id for changed: \".concat(id));\n        }\n        const oldDoc = transform(EJSON.clone(doc));\n        DiffSequence.applyChanges(doc, fields);\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(transform(doc), oldDoc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore(id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n        const from = indices ? this.docs.indexOf(id) : -1;\n        let to = indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1;\n\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from) {\n          --to;\n        }\n        observeCallbacks.movedTo(transform(EJSON.clone(this.docs.get(id))), from, to, before || null);\n      },\n      removed(id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        }\n\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n        const doc = transform(this.docs.get(id));\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      }\n    };\n  } else {\n    observeChangesCallbacks = {\n      added(id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {\n            _id: id\n          })));\n        }\n      },\n      changed(id, fields) {\n        if (observeCallbacks.changed) {\n          const oldDoc = this.docs.get(id);\n          const doc = EJSON.clone(oldDoc);\n          DiffSequence.applyChanges(doc, fields);\n          observeCallbacks.changed(transform(doc), transform(EJSON.clone(oldDoc)));\n        }\n      },\n      removed(id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      }\n    };\n  }\n  const changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n\n  // CachingChangeObserver clones all received input on its callbacks\n  // So we can mark it as safe to reduce the ejson clones.\n  // This is tested by the `mongo-livedata - (extended) scribbling` tests\n  changeObserver.applyChange._fromObserve = true;\n  const handle = cursor.observeChanges(changeObserver.applyChange, {\n    nonMutatingCallbacks: true\n  });\n  suppressed = false;\n  return handle;\n};\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n  return !!(callbacks.addedAt || callbacks.changedAt || callbacks.movedTo || callbacks.removedAt);\n};\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\nLocalCollection._removeFromResults = (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id; // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\n// Is this selector just shorthand for lookup by _id?\nLocalCollection._selectorIsId = selector => typeof selector === 'number' || typeof selector === 'string' || selector instanceof MongoID.ObjectID;\n\n// Is the selector just lookup by _id (shorthand or not)?\nLocalCollection._selectorIsIdPerhapsAsObject = selector => LocalCollection._selectorIsId(selector) || LocalCollection._selectorIsId(selector && selector._id) && Object.keys(selector).length === 1;\nLocalCollection._updateInResults = (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n    return;\n  }\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n  const new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n    distances: query.distances\n  }), query.results, doc);\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\nconst MODIFIERS = {\n  $currentDate(target, field, arg) {\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError('Minimongo does currently only support the date type in ' + '$currentDate modifiers', {\n          field\n        });\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {\n        field\n      });\n    }\n    target[field] = new Date();\n  },\n  $inc(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {\n        field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $inc modifier to non-number', {\n          field\n        });\n      }\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $min(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {\n        field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $min modifier to non-number', {\n          field\n        });\n      }\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {\n        field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $max modifier to non-number', {\n          field\n        });\n      }\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $mul(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $mul allowed for numbers only', {\n        field\n      });\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError('Cannot apply $mul modifier to non-number', {\n          field\n        });\n      }\n      target[field] *= arg;\n    } else {\n      target[field] = 0;\n    }\n  },\n  $rename(target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {\n        field\n      });\n    }\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {\n        field\n      });\n    }\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {\n        field\n      });\n    }\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError('The \\'to\\' field for $rename cannot contain an embedded null byte', {\n        field\n      });\n    }\n    if (target === undefined) {\n      return;\n    }\n    const object = target[field];\n    delete target[field];\n    const keyparts = arg.split('.');\n    const target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {\n        field\n      });\n    }\n    target2[keyparts.pop()] = object;\n  },\n  $set(target, field, arg) {\n    if (target !== Object(target)) {\n      // not an array or an object\n      const error = MinimongoError('Cannot set property on non-object field', {\n        field\n      });\n      error.setPropertyError = true;\n      throw error;\n    }\n    if (target === null) {\n      const error = MinimongoError('Cannot set property on null', {\n        field\n      });\n      error.setPropertyError = true;\n      throw error;\n    }\n    assertHasValidFieldNames(arg);\n    target[field] = arg;\n  },\n  $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {\n        field\n      });\n    }\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    const toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {\n        field\n      });\n    }\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    let position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {\n          field\n        });\n      }\n\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw MinimongoError('$position in $push must be zero or positive', {\n          field\n        });\n      }\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    let slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {\n          field\n        });\n      }\n\n      // XXX should check to make sure integer\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    let sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {\n          field\n        });\n      }\n\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      toPush.forEach(element => {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError('$push like modifiers using $sort require all elements to be ' + 'objects', {\n            field\n          });\n        }\n      });\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      toPush.forEach(element => {\n        target[field].push(element);\n      });\n    } else {\n      const spliceArguments = [position, 0];\n      toPush.forEach(element => {\n        spliceArguments.push(element);\n      });\n      target[field].splice(...spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n    assertHasValidFieldNames(arg);\n    const toPush = target[field];\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError('Cannot apply $pushAll modifier to non-array', {\n        field\n      });\n    } else {\n      toPush.push(...arg);\n    }\n  },\n  $addToSet(target, field, arg) {\n    let isEach = false;\n    if (typeof arg === 'object') {\n      // check if first key is '$each'\n      const keys = Object.keys(arg);\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n    const values = isEach ? arg.$each : [arg];\n    assertHasValidFieldNames(values);\n    const toAdd = target[field];\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError('Cannot apply $addToSet modifier to non-array', {\n        field\n      });\n    } else {\n      values.forEach(value => {\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\n          return;\n        }\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    const toPop = target[field];\n    if (toPop === undefined) {\n      return;\n    }\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {\n        field\n      });\n    }\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    const toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n        field\n      });\n    }\n    let out;\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      const matcher = new Minimongo.Matcher(arg);\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\n    } else {\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\n    }\n    target[field] = out;\n  },\n  $pullAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only', {\n        field\n      });\n    }\n    if (target === undefined) {\n      return;\n    }\n    const toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n        field\n      });\n    }\n    target[field] = toPull.filter(object => !arg.some(element => LocalCollection._f._equal(object, element)));\n  },\n  $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {\n      field\n    });\n  },\n  $v() {\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\nconst NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n};\n\n// Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\nconst invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n};\n\n// checks if all field names in an object are valid\nfunction assertHasValidFieldNames(doc) {\n  if (doc && typeof doc === 'object') {\n    JSON.stringify(doc, (key, value) => {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\nfunction assertIsValidFieldName(key) {\n  let match;\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(\"Key \".concat(key, \" must not \").concat(invalidCharMsg[match[0]]));\n  }\n}\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nfunction findModTarget(doc, keyparts) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let usedArrayIndex = false;\n  for (let i = 0; i < keyparts.length; i++) {\n    const last = i === keyparts.length - 1;\n    let keypart = keyparts[i];\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n      const error = MinimongoError(\"cannot use the part '\".concat(keypart, \"' to traverse \").concat(doc));\n      error.setPropertyError = true;\n      throw error;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError('The positional operator did not find the match needed from the ' + 'query');\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n        throw MinimongoError(\"can't append to array using string field name [\".concat(keypart, \"]\"));\n      }\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (typeof doc[keypart] !== 'object') {\n          throw MinimongoError(\"can't modify field '\".concat(keyparts[i + 1], \"' of list value \") + JSON.stringify(doc[keypart]));\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n    if (last) {\n      return doc;\n    }\n    doc = doc[keypart];\n  }\n\n  // notreached\n}","map":{"version":3,"names":["_objectSpread","module","link","default","v","export","LocalCollection","Cursor","ObserveHandle","hasOwn","isIndexable","isNumericKey","isOperatorObject","populateDocumentWithQueryFields","projectionDetails","constructor","name","_docs","_IdMap","_observeQueue","Meteor","_SynchronousQueue","next_qid","queries","Object","create","_savedOriginals","paused","countDocuments","selector","options","find","countAsync","estimatedDocumentCount","arguments","length","findOne","undefined","limit","fetch","insert","doc","callback","EJSON","clone","assertHasValidFieldNames","call","_id","_useOID","MongoID","ObjectID","Random","id","has","MinimongoError","concat","_saveOriginal","set","queriesToRecompute","keys","forEach","qid","query","dirty","matchResult","matcher","documentMatches","result","distances","distance","cursor","skip","push","_insertInResults","_recomputeResults","drain","defer","pauseObservers","resultsSnapshot","results","remove","equals","size","clear","ordered","Minimongo","Matcher","_eachPossiblyMatchingDoc","queryRemove","i","removeId","removeDoc","get","_removeFromResults","resumeObservers","_diffQueryChanges","projectionFn","retrieveOriginals","Error","originals","saveOriginals","update","mod","Function","qidToOriginalResults","docMap","idsMatched","_idsMatchedBySelector","Array","memoizedCloneIfNeeded","docToMemoize","some","map","recomputeQids","updateCount","queryResult","_modifyAndNotify","arrayIndices","multi","insertedId","upsert","_createUpsertDocument","_returnObject","numberAffected","assign","fn","specificIds","matched_before","old_doc","_modify","afterMatch","after","before","_updateInResults","oldResults","_getRawObjects","_CachingChangeObserver","orderedFromCallbacks","callbacks","_observeChangesCallbacksAreOrdered","docs","OrderedDict","idStringify","applyChange","addedBefore","fields","added","putBefore","movedBefore","moveBefore","changed","DiffSequence","applyChanges","removed","IdMap","idParse","wrapTransform","transform","__wrappedTransform__","wrapped","transformed","Tracker","nonreactive","_isPlainObject","_binarySearch","cmp","array","value","first","range","halfRange","Math","floor","_checkSupportedProjection","isArray","keyPath","split","includes","key","_compileProjection","_idProjection","details","ruleTree","subdoc","including","rule","tree","modifier","selectorDocument","isModify","_isModificationMod","newDoc","$set","isInsert","replacement","_diffObjects","left","right","diffObjects","newResults","observer","diffQueryChanges","_diffQueryOrderedChanges","diffQueryOrderedChanges","_diffQueryUnorderedChanges","diffQueryUnorderedChanges","_findInOrderedResults","_selectorIsId","$in","every","$and","subIds","sorter","_insertInSortedList","getComparator","next","splice","isReplace","substr","x","_f","_type","isModifier","operator","setOnInsert","modFunc","MODIFIERS","operand","keypath","arg","keyparts","Boolean","target","findModTarget","forbidArray","noCreate","NO_CREATE_MODIFIERS","pop","_observeFromObserveChanges","observeCallbacks","getTransform","suppressed","_suppress_initial","observeChangesCallbacks","_observeCallbacksAreOrdered","indices","_no_indices","addedAt","indexOf","changedAt","oldDoc","movedTo","from","to","removedAt","changeObserver","_fromObserve","handle","observeChanges","nonMutatingCallbacks","_selectorIsIdPerhapsAsObject","changedFields","makeChangedFields","old_idx","new_idx","$currentDate","field","$type","Date","$inc","$min","$max","$mul","$rename","object","target2","error","setPropertyError","$setOnInsert","$unset","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","Sorter","element","spliceArguments","sort","$pushAll","$addToSet","isEach","values","toAdd","_equal","$pop","toPop","$pull","toPull","out","filter","$pullAll","$bit","$v","invalidCharMsg","$","JSON","stringify","assertIsValidFieldName","match","usedArrayIndex","last","keypart","parseInt"],"sources":["packages/minimongo/local_collection.js"],"sourcesContent":["import Cursor from './cursor.js';\nimport ObserveHandle from './observe_handle.js';\nimport {\n  hasOwn,\n  isIndexable,\n  isNumericKey,\n  isOperatorObject,\n  populateDocumentWithQueryFields,\n  projectionDetails,\n} from './common.js';\n\n// XXX type checking on selectors (graceful error if malformed)\n\n// LocalCollection: a set of documents that supports queries and modifiers.\nexport default class LocalCollection {\n  constructor(name) {\n    this.name = name;\n    // _id -> document (also containing id)\n    this._docs = new LocalCollection._IdMap;\n\n    this._observeQueue = new Meteor._SynchronousQueue();\n\n    this.next_qid = 1; // live query id generator\n\n    // qid -> live query object. keys:\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n    //  results: array (ordered) or object (unordered) of current results\n    //    (aliased with this._docs!)\n    //  resultsSnapshot: snapshot of results. null if not paused.\n    //  cursor: Cursor object for the query.\n    //  selector, sorter, (callbacks): functions\n    this.queries = Object.create(null);\n\n    // null if not saving originals; an IdMap from id to original document value\n    // if saving originals. See comments before saveOriginals().\n    this._savedOriginals = null;\n\n    // True when observers are paused and we should not send callbacks.\n    this.paused = false;\n  }\n\n  countDocuments(selector, options) {\n    return this.find(selector ?? {}, options).countAsync();\n  }\n\n  estimatedDocumentCount(options) {\n    return this.find({}, options).countAsync();\n  }\n\n  // options may include sort, skip, limit, reactive\n  // sort may be any of these forms:\n  //     {a: 1, b: -1}\n  //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n  //     [\"a\", [\"b\", \"desc\"]]\n  //   (in the first form you're beholden to key enumeration order in\n  //   your javascript VM)\n  //\n  // reactive: if given, and false, don't register with Tracker (default\n  // is true)\n  //\n  // XXX possibly should support retrieving a subset of fields? and\n  // have it be a hint (ignored on the client, when not copying the\n  // doc?)\n  //\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\n  // XXX add one more sort form: \"key\"\n  // XXX tests\n  find(selector, options) {\n    // default syntax for everything is to omit the selector argument.\n    // but if selector is explicitly passed in as false or undefined, we\n    // want a selector that matches nothing.\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    return new LocalCollection.Cursor(this, selector, options);\n  }\n\n  findOne(selector, options = {}) {\n    if (arguments.length === 0) {\n      selector = {};\n    }\n\n    // NOTE: by setting limit 1 here, we end up using very inefficient\n    // code that recomputes the whole query on each update. The upside is\n    // that when you reactively depend on a findOne you only get\n    // invalidated when the found object changes, not any object in the\n    // collection. Most findOne will be by id, which has a fast path, so\n    // this might not be a big deal. In most cases, invalidation causes\n    // the called to re-query anyway, so this should be a net performance\n    // improvement.\n    options.limit = 1;\n\n    return this.find(selector, options).fetch()[0];\n  }\n\n  // XXX possibly enforce that 'undefined' does not appear (we assume\n  // this in our handling of null and $exists)\n  insert(doc, callback) {\n    doc = EJSON.clone(doc);\n\n    assertHasValidFieldNames(doc);\n\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    if (!hasOwn.call(doc, '_id')) {\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n    }\n\n    const id = doc._id;\n\n    if (this._docs.has(id)) {\n      throw MinimongoError(`Duplicate _id '${id}'`);\n    }\n\n    this._saveOriginal(id, undefined);\n    this._docs.set(id, doc);\n\n    const queriesToRecompute = [];\n\n    // trigger live queries that match\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      const matchResult = query.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (query.distances && matchResult.distance !== undefined) {\n          query.distances.set(id, matchResult.distance);\n        }\n\n        if (query.cursor.skip || query.cursor.limit) {\n          queriesToRecompute.push(qid);\n        } else {\n          LocalCollection._insertInResults(query, doc);\n        }\n      }\n    });\n\n    queriesToRecompute.forEach(qid => {\n      if (this.queries[qid]) {\n        this._recomputeResults(this.queries[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    // Defer because the caller likely doesn't expect the callback to be run\n    // immediately.\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, id);\n      });\n    }\n\n    return id;\n  }\n\n  // Pause the observers. No callbacks from observers will fire until\n  // 'resumeObservers' is called.\n  pauseObservers() {\n    // No-op if already paused.\n    if (this.paused) {\n      return;\n    }\n\n    // Set the 'paused' flag such that new observer messages don't fire.\n    this.paused = true;\n\n    // Take a snapshot of the query results for each query.\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n      query.resultsSnapshot = EJSON.clone(query.results);\n    });\n  }\n\n  remove(selector, callback) {\n    // Easy special case: if we're not calling observeChanges callbacks and\n    // we're not saving originals and we got asked to remove everything, then\n    // just empty everything directly.\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n      const result = this._docs.size();\n\n      this._docs.clear();\n\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n\n        if (query.ordered) {\n          query.results = [];\n        } else {\n          query.results.clear();\n        }\n      });\n\n      if (callback) {\n        Meteor.defer(() => {\n          callback(null, result);\n        });\n      }\n\n      return result;\n    }\n\n    const matcher = new Minimongo.Matcher(selector);\n    const remove = [];\n\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\n      if (matcher.documentMatches(doc).result) {\n        remove.push(id);\n      }\n    });\n\n    const queriesToRecompute = [];\n    const queryRemove = [];\n\n    for (let i = 0; i < remove.length; i++) {\n      const removeId = remove[i];\n      const removeDoc = this._docs.get(removeId);\n\n      Object.keys(this.queries).forEach(qid => {\n        const query = this.queries[qid];\n\n        if (query.dirty) {\n          return;\n        }\n\n        if (query.matcher.documentMatches(removeDoc).result) {\n          if (query.cursor.skip || query.cursor.limit) {\n            queriesToRecompute.push(qid);\n          } else {\n            queryRemove.push({qid, doc: removeDoc});\n          }\n        }\n      });\n\n      this._saveOriginal(removeId, removeDoc);\n      this._docs.remove(removeId);\n    }\n\n    // run live query callbacks _after_ we've removed the documents.\n    queryRemove.forEach(remove => {\n      const query = this.queries[remove.qid];\n\n      if (query) {\n        query.distances && query.distances.remove(remove.doc._id);\n        LocalCollection._removeFromResults(query, remove.doc);\n      }\n    });\n\n    queriesToRecompute.forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    const result = remove.length;\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // Resume the observers. Observers immediately receive change\n  // notifications to bring them to the current state of the\n  // database. Note that this is not just replaying all the changes that\n  // happened during the pause, it is a smarter 'coalesced' diff.\n  resumeObservers() {\n    // No-op if not paused.\n    if (!this.paused) {\n      return;\n    }\n\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\n    // observer methods won't actually fire when we trigger them.\n    this.paused = false;\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        query.dirty = false;\n\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\n        // automatically.\n        this._recomputeResults(query, query.resultsSnapshot);\n      } else {\n        // Diff the current results against the snapshot and send to observers.\n        // pass the query object for its observer callbacks.\n        LocalCollection._diffQueryChanges(\n          query.ordered,\n          query.resultsSnapshot,\n          query.results,\n          query,\n          {projectionFn: query.projectionFn}\n        );\n      }\n\n      query.resultsSnapshot = null;\n    });\n\n    this._observeQueue.drain();\n  }\n\n  retrieveOriginals() {\n    if (!this._savedOriginals) {\n      throw new Error('Called retrieveOriginals without saveOriginals');\n    }\n\n    const originals = this._savedOriginals;\n\n    this._savedOriginals = null;\n\n    return originals;\n  }\n\n  // To track what documents are affected by a piece of code, call\n  // saveOriginals() before it and retrieveOriginals() after it.\n  // retrieveOriginals returns an object whose keys are the ids of the documents\n  // that were affected since the call to saveOriginals(), and the values are\n  // equal to the document's contents at the time of saveOriginals. (In the case\n  // of an inserted document, undefined is the value.) You must alternate\n  // between calls to saveOriginals() and retrieveOriginals().\n  saveOriginals() {\n    if (this._savedOriginals) {\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\n    }\n\n    this._savedOriginals = new LocalCollection._IdMap;\n  }\n\n  // XXX atomicity: if multi is true, and one modification fails, do\n  // we rollback the whole operation, or what?\n  update(selector, mod, options, callback) {\n    if (! callback && options instanceof Function) {\n      callback = options;\n      options = null;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const matcher = new Minimongo.Matcher(selector, true);\n\n    // Save the original results of any query that we might need to\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n    // it. (We don't need to save the original results of paused queries because\n    // they already have a resultsSnapshot and we won't be diffing in\n    // _recomputeResults.)\n    const qidToOriginalResults = {};\n\n    // We should only clone each document once, even if it appears in multiple\n    // queries\n    const docMap = new LocalCollection._IdMap;\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if ((query.cursor.skip || query.cursor.limit) && ! this.paused) {\n        // Catch the case of a reactive `count()` on a cursor with skip\n        // or limit, which registers an unordered observe. This is a\n        // pretty rare case, so we just clone the entire result set with\n        // no optimizations for documents that appear in these result\n        // sets and other queries.\n        if (query.results instanceof LocalCollection._IdMap) {\n          qidToOriginalResults[qid] = query.results.clone();\n          return;\n        }\n\n        if (!(query.results instanceof Array)) {\n          throw new Error('Assertion failed: query.results not an array');\n        }\n\n        // Clones a document to be stored in `qidToOriginalResults`\n        // because it may be modified before the new and old result sets\n        // are diffed. But if we know exactly which document IDs we're\n        // going to modify, then we only need to clone those.\n        const memoizedCloneIfNeeded = doc => {\n          if (docMap.has(doc._id)) {\n            return docMap.get(doc._id);\n          }\n\n          const docToMemoize = (\n            idsMatched &&\n            !idsMatched.some(id => EJSON.equals(id, doc._id))\n          ) ? doc : EJSON.clone(doc);\n\n          docMap.set(doc._id, docToMemoize);\n\n          return docToMemoize;\n        };\n\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n      }\n    });\n\n    const recomputeQids = {};\n\n    let updateCount = 0;\n\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\n      const queryResult = matcher.documentMatches(doc);\n\n      if (queryResult.result) {\n        // XXX Should we save the original even if mod ends up being a no-op?\n        this._saveOriginal(id, doc);\n        this._modifyAndNotify(\n          doc,\n          mod,\n          recomputeQids,\n          queryResult.arrayIndices\n        );\n\n        ++updateCount;\n\n        if (!options.multi) {\n          return false; // break\n        }\n      }\n\n      return true;\n    });\n\n    Object.keys(recomputeQids).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query) {\n        this._recomputeResults(query, qidToOriginalResults[qid]);\n      }\n    });\n\n    this._observeQueue.drain();\n\n    // If we are doing an upsert, and we didn't modify any documents yet, then\n    // it's time to do an insert. Figure out what document we are inserting, and\n    // generate an id for it.\n    let insertedId;\n    if (updateCount === 0 && options.upsert) {\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\n      if (! doc._id && options.insertedId) {\n        doc._id = options.insertedId;\n      }\n\n      insertedId = this.insert(doc);\n      updateCount = 1;\n    }\n\n    // Return the number of affected documents, or in the upsert case, an object\n    // containing the number of affected docs and the id of the doc that was\n    // inserted, if any.\n    let result;\n    if (options._returnObject) {\n      result = {numberAffected: updateCount};\n\n      if (insertedId !== undefined) {\n        result.insertedId = insertedId;\n      }\n    } else {\n      result = updateCount;\n    }\n\n    if (callback) {\n      Meteor.defer(() => {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n  // _returnObject: true}).\n  upsert(selector, mod, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.update(\n      selector,\n      mod,\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\n      callback\n    );\n  }\n\n  // Iterates over a subset of documents that could match selector; calls\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n  // same object that is in _docs.\n  _eachPossiblyMatchingDoc(selector, fn) {\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n    if (specificIds) {\n      specificIds.some(id => {\n        const doc = this._docs.get(id);\n\n        if (doc) {\n          return fn(doc, id) === false;\n        }\n      });\n    } else {\n      this._docs.forEach(fn);\n    }\n  }\n\n  _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\n    const matched_before = {};\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      if (query.ordered) {\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\n      } else {\n        // Because we don't support skip or limit (yet) in unordered queries, we\n        // can just do a direct lookup.\n        matched_before[qid] = query.results.has(doc._id);\n      }\n    });\n\n    const old_doc = EJSON.clone(doc);\n\n    LocalCollection._modify(doc, mod, {arrayIndices});\n\n    Object.keys(this.queries).forEach(qid => {\n      const query = this.queries[qid];\n\n      if (query.dirty) {\n        return;\n      }\n\n      const afterMatch = query.matcher.documentMatches(doc);\n      const after = afterMatch.result;\n      const before = matched_before[qid];\n\n      if (after && query.distances && afterMatch.distance !== undefined) {\n        query.distances.set(doc._id, afterMatch.distance);\n      }\n\n      if (query.cursor.skip || query.cursor.limit) {\n        // We need to recompute any query where the doc may have been in the\n        // cursor's window either before or after the update. (Note that if skip\n        // or limit is set, \"before\" and \"after\" being true do not necessarily\n        // mean that the document is in the cursor's output after skip/limit is\n        // applied... but if they are false, then the document definitely is NOT\n        // in the output. So it's safe to skip recompute if neither before or\n        // after are true.)\n        if (before || after) {\n          recomputeQids[qid] = true;\n        }\n      } else if (before && !after) {\n        LocalCollection._removeFromResults(query, doc);\n      } else if (!before && after) {\n        LocalCollection._insertInResults(query, doc);\n      } else if (before && after) {\n        LocalCollection._updateInResults(query, doc, old_doc);\n      }\n    });\n  }\n\n  // Recomputes the results of a query and runs observe callbacks for the\n  // difference between the previous results and the current results (unless\n  // paused). Used for skip/limit queries.\n  //\n  // When this is used by insert or remove, it can just use query.results for\n  // the old results (and there's no need to pass in oldResults), because these\n  // operations don't mutate the documents in the collection. Update needs to\n  // pass in an oldResults which was deep-copied before the modifier was\n  // applied.\n  //\n  // oldResults is guaranteed to be ignored if the query is not paused.\n  _recomputeResults(query, oldResults) {\n    if (this.paused) {\n      // There's no reason to recompute the results now as we're still paused.\n      // By flagging the query as \"dirty\", the recompute will be performed\n      // when resumeObservers is called.\n      query.dirty = true;\n      return;\n    }\n\n    if (!this.paused && !oldResults) {\n      oldResults = query.results;\n    }\n\n    if (query.distances) {\n      query.distances.clear();\n    }\n\n    query.results = query.cursor._getRawObjects({\n      distances: query.distances,\n      ordered: query.ordered\n    });\n\n    if (!this.paused) {\n      LocalCollection._diffQueryChanges(\n        query.ordered,\n        oldResults,\n        query.results,\n        query,\n        {projectionFn: query.projectionFn}\n      );\n    }\n  }\n\n  _saveOriginal(id, doc) {\n    // Are we even trying to save originals?\n    if (!this._savedOriginals) {\n      return;\n    }\n\n    // Have we previously mutated the original (and so 'doc' is not actually\n    // original)?  (Note the 'has' check rather than truth: we store undefined\n    // here for inserted docs!)\n    if (this._savedOriginals.has(id)) {\n      return;\n    }\n\n    this._savedOriginals.set(id, EJSON.clone(doc));\n  }\n}\n\nLocalCollection.Cursor = Cursor;\n\nLocalCollection.ObserveHandle = ObserveHandle;\n\n// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in this.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\n  constructor(options = {}) {\n    const orderedFromCallbacks = (\n      options.callbacks &&\n      LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks)\n    );\n\n    if (hasOwn.call(options, 'ordered')) {\n      this.ordered = options.ordered;\n\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n        throw Error('ordered option doesn\\'t match callbacks');\n      }\n    } else if (options.callbacks) {\n      this.ordered = orderedFromCallbacks;\n    } else {\n      throw Error('must provide ordered or callbacks');\n    }\n\n    const callbacks = options.callbacks || {};\n\n    if (this.ordered) {\n      this.docs = new OrderedDict(MongoID.idStringify);\n      this.applyChange = {\n        addedBefore: (id, fields, before) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = { ...fields };\n\n          doc._id = id;\n\n          if (callbacks.addedBefore) {\n            callbacks.addedBefore.call(this, id, EJSON.clone(fields), before);\n          }\n\n          // This line triggers if we provide added with movedBefore.\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          // XXX could `before` be a falsy ID?  Technically\n          // idStringify seems to allow for them -- though\n          // OrderedDict won't call stringify on a falsy arg.\n          this.docs.putBefore(id, doc, before || null);\n        },\n        movedBefore: (id, before) => {\n          const doc = this.docs.get(id);\n\n          if (callbacks.movedBefore) {\n            callbacks.movedBefore.call(this, id, before);\n          }\n\n          this.docs.moveBefore(id, before || null);\n        },\n      };\n    } else {\n      this.docs = new LocalCollection._IdMap;\n      this.applyChange = {\n        added: (id, fields) => {\n          // Take a shallow copy since the top-level properties can be changed\n          const doc = { ...fields };\n\n          if (callbacks.added) {\n            callbacks.added.call(this, id, EJSON.clone(fields));\n          }\n\n          doc._id = id;\n\n          this.docs.set(id,  doc);\n        },\n      };\n    }\n\n    // The methods in _IdMap and OrderedDict used by these callbacks are\n    // identical.\n    this.applyChange.changed = (id, fields) => {\n      const doc = this.docs.get(id);\n\n      if (!doc) {\n        throw new Error(`Unknown id for changed: ${id}`);\n      }\n\n      if (callbacks.changed) {\n        callbacks.changed.call(this, id, EJSON.clone(fields));\n      }\n\n      DiffSequence.applyChanges(doc, fields);\n    };\n\n    this.applyChange.removed = id => {\n      if (callbacks.removed) {\n        callbacks.removed.call(this, id);\n      }\n\n      this.docs.remove(id);\n    };\n  }\n};\n\nLocalCollection._IdMap = class _IdMap extends IdMap {\n  constructor() {\n    super(MongoID.idStringify, MongoID.idParse);\n  }\n};\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = transform => {\n  if (!transform) {\n    return null;\n  }\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__) {\n    return transform;\n  }\n\n  const wrapped = doc => {\n    if (!hasOwn.call(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error('can only transform documents with _id');\n    }\n\n    const id = doc._id;\n\n    // XXX consider making tracker a weak dependency and checking\n    // Package.tracker here\n    const transformed = Tracker.nonreactive(() => transform(doc));\n\n    if (!LocalCollection._isPlainObject(transformed)) {\n      throw new Error('transform must return object');\n    }\n\n    if (hasOwn.call(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error('transformed document can\\'t have different _id');\n      }\n    } else {\n      transformed._id = id;\n    }\n\n    return transformed;\n  };\n\n  wrapped.__wrappedTransform__ = true;\n\n  return wrapped;\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = (cmp, array, value) => {\n  let first = 0;\n  let range = array.length;\n\n  while (range > 0) {\n    const halfRange = Math.floor(range / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      range -= halfRange + 1;\n    } else {\n      range = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._checkSupportedProjection = fields => {\n  if (fields !== Object(fields) || Array.isArray(fields)) {\n    throw MinimongoError('fields option must be an object');\n  }\n\n  Object.keys(fields).forEach(keyPath => {\n    if (keyPath.split('.').includes('$')) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support $ operator in projections yet.'\n      );\n    }\n\n    const value = fields[keyPath];\n\n    if (typeof value === 'object' &&\n        ['$elemMatch', '$meta', '$slice'].some(key =>\n          hasOwn.call(value, key)\n        )) {\n      throw MinimongoError(\n        'Minimongo doesn\\'t support operators in projections yet.'\n      );\n    }\n\n    if (![1, 0, true, false].includes(value)) {\n      throw MinimongoError(\n        'Projection values should be one of 1, 0, true, or false'\n      );\n    }\n  });\n};\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = fields => {\n  LocalCollection._checkSupportedProjection(fields);\n\n  const _idProjection = fields._id === undefined ? true : fields._id;\n  const details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  const transform = (doc, ruleTree) => {\n    // Special case for \"sets\"\n    if (Array.isArray(doc)) {\n      return doc.map(subdoc => transform(subdoc, ruleTree));\n    }\n\n    const result = details.including ? {} : EJSON.clone(doc);\n\n    Object.keys(ruleTree).forEach(key => {\n      if (doc == null || !hasOwn.call(doc, key)) {\n        return;\n      }\n\n      const rule = ruleTree[key];\n\n      if (rule === Object(rule)) {\n        // For sub-objects/subsets we branch\n        if (doc[key] === Object(doc[key])) {\n          result[key] = transform(doc[key], rule);\n        }\n      } else if (details.including) {\n        // Otherwise we don't even touch this subfield\n        result[key] = EJSON.clone(doc[key]);\n      } else {\n        delete result[key];\n      }\n    });\n\n    return doc != null ? result : doc;\n  };\n\n  return doc => {\n    const result = transform(doc, details.tree);\n\n    if (_idProjection && hasOwn.call(doc, '_id')) {\n      result._id = doc._id;\n    }\n\n    if (!_idProjection && hasOwn.call(result, '_id')) {\n      delete result._id;\n    }\n\n    return result;\n  };\n};\n\n// Calculates the document to insert in case we're doing an upsert and the\n// selector does not match any elements\nLocalCollection._createUpsertDocument = (selector, modifier) => {\n  const selectorDocument = populateDocumentWithQueryFields(selector);\n  const isModify = LocalCollection._isModificationMod(modifier);\n\n  const newDoc = {};\n\n  if (selectorDocument._id) {\n    newDoc._id = selectorDocument._id;\n    delete selectorDocument._id;\n  }\n\n  // This double _modify call is made to help with nested properties (see issue\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\n  // ambiguous id's)\n  LocalCollection._modify(newDoc, {$set: selectorDocument});\n  LocalCollection._modify(newDoc, modifier, {isInsert: true});\n\n  if (isModify) {\n    return newDoc;\n  }\n\n  // Replacement can take _id from query document\n  const replacement = Object.assign({}, modifier);\n  if (newDoc._id) {\n    replacement._id = newDoc._id;\n  }\n\n  return replacement;\n};\n\nLocalCollection._diffObjects = (left, right, callbacks) => {\n  return DiffSequence.diffObjects(left, right, callbacks);\n};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) =>\n  DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options)\n;\n\nLocalCollection._findInOrderedResults = (query, doc) => {\n  if (!query.ordered) {\n    throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n  }\n\n  for (let i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) {\n      return i;\n    }\n  }\n\n  throw Error('object missing from query');\n};\n\n// If this is a selector which explicitly constrains the match by ID to a finite\n// number of documents, returns a list of their IDs.  Otherwise returns\n// null. Note that the selector may have other restrictions so it may not even\n// match those document!  We care about $in and $and since those are generated\n// access-controlled update and remove.\nLocalCollection._idsMatchedBySelector = selector => {\n  // Is the selector just an ID?\n  if (LocalCollection._selectorIsId(selector)) {\n    return [selector];\n  }\n\n  if (!selector) {\n    return null;\n  }\n\n  // Do we have an _id clause?\n  if (hasOwn.call(selector, '_id')) {\n    // Is the _id clause just an ID?\n    if (LocalCollection._selectorIsId(selector._id)) {\n      return [selector._id];\n    }\n\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n    if (selector._id\n        && Array.isArray(selector._id.$in)\n        && selector._id.$in.length\n        && selector._id.$in.every(LocalCollection._selectorIsId)) {\n      return selector._id.$in;\n    }\n\n    return null;\n  }\n\n  // If this is a top-level $and, and any of the clauses constrain their\n  // documents, then the whole selector is constrained by any one clause's\n  // constraint. (Well, by their intersection, but that seems unlikely.)\n  if (Array.isArray(selector.$and)) {\n    for (let i = 0; i < selector.$and.length; ++i) {\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n\n      if (subIds) {\n        return subIds;\n      }\n    }\n  }\n\n  return null;\n};\n\nLocalCollection._insertInResults = (query, doc) => {\n  const fields = EJSON.clone(doc);\n\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      const i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results,\n        doc\n      );\n\n      let next = query.results[i + 1];\n      if (next) {\n        next = next._id;\n      } else {\n        next = null;\n      }\n\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._insertInSortedList = (cmp, array, value) => {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  const i = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(i, 0, value);\n\n  return i;\n};\n\nLocalCollection._isModificationMod = mod => {\n  let isModify = false;\n  let isReplace = false;\n\n  Object.keys(mod).forEach(key => {\n    if (key.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  });\n\n  if (isModify && isReplace) {\n    throw new Error(\n      'Update parameter cannot have both modifier and non-modifier fields.'\n    );\n  }\n\n  return isModify;\n};\n\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n// RegExp\n// XXX note that _type(undefined) === 3!!!!\nLocalCollection._isPlainObject = x => {\n  return x && LocalCollection._f._type(x) === 3;\n};\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = (doc, modifier, options = {}) => {\n  if (!LocalCollection._isPlainObject(modifier)) {\n    throw MinimongoError('Modifier must be an object');\n  }\n\n  // Make sure the caller can't mutate our data structures.\n  modifier = EJSON.clone(modifier);\n\n  const isModifier = isOperatorObject(modifier);\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\n\n  if (isModifier) {\n    // apply modifiers to the doc.\n    Object.keys(modifier).forEach(operator => {\n      // Treat $setOnInsert as $set if this is an insert.\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n      const operand = modifier[operator];\n\n      if (!modFunc) {\n        throw MinimongoError(`Invalid modifier specified ${operator}`);\n      }\n\n      Object.keys(operand).forEach(keypath => {\n        const arg = operand[keypath];\n\n        if (keypath === '') {\n          throw MinimongoError('An empty update path is not valid.');\n        }\n\n        const keyparts = keypath.split('.');\n\n        if (!keyparts.every(Boolean)) {\n          throw MinimongoError(\n            `The update path '${keypath}' contains an empty field name, ` +\n            'which is not allowed.'\n          );\n        }\n\n        const target = findModTarget(newDoc, keyparts, {\n          arrayIndices: options.arrayIndices,\n          forbidArray: operator === '$rename',\n          noCreate: NO_CREATE_MODIFIERS[operator]\n        });\n\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n      });\n    });\n\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n      throw MinimongoError(\n        `After applying the update to the document {_id: \"${doc._id}\", ...},` +\n        ' the (immutable) field \\'_id\\' was found to have been altered to ' +\n        `_id: \"${newDoc._id}\"`\n      );\n    }\n  } else {\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n      throw MinimongoError(\n        `The _id field cannot be changed from {_id: \"${doc._id}\"} to ` +\n        `{_id: \"${modifier._id}\"}`\n      );\n    }\n\n    // replace the whole document\n    assertHasValidFieldNames(modifier);\n  }\n\n  // move new document into place.\n  Object.keys(doc).forEach(key => {\n    // Note: this used to be for (var key in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (key !== '_id') {\n      delete doc[key];\n    }\n  });\n\n  Object.keys(newDoc).forEach(key => {\n    doc[key] = newDoc[key];\n  });\n};\n\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\n  const transform = cursor.getTransform() || (doc => doc);\n  let suppressed = !!observeCallbacks._suppress_initial;\n\n  let observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    const indices = !observeCallbacks._no_indices;\n\n    observeChangesCallbacks = {\n      addedBefore(id, fields, before) {\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\n          return;\n        }\n\n        const doc = transform(Object.assign(fields, {_id: id}));\n\n        if (observeCallbacks.addedAt) {\n          observeCallbacks.addedAt(\n            doc,\n            indices\n              ? before\n                ? this.docs.indexOf(before)\n                : this.docs.size()\n              : -1,\n            before\n          );\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed(id, fields) {\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n          return;\n        }\n\n        let doc = EJSON.clone(this.docs.get(id));\n        if (!doc) {\n          throw new Error(`Unknown id for changed: ${id}`);\n        }\n\n        const oldDoc = transform(EJSON.clone(doc));\n\n        DiffSequence.applyChanges(doc, fields);\n\n        if (observeCallbacks.changedAt) {\n          observeCallbacks.changedAt(\n            transform(doc),\n            oldDoc,\n            indices ? this.docs.indexOf(id) : -1\n          );\n        } else {\n          observeCallbacks.changed(transform(doc), oldDoc);\n        }\n      },\n      movedBefore(id, before) {\n        if (!observeCallbacks.movedTo) {\n          return;\n        }\n\n        const from = indices ? this.docs.indexOf(id) : -1;\n        let to = indices\n          ? before\n            ? this.docs.indexOf(before)\n            : this.docs.size()\n          : -1;\n\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from) {\n          --to;\n        }\n\n        observeCallbacks.movedTo(\n          transform(EJSON.clone(this.docs.get(id))),\n          from,\n          to,\n          before || null\n        );\n      },\n      removed(id) {\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n          return;\n        }\n\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from this.docs!\n        const doc = transform(this.docs.get(id));\n\n        if (observeCallbacks.removedAt) {\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      },\n    };\n  } else {\n    observeChangesCallbacks = {\n      added(id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          observeCallbacks.added(transform(Object.assign(fields, {_id: id})));\n        }\n      },\n      changed(id, fields) {\n        if (observeCallbacks.changed) {\n          const oldDoc = this.docs.get(id);\n          const doc = EJSON.clone(oldDoc);\n\n          DiffSequence.applyChanges(doc, fields);\n\n          observeCallbacks.changed(\n            transform(doc),\n            transform(EJSON.clone(oldDoc))\n          );\n        }\n      },\n      removed(id) {\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(this.docs.get(id)));\n        }\n      },\n    };\n  }\n\n  const changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n\n  // CachingChangeObserver clones all received input on its callbacks\n  // So we can mark it as safe to reduce the ejson clones.\n  // This is tested by the `mongo-livedata - (extended) scribbling` tests\n  changeObserver.applyChange._fromObserve = true;\n  const handle = cursor.observeChanges(changeObserver.applyChange,\n    { nonMutatingCallbacks: true });\n\n  suppressed = false;\n\n  return handle;\n};\n\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedAt) {\n    throw new Error('Please specify only one of added() and addedAt()');\n  }\n\n  if (callbacks.changed && callbacks.changedAt) {\n    throw new Error('Please specify only one of changed() and changedAt()');\n  }\n\n  if (callbacks.removed && callbacks.removedAt) {\n    throw new Error('Please specify only one of removed() and removedAt()');\n  }\n\n  return !!(\n    callbacks.addedAt ||\n    callbacks.changedAt ||\n    callbacks.movedTo ||\n    callbacks.removedAt\n  );\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\n  if (callbacks.added && callbacks.addedBefore) {\n    throw new Error('Please specify only one of added() and addedBefore()');\n  }\n\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._removeFromResults = (query, doc) => {\n  if (query.ordered) {\n    const i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    const id = doc._id;  // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\n// Is this selector just shorthand for lookup by _id?\nLocalCollection._selectorIsId = selector =>\n  typeof selector === 'number' ||\n  typeof selector === 'string' ||\n  selector instanceof MongoID.ObjectID\n;\n\n// Is the selector just lookup by _id (shorthand or not)?\nLocalCollection._selectorIsIdPerhapsAsObject = selector =>\n  LocalCollection._selectorIsId(selector) ||\n  LocalCollection._selectorIsId(selector && selector._id) &&\n  Object.keys(selector).length === 1\n;\n\nLocalCollection._updateInResults = (query, doc, old_doc) => {\n  if (!EJSON.equals(doc._id, old_doc._id)) {\n    throw new Error('Can\\'t change a doc\\'s _id while updating');\n  }\n\n  const projectionFn = query.projectionFn;\n  const changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc),\n    projectionFn(old_doc)\n  );\n\n  if (!query.ordered) {\n    if (Object.keys(changedFields).length) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (Object.keys(changedFields).length) {\n    query.changed(doc._id, changedFields);\n  }\n\n  if (!query.sorter) {\n    return;\n  }\n\n  // just take it out and put it back in again, and see if the index changes\n  query.results.splice(old_idx, 1);\n\n  const new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results,\n    doc\n  );\n\n  if (old_idx !== new_idx) {\n    let next = query.results[new_idx + 1];\n    if (next) {\n      next = next._id;\n    } else {\n      next = null;\n    }\n\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\nconst MODIFIERS = {\n  $currentDate(target, field, arg) {\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\n      if (arg.$type !== 'date') {\n        throw MinimongoError(\n          'Minimongo does currently only support the date type in ' +\n          '$currentDate modifiers',\n          {field}\n        );\n      }\n    } else if (arg !== true) {\n      throw MinimongoError('Invalid $currentDate modifier', {field});\n    }\n\n    target[field] = new Date();\n  },\n  $inc(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $inc allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $inc modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $min(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $min allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $min modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $max allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $max modifier to non-number',\n          {field}\n        );\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $mul(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw MinimongoError('Modifier $mul allowed for numbers only', {field});\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw MinimongoError(\n          'Cannot apply $mul modifier to non-number',\n          {field}\n        );\n      }\n\n      target[field] *= arg;\n    } else {\n      target[field] = 0;\n    }\n  },\n  $rename(target, field, arg, keypath, doc) {\n    // no idea why mongo has this restriction..\n    if (keypath === arg) {\n      throw MinimongoError('$rename source must differ from target', {field});\n    }\n\n    if (target === null) {\n      throw MinimongoError('$rename source field invalid', {field});\n    }\n\n    if (typeof arg !== 'string') {\n      throw MinimongoError('$rename target must be a string', {field});\n    }\n\n    if (arg.includes('\\0')) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\n        'The \\'to\\' field for $rename cannot contain an embedded null byte',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const object = target[field];\n\n    delete target[field];\n\n    const keyparts = arg.split('.');\n    const target2 = findModTarget(doc, keyparts, {forbidArray: true});\n\n    if (target2 === null) {\n      throw MinimongoError('$rename target field invalid', {field});\n    }\n\n    target2[keyparts.pop()] = object;\n  },\n  $set(target, field, arg) {\n    if (target !== Object(target)) { // not an array or an object\n      const error = MinimongoError(\n        'Cannot set property on non-object field',\n        {field}\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (target === null) {\n      const error = MinimongoError('Cannot set property on null', {field});\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    assertHasValidFieldNames(arg);\n\n    target[field] = arg;\n  },\n  $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n\n    if (!(target[field] instanceof Array)) {\n      throw MinimongoError('Cannot apply $push modifier to non-array', {field});\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n\n      target[field].push(arg);\n\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    const toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw MinimongoError('$each must be an array', {field});\n    }\n\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    let position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw MinimongoError('$position must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw MinimongoError(\n          '$position in $push must be zero or positive',\n          {field}\n        );\n      }\n\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    let slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw MinimongoError('$slice must be a numeric value', {field});\n      }\n\n      // XXX should check to make sure integer\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    let sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw MinimongoError('$sort requires $slice to be present', {field});\n      }\n\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n\n      toPush.forEach(element => {\n        if (LocalCollection._f._type(element) !== 3) {\n          throw MinimongoError(\n            '$push like modifiers using $sort require all elements to be ' +\n            'objects',\n            {field}\n          );\n        }\n      });\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      toPush.forEach(element => {\n        target[field].push(element);\n      });\n    } else {\n      const spliceArguments = [position, 0];\n\n      toPush.forEach(element => {\n        spliceArguments.push(element);\n      });\n\n      target[field].splice(...spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else if (slice < 0) {\n        target[field] = target[field].slice(slice);\n      } else {\n        target[field] = target[field].slice(0, slice);\n      }\n    }\n  },\n  $pushAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n\n    assertHasValidFieldNames(arg);\n\n    const toPush = target[field];\n\n    if (toPush === undefined) {\n      target[field] = arg;\n    } else if (!(toPush instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pushAll modifier to non-array',\n        {field}\n      );\n    } else {\n      toPush.push(...arg);\n    }\n  },\n  $addToSet(target, field, arg) {\n    let isEach = false;\n\n    if (typeof arg === 'object') {\n      // check if first key is '$each'\n      const keys = Object.keys(arg);\n      if (keys[0] === '$each') {\n        isEach = true;\n      }\n    }\n\n    const values = isEach ? arg.$each : [arg];\n\n    assertHasValidFieldNames(values);\n\n    const toAdd = target[field];\n    if (toAdd === undefined) {\n      target[field] = values;\n    } else if (!(toAdd instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $addToSet modifier to non-array',\n        {field}\n      );\n    } else {\n      values.forEach(value => {\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\n          return;\n        }\n\n        toAdd.push(value);\n      });\n    }\n  },\n  $pop(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPop = target[field];\n\n    if (toPop === undefined) {\n      return;\n    }\n\n    if (!(toPop instanceof Array)) {\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {field});\n    }\n\n    if (typeof arg === 'number' && arg < 0) {\n      toPop.splice(0, 1);\n    } else {\n      toPop.pop();\n    }\n  },\n  $pull(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    let out;\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n      // XXX would be much nicer to compile this once, rather than\n      // for each document we modify.. but usually we're not\n      // modifying that many documents, so we'll let it slide for\n      // now\n\n      // XXX Minimongo.Matcher isn't up for the job, because we need\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      // like {$gt: 4} is not normally a complete selector.\n      // same issue as $elemMatch possibly?\n      const matcher = new Minimongo.Matcher(arg);\n\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\n    } else {\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\n    }\n\n    target[field] = out;\n  },\n  $pullAll(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw MinimongoError(\n        'Modifier $pushAll/pullAll allowed for arrays only',\n        {field}\n      );\n    }\n\n    if (target === undefined) {\n      return;\n    }\n\n    const toPull = target[field];\n\n    if (toPull === undefined) {\n      return;\n    }\n\n    if (!(toPull instanceof Array)) {\n      throw MinimongoError(\n        'Cannot apply $pull/pullAll modifier to non-array',\n        {field}\n      );\n    }\n\n    target[field] = toPull.filter(object =>\n      !arg.some(element => LocalCollection._f._equal(object, element))\n    );\n  },\n  $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError('$bit is not supported', {field});\n  },\n  $v() {\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\n    // the `$v` operator is not needed by Meteor, but problems can occur if\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n    // a no-op to work around these problems.\n  }\n};\n\nconst NO_CREATE_MODIFIERS = {\n  $pop: true,\n  $pull: true,\n  $pullAll: true,\n  $rename: true,\n  $unset: true\n};\n\n// Make sure field names do not contain Mongo restricted\n// characters ('.', '$', '\\0').\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\nconst invalidCharMsg = {\n  $: 'start with \\'$\\'',\n  '.': 'contain \\'.\\'',\n  '\\0': 'contain null bytes'\n};\n\n// checks if all field names in an object are valid\nfunction assertHasValidFieldNames(doc) {\n  if (doc && typeof doc === 'object') {\n    JSON.stringify(doc, (key, value) => {\n      assertIsValidFieldName(key);\n      return value;\n    });\n  }\n}\n\nfunction assertIsValidFieldName(key) {\n  let match;\n  if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n    throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\n  }\n}\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nfunction findModTarget(doc, keyparts, options = {}) {\n  let usedArrayIndex = false;\n\n  for (let i = 0; i < keyparts.length; i++) {\n    const last = i === keyparts.length - 1;\n    let keypart = keyparts[i];\n\n    if (!isIndexable(doc)) {\n      if (options.noCreate) {\n        return undefined;\n      }\n\n      const error = MinimongoError(\n        `cannot use the part '${keypart}' to traverse ${doc}`\n      );\n      error.setPropertyError = true;\n      throw error;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n        }\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\n            'The positional operator did not find the match needed from the ' +\n            'query'\n          );\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        throw MinimongoError(\n          `can't append to array using string field name [${keypart}]`\n        );\n      }\n\n      if (last) {\n        keyparts[i] = keypart; // handle 'a.01'\n      }\n\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (typeof doc[keypart] !== 'object') {\n          throw MinimongoError(\n            `can't modify field '${keyparts[i + 1]}' of list value ` +\n            JSON.stringify(doc[keypart])\n          );\n        }\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n\n    doc = doc[keypart];\n  }\n\n  // notreached\n}\n"],"mappings":"AAAA,IAAIA,aAAa;AAACC,MAAM,CAACC,IAAI,CAAC,sCAAsC,EAAC;EAACC,OAAOA,CAACC,CAAC,EAAC;IAACJ,aAAa,GAACI,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAArGH,MAAM,CAACI,MAAM,CAAC;EAACF,OAAO,EAACA,CAAA,KAAIG;AAAe,CAAC,CAAC;AAAC,IAAIC,MAAM;AAACN,MAAM,CAACC,IAAI,CAAC,aAAa,EAAC;EAACC,OAAOA,CAACC,CAAC,EAAC;IAACG,MAAM,GAACH,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAII,aAAa;AAACP,MAAM,CAACC,IAAI,CAAC,qBAAqB,EAAC;EAACC,OAAOA,CAACC,CAAC,EAAC;IAACI,aAAa,GAACJ,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAAC,IAAIK,MAAM,EAACC,WAAW,EAACC,YAAY,EAACC,gBAAgB,EAACC,+BAA+B,EAACC,iBAAiB;AAACb,MAAM,CAACC,IAAI,CAAC,aAAa,EAAC;EAACO,MAAMA,CAACL,CAAC,EAAC;IAACK,MAAM,GAACL,CAAC;EAAA,CAAC;EAACM,WAAWA,CAACN,CAAC,EAAC;IAACM,WAAW,GAACN,CAAC;EAAA,CAAC;EAACO,YAAYA,CAACP,CAAC,EAAC;IAACO,YAAY,GAACP,CAAC;EAAA,CAAC;EAACQ,gBAAgBA,CAACR,CAAC,EAAC;IAACQ,gBAAgB,GAACR,CAAC;EAAA,CAAC;EAACS,+BAA+BA,CAACT,CAAC,EAAC;IAACS,+BAA+B,GAACT,CAAC;EAAA,CAAC;EAACU,iBAAiBA,CAACV,CAAC,EAAC;IAACU,iBAAiB,GAACV,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAcjiB,MAAME,eAAe,CAAC;EACnCS,WAAWA,CAACC,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB;IACA,IAAI,CAACC,KAAK,GAAG,IAAIX,eAAe,CAACY,MAAM,CAAD,CAAC;IAEvC,IAAI,CAACC,aAAa,GAAG,IAAIC,MAAM,CAACC,iBAAiB,CAAC,CAAC;IAEnD,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,CAAC;;IAEnB;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;;IAElC;IACA;IACA,IAAI,CAACC,eAAe,GAAG,IAAI;;IAE3B;IACA,IAAI,CAACC,MAAM,GAAG,KAAK;EACrB;EAEAC,cAAcA,CAACC,QAAQ,EAAEC,OAAO,EAAE;IAChC,OAAO,IAAI,CAACC,IAAI,CAACF,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAI,CAAC,CAAC,EAAEC,OAAO,CAAC,CAACE,UAAU,CAAC,CAAC;EACxD;EAEAC,sBAAsBA,CAACH,OAAO,EAAE;IAC9B,OAAO,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,EAAED,OAAO,CAAC,CAACE,UAAU,CAAC,CAAC;EAC5C;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAD,IAAIA,CAACF,QAAQ,EAAEC,OAAO,EAAE;IACtB;IACA;IACA;IACA,IAAII,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC1BN,QAAQ,GAAG,CAAC,CAAC;IACf;IAEA,OAAO,IAAIvB,eAAe,CAACC,MAAM,CAAC,IAAI,EAAEsB,QAAQ,EAAEC,OAAO,CAAC;EAC5D;EAEAM,OAAOA,CAACP,QAAQ,EAAgB;IAAA,IAAdC,OAAO,GAAAI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAG,SAAA,GAAAH,SAAA,MAAG,CAAC,CAAC;IAC5B,IAAIA,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC1BN,QAAQ,GAAG,CAAC,CAAC;IACf;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAC,OAAO,CAACQ,KAAK,GAAG,CAAC;IAEjB,OAAO,IAAI,CAACP,IAAI,CAACF,QAAQ,EAAEC,OAAO,CAAC,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EAChD;;EAEA;EACA;EACAC,MAAMA,CAACC,GAAG,EAAEC,QAAQ,EAAE;IACpBD,GAAG,GAAGE,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC;IAEtBI,wBAAwB,CAACJ,GAAG,CAAC;;IAE7B;IACA;IACA,IAAI,CAAChC,MAAM,CAACqC,IAAI,CAACL,GAAG,EAAE,KAAK,CAAC,EAAE;MAC5BA,GAAG,CAACM,GAAG,GAAGzC,eAAe,CAAC0C,OAAO,GAAG,IAAIC,OAAO,CAACC,QAAQ,CAAC,CAAC,GAAGC,MAAM,CAACC,EAAE,CAAC,CAAC;IAC1E;IAEA,MAAMA,EAAE,GAAGX,GAAG,CAACM,GAAG;IAElB,IAAI,IAAI,CAAC9B,KAAK,CAACoC,GAAG,CAACD,EAAE,CAAC,EAAE;MACtB,MAAME,cAAc,mBAAAC,MAAA,CAAmBH,EAAE,MAAG,CAAC;IAC/C;IAEA,IAAI,CAACI,aAAa,CAACJ,EAAE,EAAEf,SAAS,CAAC;IACjC,IAAI,CAACpB,KAAK,CAACwC,GAAG,CAACL,EAAE,EAAEX,GAAG,CAAC;IAEvB,MAAMiB,kBAAkB,GAAG,EAAE;;IAE7B;IACAlC,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;MACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAIC,KAAK,CAACC,KAAK,EAAE;QACf;MACF;MAEA,MAAMC,WAAW,GAAGF,KAAK,CAACG,OAAO,CAACC,eAAe,CAACzB,GAAG,CAAC;MAEtD,IAAIuB,WAAW,CAACG,MAAM,EAAE;QACtB,IAAIL,KAAK,CAACM,SAAS,IAAIJ,WAAW,CAACK,QAAQ,KAAKhC,SAAS,EAAE;UACzDyB,KAAK,CAACM,SAAS,CAACX,GAAG,CAACL,EAAE,EAAEY,WAAW,CAACK,QAAQ,CAAC;QAC/C;QAEA,IAAIP,KAAK,CAACQ,MAAM,CAACC,IAAI,IAAIT,KAAK,CAACQ,MAAM,CAAChC,KAAK,EAAE;UAC3CoB,kBAAkB,CAACc,IAAI,CAACX,GAAG,CAAC;QAC9B,CAAC,MAAM;UACLvD,eAAe,CAACmE,gBAAgB,CAACX,KAAK,EAAErB,GAAG,CAAC;QAC9C;MACF;IACF,CAAC,CAAC;IAEFiB,kBAAkB,CAACE,OAAO,CAACC,GAAG,IAAI;MAChC,IAAI,IAAI,CAACtC,OAAO,CAACsC,GAAG,CAAC,EAAE;QACrB,IAAI,CAACa,iBAAiB,CAAC,IAAI,CAACnD,OAAO,CAACsC,GAAG,CAAC,CAAC;MAC3C;IACF,CAAC,CAAC;IAEF,IAAI,CAAC1C,aAAa,CAACwD,KAAK,CAAC,CAAC;;IAE1B;IACA;IACA,IAAIjC,QAAQ,EAAE;MACZtB,MAAM,CAACwD,KAAK,CAAC,MAAM;QACjBlC,QAAQ,CAAC,IAAI,EAAEU,EAAE,CAAC;MACpB,CAAC,CAAC;IACJ;IAEA,OAAOA,EAAE;EACX;;EAEA;EACA;EACAyB,cAAcA,CAAA,EAAG;IACf;IACA,IAAI,IAAI,CAAClD,MAAM,EAAE;MACf;IACF;;IAEA;IACA,IAAI,CAACA,MAAM,GAAG,IAAI;;IAElB;IACAH,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;MACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAC/BC,KAAK,CAACgB,eAAe,GAAGnC,KAAK,CAACC,KAAK,CAACkB,KAAK,CAACiB,OAAO,CAAC;IACpD,CAAC,CAAC;EACJ;EAEAC,MAAMA,CAACnD,QAAQ,EAAEa,QAAQ,EAAE;IACzB;IACA;IACA;IACA,IAAI,IAAI,CAACf,MAAM,IAAI,CAAC,IAAI,CAACD,eAAe,IAAIiB,KAAK,CAACsC,MAAM,CAACpD,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;MACtE,MAAMsC,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACiE,IAAI,CAAC,CAAC;MAEhC,IAAI,CAACjE,KAAK,CAACkE,KAAK,CAAC,CAAC;MAElB3D,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;QACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;QAE/B,IAAIC,KAAK,CAACsB,OAAO,EAAE;UACjBtB,KAAK,CAACiB,OAAO,GAAG,EAAE;QACpB,CAAC,MAAM;UACLjB,KAAK,CAACiB,OAAO,CAACI,KAAK,CAAC,CAAC;QACvB;MACF,CAAC,CAAC;MAEF,IAAIzC,QAAQ,EAAE;QACZtB,MAAM,CAACwD,KAAK,CAAC,MAAM;UACjBlC,QAAQ,CAAC,IAAI,EAAEyB,MAAM,CAAC;QACxB,CAAC,CAAC;MACJ;MAEA,OAAOA,MAAM;IACf;IAEA,MAAMF,OAAO,GAAG,IAAIoB,SAAS,CAACC,OAAO,CAACzD,QAAQ,CAAC;IAC/C,MAAMmD,MAAM,GAAG,EAAE;IAEjB,IAAI,CAACO,wBAAwB,CAAC1D,QAAQ,EAAE,CAACY,GAAG,EAAEW,EAAE,KAAK;MACnD,IAAIa,OAAO,CAACC,eAAe,CAACzB,GAAG,CAAC,CAAC0B,MAAM,EAAE;QACvCa,MAAM,CAACR,IAAI,CAACpB,EAAE,CAAC;MACjB;IACF,CAAC,CAAC;IAEF,MAAMM,kBAAkB,GAAG,EAAE;IAC7B,MAAM8B,WAAW,GAAG,EAAE;IAEtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAAC7C,MAAM,EAAEsD,CAAC,EAAE,EAAE;MACtC,MAAMC,QAAQ,GAAGV,MAAM,CAACS,CAAC,CAAC;MAC1B,MAAME,SAAS,GAAG,IAAI,CAAC1E,KAAK,CAAC2E,GAAG,CAACF,QAAQ,CAAC;MAE1ClE,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;QACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;QAE/B,IAAIC,KAAK,CAACC,KAAK,EAAE;UACf;QACF;QAEA,IAAID,KAAK,CAACG,OAAO,CAACC,eAAe,CAACyB,SAAS,CAAC,CAACxB,MAAM,EAAE;UACnD,IAAIL,KAAK,CAACQ,MAAM,CAACC,IAAI,IAAIT,KAAK,CAACQ,MAAM,CAAChC,KAAK,EAAE;YAC3CoB,kBAAkB,CAACc,IAAI,CAACX,GAAG,CAAC;UAC9B,CAAC,MAAM;YACL2B,WAAW,CAAChB,IAAI,CAAC;cAACX,GAAG;cAAEpB,GAAG,EAAEkD;YAAS,CAAC,CAAC;UACzC;QACF;MACF,CAAC,CAAC;MAEF,IAAI,CAACnC,aAAa,CAACkC,QAAQ,EAAEC,SAAS,CAAC;MACvC,IAAI,CAAC1E,KAAK,CAAC+D,MAAM,CAACU,QAAQ,CAAC;IAC7B;;IAEA;IACAF,WAAW,CAAC5B,OAAO,CAACoB,MAAM,IAAI;MAC5B,MAAMlB,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACyD,MAAM,CAACnB,GAAG,CAAC;MAEtC,IAAIC,KAAK,EAAE;QACTA,KAAK,CAACM,SAAS,IAAIN,KAAK,CAACM,SAAS,CAACY,MAAM,CAACA,MAAM,CAACvC,GAAG,CAACM,GAAG,CAAC;QACzDzC,eAAe,CAACuF,kBAAkB,CAAC/B,KAAK,EAAEkB,MAAM,CAACvC,GAAG,CAAC;MACvD;IACF,CAAC,CAAC;IAEFiB,kBAAkB,CAACE,OAAO,CAACC,GAAG,IAAI;MAChC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAIC,KAAK,EAAE;QACT,IAAI,CAACY,iBAAiB,CAACZ,KAAK,CAAC;MAC/B;IACF,CAAC,CAAC;IAEF,IAAI,CAAC3C,aAAa,CAACwD,KAAK,CAAC,CAAC;IAE1B,MAAMR,MAAM,GAAGa,MAAM,CAAC7C,MAAM;IAE5B,IAAIO,QAAQ,EAAE;MACZtB,MAAM,CAACwD,KAAK,CAAC,MAAM;QACjBlC,QAAQ,CAAC,IAAI,EAAEyB,MAAM,CAAC;MACxB,CAAC,CAAC;IACJ;IAEA,OAAOA,MAAM;EACf;;EAEA;EACA;EACA;EACA;EACA2B,eAAeA,CAAA,EAAG;IAChB;IACA,IAAI,CAAC,IAAI,CAACnE,MAAM,EAAE;MAChB;IACF;;IAEA;IACA;IACA,IAAI,CAACA,MAAM,GAAG,KAAK;IAEnBH,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;MACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAIC,KAAK,CAACC,KAAK,EAAE;QACfD,KAAK,CAACC,KAAK,GAAG,KAAK;;QAEnB;QACA;QACA,IAAI,CAACW,iBAAiB,CAACZ,KAAK,EAAEA,KAAK,CAACgB,eAAe,CAAC;MACtD,CAAC,MAAM;QACL;QACA;QACAxE,eAAe,CAACyF,iBAAiB,CAC/BjC,KAAK,CAACsB,OAAO,EACbtB,KAAK,CAACgB,eAAe,EACrBhB,KAAK,CAACiB,OAAO,EACbjB,KAAK,EACL;UAACkC,YAAY,EAAElC,KAAK,CAACkC;QAAY,CACnC,CAAC;MACH;MAEAlC,KAAK,CAACgB,eAAe,GAAG,IAAI;IAC9B,CAAC,CAAC;IAEF,IAAI,CAAC3D,aAAa,CAACwD,KAAK,CAAC,CAAC;EAC5B;EAEAsB,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAAC,IAAI,CAACvE,eAAe,EAAE;MACzB,MAAM,IAAIwE,KAAK,CAAC,gDAAgD,CAAC;IACnE;IAEA,MAAMC,SAAS,GAAG,IAAI,CAACzE,eAAe;IAEtC,IAAI,CAACA,eAAe,GAAG,IAAI;IAE3B,OAAOyE,SAAS;EAClB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,aAAaA,CAAA,EAAG;IACd,IAAI,IAAI,CAAC1E,eAAe,EAAE;MACxB,MAAM,IAAIwE,KAAK,CAAC,sDAAsD,CAAC;IACzE;IAEA,IAAI,CAACxE,eAAe,GAAG,IAAIpB,eAAe,CAACY,MAAM,CAAD,CAAC;EACnD;;EAEA;EACA;EACAmF,MAAMA,CAACxE,QAAQ,EAAEyE,GAAG,EAAExE,OAAO,EAAEY,QAAQ,EAAE;IACvC,IAAI,CAAEA,QAAQ,IAAIZ,OAAO,YAAYyE,QAAQ,EAAE;MAC7C7D,QAAQ,GAAGZ,OAAO;MAClBA,OAAO,GAAG,IAAI;IAChB;IAEA,IAAI,CAACA,OAAO,EAAE;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,MAAMmC,OAAO,GAAG,IAAIoB,SAAS,CAACC,OAAO,CAACzD,QAAQ,EAAE,IAAI,CAAC;;IAErD;IACA;IACA;IACA;IACA;IACA,MAAM2E,oBAAoB,GAAG,CAAC,CAAC;;IAE/B;IACA;IACA,MAAMC,MAAM,GAAG,IAAInG,eAAe,CAACY,MAAM,CAAD,CAAC;IACzC,MAAMwF,UAAU,GAAGpG,eAAe,CAACqG,qBAAqB,CAAC9E,QAAQ,CAAC;IAElEL,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;MACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAI,CAACC,KAAK,CAACQ,MAAM,CAACC,IAAI,IAAIT,KAAK,CAACQ,MAAM,CAAChC,KAAK,KAAK,CAAE,IAAI,CAACX,MAAM,EAAE;QAC9D;QACA;QACA;QACA;QACA;QACA,IAAImC,KAAK,CAACiB,OAAO,YAAYzE,eAAe,CAACY,MAAM,EAAE;UACnDsF,oBAAoB,CAAC3C,GAAG,CAAC,GAAGC,KAAK,CAACiB,OAAO,CAACnC,KAAK,CAAC,CAAC;UACjD;QACF;QAEA,IAAI,EAAEkB,KAAK,CAACiB,OAAO,YAAY6B,KAAK,CAAC,EAAE;UACrC,MAAM,IAAIV,KAAK,CAAC,8CAA8C,CAAC;QACjE;;QAEA;QACA;QACA;QACA;QACA,MAAMW,qBAAqB,GAAGpE,GAAG,IAAI;UACnC,IAAIgE,MAAM,CAACpD,GAAG,CAACZ,GAAG,CAACM,GAAG,CAAC,EAAE;YACvB,OAAO0D,MAAM,CAACb,GAAG,CAACnD,GAAG,CAACM,GAAG,CAAC;UAC5B;UAEA,MAAM+D,YAAY,GAChBJ,UAAU,IACV,CAACA,UAAU,CAACK,IAAI,CAAC3D,EAAE,IAAIT,KAAK,CAACsC,MAAM,CAAC7B,EAAE,EAAEX,GAAG,CAACM,GAAG,CAAC,CAAC,GAC/CN,GAAG,GAAGE,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC;UAE1BgE,MAAM,CAAChD,GAAG,CAAChB,GAAG,CAACM,GAAG,EAAE+D,YAAY,CAAC;UAEjC,OAAOA,YAAY;QACrB,CAAC;QAEDN,oBAAoB,CAAC3C,GAAG,CAAC,GAAGC,KAAK,CAACiB,OAAO,CAACiC,GAAG,CAACH,qBAAqB,CAAC;MACtE;IACF,CAAC,CAAC;IAEF,MAAMI,aAAa,GAAG,CAAC,CAAC;IAExB,IAAIC,WAAW,GAAG,CAAC;IAEnB,IAAI,CAAC3B,wBAAwB,CAAC1D,QAAQ,EAAE,CAACY,GAAG,EAAEW,EAAE,KAAK;MACnD,MAAM+D,WAAW,GAAGlD,OAAO,CAACC,eAAe,CAACzB,GAAG,CAAC;MAEhD,IAAI0E,WAAW,CAAChD,MAAM,EAAE;QACtB;QACA,IAAI,CAACX,aAAa,CAACJ,EAAE,EAAEX,GAAG,CAAC;QAC3B,IAAI,CAAC2E,gBAAgB,CACnB3E,GAAG,EACH6D,GAAG,EACHW,aAAa,EACbE,WAAW,CAACE,YACd,CAAC;QAED,EAAEH,WAAW;QAEb,IAAI,CAACpF,OAAO,CAACwF,KAAK,EAAE;UAClB,OAAO,KAAK,CAAC,CAAC;QAChB;MACF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC;IAEF9F,MAAM,CAACmC,IAAI,CAACsD,aAAa,CAAC,CAACrD,OAAO,CAACC,GAAG,IAAI;MACxC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAIC,KAAK,EAAE;QACT,IAAI,CAACY,iBAAiB,CAACZ,KAAK,EAAE0C,oBAAoB,CAAC3C,GAAG,CAAC,CAAC;MAC1D;IACF,CAAC,CAAC;IAEF,IAAI,CAAC1C,aAAa,CAACwD,KAAK,CAAC,CAAC;;IAE1B;IACA;IACA;IACA,IAAI4C,UAAU;IACd,IAAIL,WAAW,KAAK,CAAC,IAAIpF,OAAO,CAAC0F,MAAM,EAAE;MACvC,MAAM/E,GAAG,GAAGnC,eAAe,CAACmH,qBAAqB,CAAC5F,QAAQ,EAAEyE,GAAG,CAAC;MAChE,IAAI,CAAE7D,GAAG,CAACM,GAAG,IAAIjB,OAAO,CAACyF,UAAU,EAAE;QACnC9E,GAAG,CAACM,GAAG,GAAGjB,OAAO,CAACyF,UAAU;MAC9B;MAEAA,UAAU,GAAG,IAAI,CAAC/E,MAAM,CAACC,GAAG,CAAC;MAC7ByE,WAAW,GAAG,CAAC;IACjB;;IAEA;IACA;IACA;IACA,IAAI/C,MAAM;IACV,IAAIrC,OAAO,CAAC4F,aAAa,EAAE;MACzBvD,MAAM,GAAG;QAACwD,cAAc,EAAET;MAAW,CAAC;MAEtC,IAAIK,UAAU,KAAKlF,SAAS,EAAE;QAC5B8B,MAAM,CAACoD,UAAU,GAAGA,UAAU;MAChC;IACF,CAAC,MAAM;MACLpD,MAAM,GAAG+C,WAAW;IACtB;IAEA,IAAIxE,QAAQ,EAAE;MACZtB,MAAM,CAACwD,KAAK,CAAC,MAAM;QACjBlC,QAAQ,CAAC,IAAI,EAAEyB,MAAM,CAAC;MACxB,CAAC,CAAC;IACJ;IAEA,OAAOA,MAAM;EACf;;EAEA;EACA;EACA;EACAqD,MAAMA,CAAC3F,QAAQ,EAAEyE,GAAG,EAAExE,OAAO,EAAEY,QAAQ,EAAE;IACvC,IAAI,CAACA,QAAQ,IAAI,OAAOZ,OAAO,KAAK,UAAU,EAAE;MAC9CY,QAAQ,GAAGZ,OAAO;MAClBA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,OAAO,IAAI,CAACuE,MAAM,CAChBxE,QAAQ,EACRyE,GAAG,EACH9E,MAAM,CAACoG,MAAM,CAAC,CAAC,CAAC,EAAE9F,OAAO,EAAE;MAAC0F,MAAM,EAAE,IAAI;MAAEE,aAAa,EAAE;IAAI,CAAC,CAAC,EAC/DhF,QACF,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA6C,wBAAwBA,CAAC1D,QAAQ,EAAEgG,EAAE,EAAE;IACrC,MAAMC,WAAW,GAAGxH,eAAe,CAACqG,qBAAqB,CAAC9E,QAAQ,CAAC;IAEnE,IAAIiG,WAAW,EAAE;MACfA,WAAW,CAACf,IAAI,CAAC3D,EAAE,IAAI;QACrB,MAAMX,GAAG,GAAG,IAAI,CAACxB,KAAK,CAAC2E,GAAG,CAACxC,EAAE,CAAC;QAE9B,IAAIX,GAAG,EAAE;UACP,OAAOoF,EAAE,CAACpF,GAAG,EAAEW,EAAE,CAAC,KAAK,KAAK;QAC9B;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAI,CAACnC,KAAK,CAAC2C,OAAO,CAACiE,EAAE,CAAC;IACxB;EACF;EAEAT,gBAAgBA,CAAC3E,GAAG,EAAE6D,GAAG,EAAEW,aAAa,EAAEI,YAAY,EAAE;IACtD,MAAMU,cAAc,GAAG,CAAC,CAAC;IAEzBvG,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;MACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAIC,KAAK,CAACC,KAAK,EAAE;QACf;MACF;MAEA,IAAID,KAAK,CAACsB,OAAO,EAAE;QACjB2C,cAAc,CAAClE,GAAG,CAAC,GAAGC,KAAK,CAACG,OAAO,CAACC,eAAe,CAACzB,GAAG,CAAC,CAAC0B,MAAM;MACjE,CAAC,MAAM;QACL;QACA;QACA4D,cAAc,CAAClE,GAAG,CAAC,GAAGC,KAAK,CAACiB,OAAO,CAAC1B,GAAG,CAACZ,GAAG,CAACM,GAAG,CAAC;MAClD;IACF,CAAC,CAAC;IAEF,MAAMiF,OAAO,GAAGrF,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC;IAEhCnC,eAAe,CAAC2H,OAAO,CAACxF,GAAG,EAAE6D,GAAG,EAAE;MAACe;IAAY,CAAC,CAAC;IAEjD7F,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACpC,OAAO,CAAC,CAACqC,OAAO,CAACC,GAAG,IAAI;MACvC,MAAMC,KAAK,GAAG,IAAI,CAACvC,OAAO,CAACsC,GAAG,CAAC;MAE/B,IAAIC,KAAK,CAACC,KAAK,EAAE;QACf;MACF;MAEA,MAAMmE,UAAU,GAAGpE,KAAK,CAACG,OAAO,CAACC,eAAe,CAACzB,GAAG,CAAC;MACrD,MAAM0F,KAAK,GAAGD,UAAU,CAAC/D,MAAM;MAC/B,MAAMiE,MAAM,GAAGL,cAAc,CAAClE,GAAG,CAAC;MAElC,IAAIsE,KAAK,IAAIrE,KAAK,CAACM,SAAS,IAAI8D,UAAU,CAAC7D,QAAQ,KAAKhC,SAAS,EAAE;QACjEyB,KAAK,CAACM,SAAS,CAACX,GAAG,CAAChB,GAAG,CAACM,GAAG,EAAEmF,UAAU,CAAC7D,QAAQ,CAAC;MACnD;MAEA,IAAIP,KAAK,CAACQ,MAAM,CAACC,IAAI,IAAIT,KAAK,CAACQ,MAAM,CAAChC,KAAK,EAAE;QAC3C;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI8F,MAAM,IAAID,KAAK,EAAE;UACnBlB,aAAa,CAACpD,GAAG,CAAC,GAAG,IAAI;QAC3B;MACF,CAAC,MAAM,IAAIuE,MAAM,IAAI,CAACD,KAAK,EAAE;QAC3B7H,eAAe,CAACuF,kBAAkB,CAAC/B,KAAK,EAAErB,GAAG,CAAC;MAChD,CAAC,MAAM,IAAI,CAAC2F,MAAM,IAAID,KAAK,EAAE;QAC3B7H,eAAe,CAACmE,gBAAgB,CAACX,KAAK,EAAErB,GAAG,CAAC;MAC9C,CAAC,MAAM,IAAI2F,MAAM,IAAID,KAAK,EAAE;QAC1B7H,eAAe,CAAC+H,gBAAgB,CAACvE,KAAK,EAAErB,GAAG,EAAEuF,OAAO,CAAC;MACvD;IACF,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAtD,iBAAiBA,CAACZ,KAAK,EAAEwE,UAAU,EAAE;IACnC,IAAI,IAAI,CAAC3G,MAAM,EAAE;MACf;MACA;MACA;MACAmC,KAAK,CAACC,KAAK,GAAG,IAAI;MAClB;IACF;IAEA,IAAI,CAAC,IAAI,CAACpC,MAAM,IAAI,CAAC2G,UAAU,EAAE;MAC/BA,UAAU,GAAGxE,KAAK,CAACiB,OAAO;IAC5B;IAEA,IAAIjB,KAAK,CAACM,SAAS,EAAE;MACnBN,KAAK,CAACM,SAAS,CAACe,KAAK,CAAC,CAAC;IACzB;IAEArB,KAAK,CAACiB,OAAO,GAAGjB,KAAK,CAACQ,MAAM,CAACiE,cAAc,CAAC;MAC1CnE,SAAS,EAAEN,KAAK,CAACM,SAAS;MAC1BgB,OAAO,EAAEtB,KAAK,CAACsB;IACjB,CAAC,CAAC;IAEF,IAAI,CAAC,IAAI,CAACzD,MAAM,EAAE;MAChBrB,eAAe,CAACyF,iBAAiB,CAC/BjC,KAAK,CAACsB,OAAO,EACbkD,UAAU,EACVxE,KAAK,CAACiB,OAAO,EACbjB,KAAK,EACL;QAACkC,YAAY,EAAElC,KAAK,CAACkC;MAAY,CACnC,CAAC;IACH;EACF;EAEAxC,aAAaA,CAACJ,EAAE,EAAEX,GAAG,EAAE;IACrB;IACA,IAAI,CAAC,IAAI,CAACf,eAAe,EAAE;MACzB;IACF;;IAEA;IACA;IACA;IACA,IAAI,IAAI,CAACA,eAAe,CAAC2B,GAAG,CAACD,EAAE,CAAC,EAAE;MAChC;IACF;IAEA,IAAI,CAAC1B,eAAe,CAAC+B,GAAG,CAACL,EAAE,EAAET,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC,CAAC;EAChD;AACF;AAEAnC,eAAe,CAACC,MAAM,GAAGA,MAAM;AAE/BD,eAAe,CAACE,aAAa,GAAGA,aAAa;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,eAAe,CAACkI,sBAAsB,GAAG,MAAMA,sBAAsB,CAAC;EACpEzH,WAAWA,CAAA,EAAe;IAAA,IAAde,OAAO,GAAAI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAG,SAAA,GAAAH,SAAA,MAAG,CAAC,CAAC;IACtB,MAAMuG,oBAAoB,GACxB3G,OAAO,CAAC4G,SAAS,IACjBpI,eAAe,CAACqI,kCAAkC,CAAC7G,OAAO,CAAC4G,SAAS,CACrE;IAED,IAAIjI,MAAM,CAACqC,IAAI,CAAChB,OAAO,EAAE,SAAS,CAAC,EAAE;MACnC,IAAI,CAACsD,OAAO,GAAGtD,OAAO,CAACsD,OAAO;MAE9B,IAAItD,OAAO,CAAC4G,SAAS,IAAI5G,OAAO,CAACsD,OAAO,KAAKqD,oBAAoB,EAAE;QACjE,MAAMvC,KAAK,CAAC,yCAAyC,CAAC;MACxD;IACF,CAAC,MAAM,IAAIpE,OAAO,CAAC4G,SAAS,EAAE;MAC5B,IAAI,CAACtD,OAAO,GAAGqD,oBAAoB;IACrC,CAAC,MAAM;MACL,MAAMvC,KAAK,CAAC,mCAAmC,CAAC;IAClD;IAEA,MAAMwC,SAAS,GAAG5G,OAAO,CAAC4G,SAAS,IAAI,CAAC,CAAC;IAEzC,IAAI,IAAI,CAACtD,OAAO,EAAE;MAChB,IAAI,CAACwD,IAAI,GAAG,IAAIC,WAAW,CAAC5F,OAAO,CAAC6F,WAAW,CAAC;MAChD,IAAI,CAACC,WAAW,GAAG;QACjBC,WAAW,EAAEA,CAAC5F,EAAE,EAAE6F,MAAM,EAAEb,MAAM,KAAK;UACnC;UACA,MAAM3F,GAAG,GAAAzC,aAAA,KAAQiJ,MAAM,CAAE;UAEzBxG,GAAG,CAACM,GAAG,GAAGK,EAAE;UAEZ,IAAIsF,SAAS,CAACM,WAAW,EAAE;YACzBN,SAAS,CAACM,WAAW,CAAClG,IAAI,CAAC,IAAI,EAAEM,EAAE,EAAET,KAAK,CAACC,KAAK,CAACqG,MAAM,CAAC,EAAEb,MAAM,CAAC;UACnE;;UAEA;UACA,IAAIM,SAAS,CAACQ,KAAK,EAAE;YACnBR,SAAS,CAACQ,KAAK,CAACpG,IAAI,CAAC,IAAI,EAAEM,EAAE,EAAET,KAAK,CAACC,KAAK,CAACqG,MAAM,CAAC,CAAC;UACrD;;UAEA;UACA;UACA;UACA,IAAI,CAACL,IAAI,CAACO,SAAS,CAAC/F,EAAE,EAAEX,GAAG,EAAE2F,MAAM,IAAI,IAAI,CAAC;QAC9C,CAAC;QACDgB,WAAW,EAAEA,CAAChG,EAAE,EAAEgF,MAAM,KAAK;UAC3B,MAAM3F,GAAG,GAAG,IAAI,CAACmG,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC;UAE7B,IAAIsF,SAAS,CAACU,WAAW,EAAE;YACzBV,SAAS,CAACU,WAAW,CAACtG,IAAI,CAAC,IAAI,EAAEM,EAAE,EAAEgF,MAAM,CAAC;UAC9C;UAEA,IAAI,CAACQ,IAAI,CAACS,UAAU,CAACjG,EAAE,EAAEgF,MAAM,IAAI,IAAI,CAAC;QAC1C;MACF,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACQ,IAAI,GAAG,IAAItI,eAAe,CAACY,MAAM,CAAD,CAAC;MACtC,IAAI,CAAC6H,WAAW,GAAG;QACjBG,KAAK,EAAEA,CAAC9F,EAAE,EAAE6F,MAAM,KAAK;UACrB;UACA,MAAMxG,GAAG,GAAAzC,aAAA,KAAQiJ,MAAM,CAAE;UAEzB,IAAIP,SAAS,CAACQ,KAAK,EAAE;YACnBR,SAAS,CAACQ,KAAK,CAACpG,IAAI,CAAC,IAAI,EAAEM,EAAE,EAAET,KAAK,CAACC,KAAK,CAACqG,MAAM,CAAC,CAAC;UACrD;UAEAxG,GAAG,CAACM,GAAG,GAAGK,EAAE;UAEZ,IAAI,CAACwF,IAAI,CAACnF,GAAG,CAACL,EAAE,EAAGX,GAAG,CAAC;QACzB;MACF,CAAC;IACH;;IAEA;IACA;IACA,IAAI,CAACsG,WAAW,CAACO,OAAO,GAAG,CAAClG,EAAE,EAAE6F,MAAM,KAAK;MACzC,MAAMxG,GAAG,GAAG,IAAI,CAACmG,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC;MAE7B,IAAI,CAACX,GAAG,EAAE;QACR,MAAM,IAAIyD,KAAK,4BAAA3C,MAAA,CAA4BH,EAAE,CAAE,CAAC;MAClD;MAEA,IAAIsF,SAAS,CAACY,OAAO,EAAE;QACrBZ,SAAS,CAACY,OAAO,CAACxG,IAAI,CAAC,IAAI,EAAEM,EAAE,EAAET,KAAK,CAACC,KAAK,CAACqG,MAAM,CAAC,CAAC;MACvD;MAEAM,YAAY,CAACC,YAAY,CAAC/G,GAAG,EAAEwG,MAAM,CAAC;IACxC,CAAC;IAED,IAAI,CAACF,WAAW,CAACU,OAAO,GAAGrG,EAAE,IAAI;MAC/B,IAAIsF,SAAS,CAACe,OAAO,EAAE;QACrBf,SAAS,CAACe,OAAO,CAAC3G,IAAI,CAAC,IAAI,EAAEM,EAAE,CAAC;MAClC;MAEA,IAAI,CAACwF,IAAI,CAAC5D,MAAM,CAAC5B,EAAE,CAAC;IACtB,CAAC;EACH;AACF,CAAC;AAED9C,eAAe,CAACY,MAAM,GAAG,MAAMA,MAAM,SAASwI,KAAK,CAAC;EAClD3I,WAAWA,CAAA,EAAG;IACZ,KAAK,CAACkC,OAAO,CAAC6F,WAAW,EAAE7F,OAAO,CAAC0G,OAAO,CAAC;EAC7C;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArJ,eAAe,CAACsJ,aAAa,GAAGC,SAAS,IAAI;EAC3C,IAAI,CAACA,SAAS,EAAE;IACd,OAAO,IAAI;EACb;;EAEA;EACA,IAAIA,SAAS,CAACC,oBAAoB,EAAE;IAClC,OAAOD,SAAS;EAClB;EAEA,MAAME,OAAO,GAAGtH,GAAG,IAAI;IACrB,IAAI,CAAChC,MAAM,CAACqC,IAAI,CAACL,GAAG,EAAE,KAAK,CAAC,EAAE;MAC5B;MACA;MACA,MAAM,IAAIyD,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IAEA,MAAM9C,EAAE,GAAGX,GAAG,CAACM,GAAG;;IAElB;IACA;IACA,MAAMiH,WAAW,GAAGC,OAAO,CAACC,WAAW,CAAC,MAAML,SAAS,CAACpH,GAAG,CAAC,CAAC;IAE7D,IAAI,CAACnC,eAAe,CAAC6J,cAAc,CAACH,WAAW,CAAC,EAAE;MAChD,MAAM,IAAI9D,KAAK,CAAC,8BAA8B,CAAC;IACjD;IAEA,IAAIzF,MAAM,CAACqC,IAAI,CAACkH,WAAW,EAAE,KAAK,CAAC,EAAE;MACnC,IAAI,CAACrH,KAAK,CAACsC,MAAM,CAAC+E,WAAW,CAACjH,GAAG,EAAEK,EAAE,CAAC,EAAE;QACtC,MAAM,IAAI8C,KAAK,CAAC,gDAAgD,CAAC;MACnE;IACF,CAAC,MAAM;MACL8D,WAAW,CAACjH,GAAG,GAAGK,EAAE;IACtB;IAEA,OAAO4G,WAAW;EACpB,CAAC;EAEDD,OAAO,CAACD,oBAAoB,GAAG,IAAI;EAEnC,OAAOC,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACAzJ,eAAe,CAAC8J,aAAa,GAAG,CAACC,GAAG,EAAEC,KAAK,EAAEC,KAAK,KAAK;EACrD,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,KAAK,GAAGH,KAAK,CAACnI,MAAM;EAExB,OAAOsI,KAAK,GAAG,CAAC,EAAE;IAChB,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,GAAG,CAAC,CAAC;IAEvC,IAAIJ,GAAG,CAACE,KAAK,EAAED,KAAK,CAACE,KAAK,GAAGE,SAAS,CAAC,CAAC,IAAI,CAAC,EAAE;MAC7CF,KAAK,IAAIE,SAAS,GAAG,CAAC;MACtBD,KAAK,IAAIC,SAAS,GAAG,CAAC;IACxB,CAAC,MAAM;MACLD,KAAK,GAAGC,SAAS;IACnB;EACF;EAEA,OAAOF,KAAK;AACd,CAAC;AAEDlK,eAAe,CAACuK,yBAAyB,GAAG5B,MAAM,IAAI;EACpD,IAAIA,MAAM,KAAKzH,MAAM,CAACyH,MAAM,CAAC,IAAIrC,KAAK,CAACkE,OAAO,CAAC7B,MAAM,CAAC,EAAE;IACtD,MAAM3F,cAAc,CAAC,iCAAiC,CAAC;EACzD;EAEA9B,MAAM,CAACmC,IAAI,CAACsF,MAAM,CAAC,CAACrF,OAAO,CAACmH,OAAO,IAAI;IACrC,IAAIA,OAAO,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;MACpC,MAAM3H,cAAc,CAClB,2DACF,CAAC;IACH;IAEA,MAAMiH,KAAK,GAAGtB,MAAM,CAAC8B,OAAO,CAAC;IAE7B,IAAI,OAAOR,KAAK,KAAK,QAAQ,IACzB,CAAC,YAAY,EAAE,OAAO,EAAE,QAAQ,CAAC,CAACxD,IAAI,CAACmE,GAAG,IACxCzK,MAAM,CAACqC,IAAI,CAACyH,KAAK,EAAEW,GAAG,CACxB,CAAC,EAAE;MACL,MAAM5H,cAAc,CAClB,0DACF,CAAC;IACH;IAEA,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC2H,QAAQ,CAACV,KAAK,CAAC,EAAE;MACxC,MAAMjH,cAAc,CAClB,yDACF,CAAC;IACH;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAhD,eAAe,CAAC6K,kBAAkB,GAAGlC,MAAM,IAAI;EAC7C3I,eAAe,CAACuK,yBAAyB,CAAC5B,MAAM,CAAC;EAEjD,MAAMmC,aAAa,GAAGnC,MAAM,CAAClG,GAAG,KAAKV,SAAS,GAAG,IAAI,GAAG4G,MAAM,CAAClG,GAAG;EAClE,MAAMsI,OAAO,GAAGvK,iBAAiB,CAACmI,MAAM,CAAC;;EAEzC;EACA,MAAMY,SAAS,GAAGA,CAACpH,GAAG,EAAE6I,QAAQ,KAAK;IACnC;IACA,IAAI1E,KAAK,CAACkE,OAAO,CAACrI,GAAG,CAAC,EAAE;MACtB,OAAOA,GAAG,CAACuE,GAAG,CAACuE,MAAM,IAAI1B,SAAS,CAAC0B,MAAM,EAAED,QAAQ,CAAC,CAAC;IACvD;IAEA,MAAMnH,MAAM,GAAGkH,OAAO,CAACG,SAAS,GAAG,CAAC,CAAC,GAAG7I,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC;IAExDjB,MAAM,CAACmC,IAAI,CAAC2H,QAAQ,CAAC,CAAC1H,OAAO,CAACsH,GAAG,IAAI;MACnC,IAAIzI,GAAG,IAAI,IAAI,IAAI,CAAChC,MAAM,CAACqC,IAAI,CAACL,GAAG,EAAEyI,GAAG,CAAC,EAAE;QACzC;MACF;MAEA,MAAMO,IAAI,GAAGH,QAAQ,CAACJ,GAAG,CAAC;MAE1B,IAAIO,IAAI,KAAKjK,MAAM,CAACiK,IAAI,CAAC,EAAE;QACzB;QACA,IAAIhJ,GAAG,CAACyI,GAAG,CAAC,KAAK1J,MAAM,CAACiB,GAAG,CAACyI,GAAG,CAAC,CAAC,EAAE;UACjC/G,MAAM,CAAC+G,GAAG,CAAC,GAAGrB,SAAS,CAACpH,GAAG,CAACyI,GAAG,CAAC,EAAEO,IAAI,CAAC;QACzC;MACF,CAAC,MAAM,IAAIJ,OAAO,CAACG,SAAS,EAAE;QAC5B;QACArH,MAAM,CAAC+G,GAAG,CAAC,GAAGvI,KAAK,CAACC,KAAK,CAACH,GAAG,CAACyI,GAAG,CAAC,CAAC;MACrC,CAAC,MAAM;QACL,OAAO/G,MAAM,CAAC+G,GAAG,CAAC;MACpB;IACF,CAAC,CAAC;IAEF,OAAOzI,GAAG,IAAI,IAAI,GAAG0B,MAAM,GAAG1B,GAAG;EACnC,CAAC;EAED,OAAOA,GAAG,IAAI;IACZ,MAAM0B,MAAM,GAAG0F,SAAS,CAACpH,GAAG,EAAE4I,OAAO,CAACK,IAAI,CAAC;IAE3C,IAAIN,aAAa,IAAI3K,MAAM,CAACqC,IAAI,CAACL,GAAG,EAAE,KAAK,CAAC,EAAE;MAC5C0B,MAAM,CAACpB,GAAG,GAAGN,GAAG,CAACM,GAAG;IACtB;IAEA,IAAI,CAACqI,aAAa,IAAI3K,MAAM,CAACqC,IAAI,CAACqB,MAAM,EAAE,KAAK,CAAC,EAAE;MAChD,OAAOA,MAAM,CAACpB,GAAG;IACnB;IAEA,OAAOoB,MAAM;EACf,CAAC;AACH,CAAC;;AAED;AACA;AACA7D,eAAe,CAACmH,qBAAqB,GAAG,CAAC5F,QAAQ,EAAE8J,QAAQ,KAAK;EAC9D,MAAMC,gBAAgB,GAAG/K,+BAA+B,CAACgB,QAAQ,CAAC;EAClE,MAAMgK,QAAQ,GAAGvL,eAAe,CAACwL,kBAAkB,CAACH,QAAQ,CAAC;EAE7D,MAAMI,MAAM,GAAG,CAAC,CAAC;EAEjB,IAAIH,gBAAgB,CAAC7I,GAAG,EAAE;IACxBgJ,MAAM,CAAChJ,GAAG,GAAG6I,gBAAgB,CAAC7I,GAAG;IACjC,OAAO6I,gBAAgB,CAAC7I,GAAG;EAC7B;;EAEA;EACA;EACA;EACAzC,eAAe,CAAC2H,OAAO,CAAC8D,MAAM,EAAE;IAACC,IAAI,EAAEJ;EAAgB,CAAC,CAAC;EACzDtL,eAAe,CAAC2H,OAAO,CAAC8D,MAAM,EAAEJ,QAAQ,EAAE;IAACM,QAAQ,EAAE;EAAI,CAAC,CAAC;EAE3D,IAAIJ,QAAQ,EAAE;IACZ,OAAOE,MAAM;EACf;;EAEA;EACA,MAAMG,WAAW,GAAG1K,MAAM,CAACoG,MAAM,CAAC,CAAC,CAAC,EAAE+D,QAAQ,CAAC;EAC/C,IAAII,MAAM,CAAChJ,GAAG,EAAE;IACdmJ,WAAW,CAACnJ,GAAG,GAAGgJ,MAAM,CAAChJ,GAAG;EAC9B;EAEA,OAAOmJ,WAAW;AACpB,CAAC;AAED5L,eAAe,CAAC6L,YAAY,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAE3D,SAAS,KAAK;EACzD,OAAOa,YAAY,CAAC+C,WAAW,CAACF,IAAI,EAAEC,KAAK,EAAE3D,SAAS,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACApI,eAAe,CAACyF,iBAAiB,GAAG,CAACX,OAAO,EAAEkD,UAAU,EAAEiE,UAAU,EAAEC,QAAQ,EAAE1K,OAAO,KACrFyH,YAAY,CAACkD,gBAAgB,CAACrH,OAAO,EAAEkD,UAAU,EAAEiE,UAAU,EAAEC,QAAQ,EAAE1K,OAAO,CAAC;AAGnFxB,eAAe,CAACoM,wBAAwB,GAAG,CAACpE,UAAU,EAAEiE,UAAU,EAAEC,QAAQ,EAAE1K,OAAO,KACnFyH,YAAY,CAACoD,uBAAuB,CAACrE,UAAU,EAAEiE,UAAU,EAAEC,QAAQ,EAAE1K,OAAO,CAAC;AAGjFxB,eAAe,CAACsM,0BAA0B,GAAG,CAACtE,UAAU,EAAEiE,UAAU,EAAEC,QAAQ,EAAE1K,OAAO,KACrFyH,YAAY,CAACsD,yBAAyB,CAACvE,UAAU,EAAEiE,UAAU,EAAEC,QAAQ,EAAE1K,OAAO,CAAC;AAGnFxB,eAAe,CAACwM,qBAAqB,GAAG,CAAChJ,KAAK,EAAErB,GAAG,KAAK;EACtD,IAAI,CAACqB,KAAK,CAACsB,OAAO,EAAE;IAClB,MAAM,IAAIc,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,KAAK,CAACiB,OAAO,CAAC5C,MAAM,EAAEsD,CAAC,EAAE,EAAE;IAC7C,IAAI3B,KAAK,CAACiB,OAAO,CAACU,CAAC,CAAC,KAAKhD,GAAG,EAAE;MAC5B,OAAOgD,CAAC;IACV;EACF;EAEA,MAAMS,KAAK,CAAC,2BAA2B,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA5F,eAAe,CAACqG,qBAAqB,GAAG9E,QAAQ,IAAI;EAClD;EACA,IAAIvB,eAAe,CAACyM,aAAa,CAAClL,QAAQ,CAAC,EAAE;IAC3C,OAAO,CAACA,QAAQ,CAAC;EACnB;EAEA,IAAI,CAACA,QAAQ,EAAE;IACb,OAAO,IAAI;EACb;;EAEA;EACA,IAAIpB,MAAM,CAACqC,IAAI,CAACjB,QAAQ,EAAE,KAAK,CAAC,EAAE;IAChC;IACA,IAAIvB,eAAe,CAACyM,aAAa,CAAClL,QAAQ,CAACkB,GAAG,CAAC,EAAE;MAC/C,OAAO,CAAClB,QAAQ,CAACkB,GAAG,CAAC;IACvB;;IAEA;IACA,IAAIlB,QAAQ,CAACkB,GAAG,IACT6D,KAAK,CAACkE,OAAO,CAACjJ,QAAQ,CAACkB,GAAG,CAACiK,GAAG,CAAC,IAC/BnL,QAAQ,CAACkB,GAAG,CAACiK,GAAG,CAAC7K,MAAM,IACvBN,QAAQ,CAACkB,GAAG,CAACiK,GAAG,CAACC,KAAK,CAAC3M,eAAe,CAACyM,aAAa,CAAC,EAAE;MAC5D,OAAOlL,QAAQ,CAACkB,GAAG,CAACiK,GAAG;IACzB;IAEA,OAAO,IAAI;EACb;;EAEA;EACA;EACA;EACA,IAAIpG,KAAK,CAACkE,OAAO,CAACjJ,QAAQ,CAACqL,IAAI,CAAC,EAAE;IAChC,KAAK,IAAIzH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5D,QAAQ,CAACqL,IAAI,CAAC/K,MAAM,EAAE,EAAEsD,CAAC,EAAE;MAC7C,MAAM0H,MAAM,GAAG7M,eAAe,CAACqG,qBAAqB,CAAC9E,QAAQ,CAACqL,IAAI,CAACzH,CAAC,CAAC,CAAC;MAEtE,IAAI0H,MAAM,EAAE;QACV,OAAOA,MAAM;MACf;IACF;EACF;EAEA,OAAO,IAAI;AACb,CAAC;AAED7M,eAAe,CAACmE,gBAAgB,GAAG,CAACX,KAAK,EAAErB,GAAG,KAAK;EACjD,MAAMwG,MAAM,GAAGtG,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC;EAE/B,OAAOwG,MAAM,CAAClG,GAAG;EAEjB,IAAIe,KAAK,CAACsB,OAAO,EAAE;IACjB,IAAI,CAACtB,KAAK,CAACsJ,MAAM,EAAE;MACjBtJ,KAAK,CAACkF,WAAW,CAACvG,GAAG,CAACM,GAAG,EAAEe,KAAK,CAACkC,YAAY,CAACiD,MAAM,CAAC,EAAE,IAAI,CAAC;MAC5DnF,KAAK,CAACiB,OAAO,CAACP,IAAI,CAAC/B,GAAG,CAAC;IACzB,CAAC,MAAM;MACL,MAAMgD,CAAC,GAAGnF,eAAe,CAAC+M,mBAAmB,CAC3CvJ,KAAK,CAACsJ,MAAM,CAACE,aAAa,CAAC;QAAClJ,SAAS,EAAEN,KAAK,CAACM;MAAS,CAAC,CAAC,EACxDN,KAAK,CAACiB,OAAO,EACbtC,GACF,CAAC;MAED,IAAI8K,IAAI,GAAGzJ,KAAK,CAACiB,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC;MAC/B,IAAI8H,IAAI,EAAE;QACRA,IAAI,GAAGA,IAAI,CAACxK,GAAG;MACjB,CAAC,MAAM;QACLwK,IAAI,GAAG,IAAI;MACb;MAEAzJ,KAAK,CAACkF,WAAW,CAACvG,GAAG,CAACM,GAAG,EAAEe,KAAK,CAACkC,YAAY,CAACiD,MAAM,CAAC,EAAEsE,IAAI,CAAC;IAC9D;IAEAzJ,KAAK,CAACoF,KAAK,CAACzG,GAAG,CAACM,GAAG,EAAEe,KAAK,CAACkC,YAAY,CAACiD,MAAM,CAAC,CAAC;EAClD,CAAC,MAAM;IACLnF,KAAK,CAACoF,KAAK,CAACzG,GAAG,CAACM,GAAG,EAAEe,KAAK,CAACkC,YAAY,CAACiD,MAAM,CAAC,CAAC;IAChDnF,KAAK,CAACiB,OAAO,CAACtB,GAAG,CAAChB,GAAG,CAACM,GAAG,EAAEN,GAAG,CAAC;EACjC;AACF,CAAC;AAEDnC,eAAe,CAAC+M,mBAAmB,GAAG,CAAChD,GAAG,EAAEC,KAAK,EAAEC,KAAK,KAAK;EAC3D,IAAID,KAAK,CAACnI,MAAM,KAAK,CAAC,EAAE;IACtBmI,KAAK,CAAC9F,IAAI,CAAC+F,KAAK,CAAC;IACjB,OAAO,CAAC;EACV;EAEA,MAAM9E,CAAC,GAAGnF,eAAe,CAAC8J,aAAa,CAACC,GAAG,EAAEC,KAAK,EAAEC,KAAK,CAAC;EAE1DD,KAAK,CAACkD,MAAM,CAAC/H,CAAC,EAAE,CAAC,EAAE8E,KAAK,CAAC;EAEzB,OAAO9E,CAAC;AACV,CAAC;AAEDnF,eAAe,CAACwL,kBAAkB,GAAGxF,GAAG,IAAI;EAC1C,IAAIuF,QAAQ,GAAG,KAAK;EACpB,IAAI4B,SAAS,GAAG,KAAK;EAErBjM,MAAM,CAACmC,IAAI,CAAC2C,GAAG,CAAC,CAAC1C,OAAO,CAACsH,GAAG,IAAI;IAC9B,IAAIA,GAAG,CAACwC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;MAC5B7B,QAAQ,GAAG,IAAI;IACjB,CAAC,MAAM;MACL4B,SAAS,GAAG,IAAI;IAClB;EACF,CAAC,CAAC;EAEF,IAAI5B,QAAQ,IAAI4B,SAAS,EAAE;IACzB,MAAM,IAAIvH,KAAK,CACb,qEACF,CAAC;EACH;EAEA,OAAO2F,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACAvL,eAAe,CAAC6J,cAAc,GAAGwD,CAAC,IAAI;EACpC,OAAOA,CAAC,IAAIrN,eAAe,CAACsN,EAAE,CAACC,KAAK,CAACF,CAAC,CAAC,KAAK,CAAC;AAC/C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArN,eAAe,CAAC2H,OAAO,GAAG,UAACxF,GAAG,EAAEkJ,QAAQ,EAAmB;EAAA,IAAjB7J,OAAO,GAAAI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAG,SAAA,GAAAH,SAAA,MAAG,CAAC,CAAC;EACpD,IAAI,CAAC5B,eAAe,CAAC6J,cAAc,CAACwB,QAAQ,CAAC,EAAE;IAC7C,MAAMrI,cAAc,CAAC,4BAA4B,CAAC;EACpD;;EAEA;EACAqI,QAAQ,GAAGhJ,KAAK,CAACC,KAAK,CAAC+I,QAAQ,CAAC;EAEhC,MAAMmC,UAAU,GAAGlN,gBAAgB,CAAC+K,QAAQ,CAAC;EAC7C,MAAMI,MAAM,GAAG+B,UAAU,GAAGnL,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC,GAAGkJ,QAAQ;EAEvD,IAAImC,UAAU,EAAE;IACd;IACAtM,MAAM,CAACmC,IAAI,CAACgI,QAAQ,CAAC,CAAC/H,OAAO,CAACmK,QAAQ,IAAI;MACxC;MACA,MAAMC,WAAW,GAAGlM,OAAO,CAACmK,QAAQ,IAAI8B,QAAQ,KAAK,cAAc;MACnE,MAAME,OAAO,GAAGC,SAAS,CAACF,WAAW,GAAG,MAAM,GAAGD,QAAQ,CAAC;MAC1D,MAAMI,OAAO,GAAGxC,QAAQ,CAACoC,QAAQ,CAAC;MAElC,IAAI,CAACE,OAAO,EAAE;QACZ,MAAM3K,cAAc,+BAAAC,MAAA,CAA+BwK,QAAQ,CAAE,CAAC;MAChE;MAEAvM,MAAM,CAACmC,IAAI,CAACwK,OAAO,CAAC,CAACvK,OAAO,CAACwK,OAAO,IAAI;QACtC,MAAMC,GAAG,GAAGF,OAAO,CAACC,OAAO,CAAC;QAE5B,IAAIA,OAAO,KAAK,EAAE,EAAE;UAClB,MAAM9K,cAAc,CAAC,oCAAoC,CAAC;QAC5D;QAEA,MAAMgL,QAAQ,GAAGF,OAAO,CAACpD,KAAK,CAAC,GAAG,CAAC;QAEnC,IAAI,CAACsD,QAAQ,CAACrB,KAAK,CAACsB,OAAO,CAAC,EAAE;UAC5B,MAAMjL,cAAc,CAClB,oBAAAC,MAAA,CAAoB6K,OAAO,wCAC3B,uBACF,CAAC;QACH;QAEA,MAAMI,MAAM,GAAGC,aAAa,CAAC1C,MAAM,EAAEuC,QAAQ,EAAE;UAC7CjH,YAAY,EAAEvF,OAAO,CAACuF,YAAY;UAClCqH,WAAW,EAAEX,QAAQ,KAAK,SAAS;UACnCY,QAAQ,EAAEC,mBAAmB,CAACb,QAAQ;QACxC,CAAC,CAAC;QAEFE,OAAO,CAACO,MAAM,EAAEF,QAAQ,CAACO,GAAG,CAAC,CAAC,EAAER,GAAG,EAAED,OAAO,EAAErC,MAAM,CAAC;MACvD,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,IAAItJ,GAAG,CAACM,GAAG,IAAI,CAACJ,KAAK,CAACsC,MAAM,CAACxC,GAAG,CAACM,GAAG,EAAEgJ,MAAM,CAAChJ,GAAG,CAAC,EAAE;MACjD,MAAMO,cAAc,CAClB,qDAAAC,MAAA,CAAoDd,GAAG,CAACM,GAAG,iBAC3D,mEAAmE,aAAAQ,MAAA,CAC1DwI,MAAM,CAAChJ,GAAG,OACrB,CAAC;IACH;EACF,CAAC,MAAM;IACL,IAAIN,GAAG,CAACM,GAAG,IAAI4I,QAAQ,CAAC5I,GAAG,IAAI,CAACJ,KAAK,CAACsC,MAAM,CAACxC,GAAG,CAACM,GAAG,EAAE4I,QAAQ,CAAC5I,GAAG,CAAC,EAAE;MACnE,MAAMO,cAAc,CAClB,gDAAAC,MAAA,CAA+Cd,GAAG,CAACM,GAAG,0BAAAQ,MAAA,CAC5CoI,QAAQ,CAAC5I,GAAG,QACxB,CAAC;IACH;;IAEA;IACAF,wBAAwB,CAAC8I,QAAQ,CAAC;EACpC;;EAEA;EACAnK,MAAM,CAACmC,IAAI,CAAClB,GAAG,CAAC,CAACmB,OAAO,CAACsH,GAAG,IAAI;IAC9B;IACA;IACA;IACA,IAAIA,GAAG,KAAK,KAAK,EAAE;MACjB,OAAOzI,GAAG,CAACyI,GAAG,CAAC;IACjB;EACF,CAAC,CAAC;EAEF1J,MAAM,CAACmC,IAAI,CAACoI,MAAM,CAAC,CAACnI,OAAO,CAACsH,GAAG,IAAI;IACjCzI,GAAG,CAACyI,GAAG,CAAC,GAAGa,MAAM,CAACb,GAAG,CAAC;EACxB,CAAC,CAAC;AACJ,CAAC;AAED5K,eAAe,CAACwO,0BAA0B,GAAG,CAACxK,MAAM,EAAEyK,gBAAgB,KAAK;EACzE,MAAMlF,SAAS,GAAGvF,MAAM,CAAC0K,YAAY,CAAC,CAAC,KAAKvM,GAAG,IAAIA,GAAG,CAAC;EACvD,IAAIwM,UAAU,GAAG,CAAC,CAACF,gBAAgB,CAACG,iBAAiB;EAErD,IAAIC,uBAAuB;EAC3B,IAAI7O,eAAe,CAAC8O,2BAA2B,CAACL,gBAAgB,CAAC,EAAE;IACjE;IACA;IACA;IACA;IACA,MAAMM,OAAO,GAAG,CAACN,gBAAgB,CAACO,WAAW;IAE7CH,uBAAuB,GAAG;MACxBnG,WAAWA,CAAC5F,EAAE,EAAE6F,MAAM,EAAEb,MAAM,EAAE;QAC9B,IAAI6G,UAAU,IAAI,EAAEF,gBAAgB,CAACQ,OAAO,IAAIR,gBAAgB,CAAC7F,KAAK,CAAC,EAAE;UACvE;QACF;QAEA,MAAMzG,GAAG,GAAGoH,SAAS,CAACrI,MAAM,CAACoG,MAAM,CAACqB,MAAM,EAAE;UAAClG,GAAG,EAAEK;QAAE,CAAC,CAAC,CAAC;QAEvD,IAAI2L,gBAAgB,CAACQ,OAAO,EAAE;UAC5BR,gBAAgB,CAACQ,OAAO,CACtB9M,GAAG,EACH4M,OAAO,GACHjH,MAAM,GACJ,IAAI,CAACQ,IAAI,CAAC4G,OAAO,CAACpH,MAAM,CAAC,GACzB,IAAI,CAACQ,IAAI,CAAC1D,IAAI,CAAC,CAAC,GAClB,CAAC,CAAC,EACNkD,MACF,CAAC;QACH,CAAC,MAAM;UACL2G,gBAAgB,CAAC7F,KAAK,CAACzG,GAAG,CAAC;QAC7B;MACF,CAAC;MACD6G,OAAOA,CAAClG,EAAE,EAAE6F,MAAM,EAAE;QAClB,IAAI,EAAE8F,gBAAgB,CAACU,SAAS,IAAIV,gBAAgB,CAACzF,OAAO,CAAC,EAAE;UAC7D;QACF;QAEA,IAAI7G,GAAG,GAAGE,KAAK,CAACC,KAAK,CAAC,IAAI,CAACgG,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC,CAAC;QACxC,IAAI,CAACX,GAAG,EAAE;UACR,MAAM,IAAIyD,KAAK,4BAAA3C,MAAA,CAA4BH,EAAE,CAAE,CAAC;QAClD;QAEA,MAAMsM,MAAM,GAAG7F,SAAS,CAAClH,KAAK,CAACC,KAAK,CAACH,GAAG,CAAC,CAAC;QAE1C8G,YAAY,CAACC,YAAY,CAAC/G,GAAG,EAAEwG,MAAM,CAAC;QAEtC,IAAI8F,gBAAgB,CAACU,SAAS,EAAE;UAC9BV,gBAAgB,CAACU,SAAS,CACxB5F,SAAS,CAACpH,GAAG,CAAC,EACdiN,MAAM,EACNL,OAAO,GAAG,IAAI,CAACzG,IAAI,CAAC4G,OAAO,CAACpM,EAAE,CAAC,GAAG,CAAC,CACrC,CAAC;QACH,CAAC,MAAM;UACL2L,gBAAgB,CAACzF,OAAO,CAACO,SAAS,CAACpH,GAAG,CAAC,EAAEiN,MAAM,CAAC;QAClD;MACF,CAAC;MACDtG,WAAWA,CAAChG,EAAE,EAAEgF,MAAM,EAAE;QACtB,IAAI,CAAC2G,gBAAgB,CAACY,OAAO,EAAE;UAC7B;QACF;QAEA,MAAMC,IAAI,GAAGP,OAAO,GAAG,IAAI,CAACzG,IAAI,CAAC4G,OAAO,CAACpM,EAAE,CAAC,GAAG,CAAC,CAAC;QACjD,IAAIyM,EAAE,GAAGR,OAAO,GACZjH,MAAM,GACJ,IAAI,CAACQ,IAAI,CAAC4G,OAAO,CAACpH,MAAM,CAAC,GACzB,IAAI,CAACQ,IAAI,CAAC1D,IAAI,CAAC,CAAC,GAClB,CAAC,CAAC;;QAEN;QACA;QACA,IAAI2K,EAAE,GAAGD,IAAI,EAAE;UACb,EAAEC,EAAE;QACN;QAEAd,gBAAgB,CAACY,OAAO,CACtB9F,SAAS,CAAClH,KAAK,CAACC,KAAK,CAAC,IAAI,CAACgG,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC,CAAC,CAAC,EACzCwM,IAAI,EACJC,EAAE,EACFzH,MAAM,IAAI,IACZ,CAAC;MACH,CAAC;MACDqB,OAAOA,CAACrG,EAAE,EAAE;QACV,IAAI,EAAE2L,gBAAgB,CAACe,SAAS,IAAIf,gBAAgB,CAACtF,OAAO,CAAC,EAAE;UAC7D;QACF;;QAEA;QACA;QACA,MAAMhH,GAAG,GAAGoH,SAAS,CAAC,IAAI,CAACjB,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC,CAAC;QAExC,IAAI2L,gBAAgB,CAACe,SAAS,EAAE;UAC9Bf,gBAAgB,CAACe,SAAS,CAACrN,GAAG,EAAE4M,OAAO,GAAG,IAAI,CAACzG,IAAI,CAAC4G,OAAO,CAACpM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;QACvE,CAAC,MAAM;UACL2L,gBAAgB,CAACtF,OAAO,CAAChH,GAAG,CAAC;QAC/B;MACF;IACF,CAAC;EACH,CAAC,MAAM;IACL0M,uBAAuB,GAAG;MACxBjG,KAAKA,CAAC9F,EAAE,EAAE6F,MAAM,EAAE;QAChB,IAAI,CAACgG,UAAU,IAAIF,gBAAgB,CAAC7F,KAAK,EAAE;UACzC6F,gBAAgB,CAAC7F,KAAK,CAACW,SAAS,CAACrI,MAAM,CAACoG,MAAM,CAACqB,MAAM,EAAE;YAAClG,GAAG,EAAEK;UAAE,CAAC,CAAC,CAAC,CAAC;QACrE;MACF,CAAC;MACDkG,OAAOA,CAAClG,EAAE,EAAE6F,MAAM,EAAE;QAClB,IAAI8F,gBAAgB,CAACzF,OAAO,EAAE;UAC5B,MAAMoG,MAAM,GAAG,IAAI,CAAC9G,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC;UAChC,MAAMX,GAAG,GAAGE,KAAK,CAACC,KAAK,CAAC8M,MAAM,CAAC;UAE/BnG,YAAY,CAACC,YAAY,CAAC/G,GAAG,EAAEwG,MAAM,CAAC;UAEtC8F,gBAAgB,CAACzF,OAAO,CACtBO,SAAS,CAACpH,GAAG,CAAC,EACdoH,SAAS,CAAClH,KAAK,CAACC,KAAK,CAAC8M,MAAM,CAAC,CAC/B,CAAC;QACH;MACF,CAAC;MACDjG,OAAOA,CAACrG,EAAE,EAAE;QACV,IAAI2L,gBAAgB,CAACtF,OAAO,EAAE;UAC5BsF,gBAAgB,CAACtF,OAAO,CAACI,SAAS,CAAC,IAAI,CAACjB,IAAI,CAAChD,GAAG,CAACxC,EAAE,CAAC,CAAC,CAAC;QACxD;MACF;IACF,CAAC;EACH;EAEA,MAAM2M,cAAc,GAAG,IAAIzP,eAAe,CAACkI,sBAAsB,CAAC;IAChEE,SAAS,EAAEyG;EACb,CAAC,CAAC;;EAEF;EACA;EACA;EACAY,cAAc,CAAChH,WAAW,CAACiH,YAAY,GAAG,IAAI;EAC9C,MAAMC,MAAM,GAAG3L,MAAM,CAAC4L,cAAc,CAACH,cAAc,CAAChH,WAAW,EAC7D;IAAEoH,oBAAoB,EAAE;EAAK,CAAC,CAAC;EAEjClB,UAAU,GAAG,KAAK;EAElB,OAAOgB,MAAM;AACf,CAAC;AAED3P,eAAe,CAAC8O,2BAA2B,GAAG1G,SAAS,IAAI;EACzD,IAAIA,SAAS,CAACQ,KAAK,IAAIR,SAAS,CAAC6G,OAAO,EAAE;IACxC,MAAM,IAAIrJ,KAAK,CAAC,kDAAkD,CAAC;EACrE;EAEA,IAAIwC,SAAS,CAACY,OAAO,IAAIZ,SAAS,CAAC+G,SAAS,EAAE;IAC5C,MAAM,IAAIvJ,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,IAAIwC,SAAS,CAACe,OAAO,IAAIf,SAAS,CAACoH,SAAS,EAAE;IAC5C,MAAM,IAAI5J,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,OAAO,CAAC,EACNwC,SAAS,CAAC6G,OAAO,IACjB7G,SAAS,CAAC+G,SAAS,IACnB/G,SAAS,CAACiH,OAAO,IACjBjH,SAAS,CAACoH,SAAS,CACpB;AACH,CAAC;AAEDxP,eAAe,CAACqI,kCAAkC,GAAGD,SAAS,IAAI;EAChE,IAAIA,SAAS,CAACQ,KAAK,IAAIR,SAAS,CAACM,WAAW,EAAE;IAC5C,MAAM,IAAI9C,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,OAAO,CAAC,EAAEwC,SAAS,CAACM,WAAW,IAAIN,SAAS,CAACU,WAAW,CAAC;AAC3D,CAAC;AAED9I,eAAe,CAACuF,kBAAkB,GAAG,CAAC/B,KAAK,EAAErB,GAAG,KAAK;EACnD,IAAIqB,KAAK,CAACsB,OAAO,EAAE;IACjB,MAAMK,CAAC,GAAGnF,eAAe,CAACwM,qBAAqB,CAAChJ,KAAK,EAAErB,GAAG,CAAC;IAE3DqB,KAAK,CAAC2F,OAAO,CAAChH,GAAG,CAACM,GAAG,CAAC;IACtBe,KAAK,CAACiB,OAAO,CAACyI,MAAM,CAAC/H,CAAC,EAAE,CAAC,CAAC;EAC5B,CAAC,MAAM;IACL,MAAMrC,EAAE,GAAGX,GAAG,CAACM,GAAG,CAAC,CAAE;;IAErBe,KAAK,CAAC2F,OAAO,CAAChH,GAAG,CAACM,GAAG,CAAC;IACtBe,KAAK,CAACiB,OAAO,CAACC,MAAM,CAAC5B,EAAE,CAAC;EAC1B;AACF,CAAC;;AAED;AACA9C,eAAe,CAACyM,aAAa,GAAGlL,QAAQ,IACtC,OAAOA,QAAQ,KAAK,QAAQ,IAC5B,OAAOA,QAAQ,KAAK,QAAQ,IAC5BA,QAAQ,YAAYoB,OAAO,CAACC,QAAQ;;AAGtC;AACA5C,eAAe,CAAC8P,4BAA4B,GAAGvO,QAAQ,IACrDvB,eAAe,CAACyM,aAAa,CAAClL,QAAQ,CAAC,IACvCvB,eAAe,CAACyM,aAAa,CAAClL,QAAQ,IAAIA,QAAQ,CAACkB,GAAG,CAAC,IACvDvB,MAAM,CAACmC,IAAI,CAAC9B,QAAQ,CAAC,CAACM,MAAM,KAAK,CAAC;AAGpC7B,eAAe,CAAC+H,gBAAgB,GAAG,CAACvE,KAAK,EAAErB,GAAG,EAAEuF,OAAO,KAAK;EAC1D,IAAI,CAACrF,KAAK,CAACsC,MAAM,CAACxC,GAAG,CAACM,GAAG,EAAEiF,OAAO,CAACjF,GAAG,CAAC,EAAE;IACvC,MAAM,IAAImD,KAAK,CAAC,2CAA2C,CAAC;EAC9D;EAEA,MAAMF,YAAY,GAAGlC,KAAK,CAACkC,YAAY;EACvC,MAAMqK,aAAa,GAAG9G,YAAY,CAAC+G,iBAAiB,CAClDtK,YAAY,CAACvD,GAAG,CAAC,EACjBuD,YAAY,CAACgC,OAAO,CACtB,CAAC;EAED,IAAI,CAAClE,KAAK,CAACsB,OAAO,EAAE;IAClB,IAAI5D,MAAM,CAACmC,IAAI,CAAC0M,aAAa,CAAC,CAAClO,MAAM,EAAE;MACrC2B,KAAK,CAACwF,OAAO,CAAC7G,GAAG,CAACM,GAAG,EAAEsN,aAAa,CAAC;MACrCvM,KAAK,CAACiB,OAAO,CAACtB,GAAG,CAAChB,GAAG,CAACM,GAAG,EAAEN,GAAG,CAAC;IACjC;IAEA;EACF;EAEA,MAAM8N,OAAO,GAAGjQ,eAAe,CAACwM,qBAAqB,CAAChJ,KAAK,EAAErB,GAAG,CAAC;EAEjE,IAAIjB,MAAM,CAACmC,IAAI,CAAC0M,aAAa,CAAC,CAAClO,MAAM,EAAE;IACrC2B,KAAK,CAACwF,OAAO,CAAC7G,GAAG,CAACM,GAAG,EAAEsN,aAAa,CAAC;EACvC;EAEA,IAAI,CAACvM,KAAK,CAACsJ,MAAM,EAAE;IACjB;EACF;;EAEA;EACAtJ,KAAK,CAACiB,OAAO,CAACyI,MAAM,CAAC+C,OAAO,EAAE,CAAC,CAAC;EAEhC,MAAMC,OAAO,GAAGlQ,eAAe,CAAC+M,mBAAmB,CACjDvJ,KAAK,CAACsJ,MAAM,CAACE,aAAa,CAAC;IAAClJ,SAAS,EAAEN,KAAK,CAACM;EAAS,CAAC,CAAC,EACxDN,KAAK,CAACiB,OAAO,EACbtC,GACF,CAAC;EAED,IAAI8N,OAAO,KAAKC,OAAO,EAAE;IACvB,IAAIjD,IAAI,GAAGzJ,KAAK,CAACiB,OAAO,CAACyL,OAAO,GAAG,CAAC,CAAC;IACrC,IAAIjD,IAAI,EAAE;MACRA,IAAI,GAAGA,IAAI,CAACxK,GAAG;IACjB,CAAC,MAAM;MACLwK,IAAI,GAAG,IAAI;IACb;IAEAzJ,KAAK,CAACsF,WAAW,IAAItF,KAAK,CAACsF,WAAW,CAAC3G,GAAG,CAACM,GAAG,EAAEwK,IAAI,CAAC;EACvD;AACF,CAAC;AAED,MAAMW,SAAS,GAAG;EAChBuC,YAAYA,CAACjC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IAC/B,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI5N,MAAM,CAACqC,IAAI,CAACuL,GAAG,EAAE,OAAO,CAAC,EAAE;MACxD,IAAIA,GAAG,CAACsC,KAAK,KAAK,MAAM,EAAE;QACxB,MAAMrN,cAAc,CAClB,yDAAyD,GACzD,wBAAwB,EACxB;UAACoN;QAAK,CACR,CAAC;MACH;IACF,CAAC,MAAM,IAAIrC,GAAG,KAAK,IAAI,EAAE;MACvB,MAAM/K,cAAc,CAAC,+BAA+B,EAAE;QAACoN;MAAK,CAAC,CAAC;IAChE;IAEAlC,MAAM,CAACkC,KAAK,CAAC,GAAG,IAAIE,IAAI,CAAC,CAAC;EAC5B,CAAC;EACDC,IAAIA,CAACrC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAM/K,cAAc,CAAC,wCAAwC,EAAE;QAACoN;MAAK,CAAC,CAAC;IACzE;IAEA,IAAIA,KAAK,IAAIlC,MAAM,EAAE;MACnB,IAAI,OAAOA,MAAM,CAACkC,KAAK,CAAC,KAAK,QAAQ,EAAE;QACrC,MAAMpN,cAAc,CAClB,0CAA0C,EAC1C;UAACoN;QAAK,CACR,CAAC;MACH;MAEAlC,MAAM,CAACkC,KAAK,CAAC,IAAIrC,GAAG;IACtB,CAAC,MAAM;MACLG,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;IACrB;EACF,CAAC;EACDyC,IAAIA,CAACtC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAM/K,cAAc,CAAC,wCAAwC,EAAE;QAACoN;MAAK,CAAC,CAAC;IACzE;IAEA,IAAIA,KAAK,IAAIlC,MAAM,EAAE;MACnB,IAAI,OAAOA,MAAM,CAACkC,KAAK,CAAC,KAAK,QAAQ,EAAE;QACrC,MAAMpN,cAAc,CAClB,0CAA0C,EAC1C;UAACoN;QAAK,CACR,CAAC;MACH;MAEA,IAAIlC,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG,EAAE;QACvBG,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;MACrB;IACF,CAAC,MAAM;MACLG,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;IACrB;EACF,CAAC;EACD0C,IAAIA,CAACvC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAM/K,cAAc,CAAC,wCAAwC,EAAE;QAACoN;MAAK,CAAC,CAAC;IACzE;IAEA,IAAIA,KAAK,IAAIlC,MAAM,EAAE;MACnB,IAAI,OAAOA,MAAM,CAACkC,KAAK,CAAC,KAAK,QAAQ,EAAE;QACrC,MAAMpN,cAAc,CAClB,0CAA0C,EAC1C;UAACoN;QAAK,CACR,CAAC;MACH;MAEA,IAAIlC,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG,EAAE;QACvBG,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;MACrB;IACF,CAAC,MAAM;MACLG,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;IACrB;EACF,CAAC;EACD2C,IAAIA,CAACxC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAM/K,cAAc,CAAC,wCAAwC,EAAE;QAACoN;MAAK,CAAC,CAAC;IACzE;IAEA,IAAIA,KAAK,IAAIlC,MAAM,EAAE;MACnB,IAAI,OAAOA,MAAM,CAACkC,KAAK,CAAC,KAAK,QAAQ,EAAE;QACrC,MAAMpN,cAAc,CAClB,0CAA0C,EAC1C;UAACoN;QAAK,CACR,CAAC;MACH;MAEAlC,MAAM,CAACkC,KAAK,CAAC,IAAIrC,GAAG;IACtB,CAAC,MAAM;MACLG,MAAM,CAACkC,KAAK,CAAC,GAAG,CAAC;IACnB;EACF,CAAC;EACDO,OAAOA,CAACzC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAED,OAAO,EAAE3L,GAAG,EAAE;IACxC;IACA,IAAI2L,OAAO,KAAKC,GAAG,EAAE;MACnB,MAAM/K,cAAc,CAAC,wCAAwC,EAAE;QAACoN;MAAK,CAAC,CAAC;IACzE;IAEA,IAAIlC,MAAM,KAAK,IAAI,EAAE;MACnB,MAAMlL,cAAc,CAAC,8BAA8B,EAAE;QAACoN;MAAK,CAAC,CAAC;IAC/D;IAEA,IAAI,OAAOrC,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAM/K,cAAc,CAAC,iCAAiC,EAAE;QAACoN;MAAK,CAAC,CAAC;IAClE;IAEA,IAAIrC,GAAG,CAACpD,QAAQ,CAAC,IAAI,CAAC,EAAE;MACtB;MACA;MACA,MAAM3H,cAAc,CAClB,mEAAmE,EACnE;QAACoN;MAAK,CACR,CAAC;IACH;IAEA,IAAIlC,MAAM,KAAKnM,SAAS,EAAE;MACxB;IACF;IAEA,MAAM6O,MAAM,GAAG1C,MAAM,CAACkC,KAAK,CAAC;IAE5B,OAAOlC,MAAM,CAACkC,KAAK,CAAC;IAEpB,MAAMpC,QAAQ,GAAGD,GAAG,CAACrD,KAAK,CAAC,GAAG,CAAC;IAC/B,MAAMmG,OAAO,GAAG1C,aAAa,CAAChM,GAAG,EAAE6L,QAAQ,EAAE;MAACI,WAAW,EAAE;IAAI,CAAC,CAAC;IAEjE,IAAIyC,OAAO,KAAK,IAAI,EAAE;MACpB,MAAM7N,cAAc,CAAC,8BAA8B,EAAE;QAACoN;MAAK,CAAC,CAAC;IAC/D;IAEAS,OAAO,CAAC7C,QAAQ,CAACO,GAAG,CAAC,CAAC,CAAC,GAAGqC,MAAM;EAClC,CAAC;EACDlF,IAAIA,CAACwC,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB,IAAIG,MAAM,KAAKhN,MAAM,CAACgN,MAAM,CAAC,EAAE;MAAE;MAC/B,MAAM4C,KAAK,GAAG9N,cAAc,CAC1B,yCAAyC,EACzC;QAACoN;MAAK,CACR,CAAC;MACDU,KAAK,CAACC,gBAAgB,GAAG,IAAI;MAC7B,MAAMD,KAAK;IACb;IAEA,IAAI5C,MAAM,KAAK,IAAI,EAAE;MACnB,MAAM4C,KAAK,GAAG9N,cAAc,CAAC,6BAA6B,EAAE;QAACoN;MAAK,CAAC,CAAC;MACpEU,KAAK,CAACC,gBAAgB,GAAG,IAAI;MAC7B,MAAMD,KAAK;IACb;IAEAvO,wBAAwB,CAACwL,GAAG,CAAC;IAE7BG,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;EACrB,CAAC;EACDiD,YAAYA,CAAC9C,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IAC/B;EAAA,CACD;EACDkD,MAAMA,CAAC/C,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACzB,IAAIG,MAAM,KAAKnM,SAAS,EAAE;MACxB,IAAImM,MAAM,YAAY5H,KAAK,EAAE;QAC3B,IAAI8J,KAAK,IAAIlC,MAAM,EAAE;UACnBA,MAAM,CAACkC,KAAK,CAAC,GAAG,IAAI;QACtB;MACF,CAAC,MAAM;QACL,OAAOlC,MAAM,CAACkC,KAAK,CAAC;MACtB;IACF;EACF,CAAC;EACDc,KAAKA,CAAChD,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACxB,IAAIG,MAAM,CAACkC,KAAK,CAAC,KAAKrO,SAAS,EAAE;MAC/BmM,MAAM,CAACkC,KAAK,CAAC,GAAG,EAAE;IACpB;IAEA,IAAI,EAAElC,MAAM,CAACkC,KAAK,CAAC,YAAY9J,KAAK,CAAC,EAAE;MACrC,MAAMtD,cAAc,CAAC,0CAA0C,EAAE;QAACoN;MAAK,CAAC,CAAC;IAC3E;IAEA,IAAI,EAAErC,GAAG,IAAIA,GAAG,CAACoD,KAAK,CAAC,EAAE;MACvB;MACA5O,wBAAwB,CAACwL,GAAG,CAAC;MAE7BG,MAAM,CAACkC,KAAK,CAAC,CAAClM,IAAI,CAAC6J,GAAG,CAAC;MAEvB;IACF;;IAEA;IACA,MAAMqD,MAAM,GAAGrD,GAAG,CAACoD,KAAK;IACxB,IAAI,EAAEC,MAAM,YAAY9K,KAAK,CAAC,EAAE;MAC9B,MAAMtD,cAAc,CAAC,wBAAwB,EAAE;QAACoN;MAAK,CAAC,CAAC;IACzD;IAEA7N,wBAAwB,CAAC6O,MAAM,CAAC;;IAEhC;IACA,IAAIC,QAAQ,GAAGtP,SAAS;IACxB,IAAI,WAAW,IAAIgM,GAAG,EAAE;MACtB,IAAI,OAAOA,GAAG,CAACuD,SAAS,KAAK,QAAQ,EAAE;QACrC,MAAMtO,cAAc,CAAC,mCAAmC,EAAE;UAACoN;QAAK,CAAC,CAAC;MACpE;;MAEA;MACA,IAAIrC,GAAG,CAACuD,SAAS,GAAG,CAAC,EAAE;QACrB,MAAMtO,cAAc,CAClB,6CAA6C,EAC7C;UAACoN;QAAK,CACR,CAAC;MACH;MAEAiB,QAAQ,GAAGtD,GAAG,CAACuD,SAAS;IAC1B;;IAEA;IACA,IAAIC,KAAK,GAAGxP,SAAS;IACrB,IAAI,QAAQ,IAAIgM,GAAG,EAAE;MACnB,IAAI,OAAOA,GAAG,CAACyD,MAAM,KAAK,QAAQ,EAAE;QAClC,MAAMxO,cAAc,CAAC,gCAAgC,EAAE;UAACoN;QAAK,CAAC,CAAC;MACjE;;MAEA;MACAmB,KAAK,GAAGxD,GAAG,CAACyD,MAAM;IACpB;;IAEA;IACA,IAAIC,YAAY,GAAG1P,SAAS;IAC5B,IAAIgM,GAAG,CAAC2D,KAAK,EAAE;MACb,IAAIH,KAAK,KAAKxP,SAAS,EAAE;QACvB,MAAMiB,cAAc,CAAC,qCAAqC,EAAE;UAACoN;QAAK,CAAC,CAAC;MACtE;;MAEA;MACA;MACA;MACA;MACAqB,YAAY,GAAG,IAAI1M,SAAS,CAAC4M,MAAM,CAAC5D,GAAG,CAAC2D,KAAK,CAAC,CAAC1E,aAAa,CAAC,CAAC;MAE9DoE,MAAM,CAAC9N,OAAO,CAACsO,OAAO,IAAI;QACxB,IAAI5R,eAAe,CAACsN,EAAE,CAACC,KAAK,CAACqE,OAAO,CAAC,KAAK,CAAC,EAAE;UAC3C,MAAM5O,cAAc,CAClB,8DAA8D,GAC9D,SAAS,EACT;YAACoN;UAAK,CACR,CAAC;QACH;MACF,CAAC,CAAC;IACJ;;IAEA;IACA,IAAIiB,QAAQ,KAAKtP,SAAS,EAAE;MAC1BqP,MAAM,CAAC9N,OAAO,CAACsO,OAAO,IAAI;QACxB1D,MAAM,CAACkC,KAAK,CAAC,CAAClM,IAAI,CAAC0N,OAAO,CAAC;MAC7B,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,MAAMC,eAAe,GAAG,CAACR,QAAQ,EAAE,CAAC,CAAC;MAErCD,MAAM,CAAC9N,OAAO,CAACsO,OAAO,IAAI;QACxBC,eAAe,CAAC3N,IAAI,CAAC0N,OAAO,CAAC;MAC/B,CAAC,CAAC;MAEF1D,MAAM,CAACkC,KAAK,CAAC,CAAClD,MAAM,CAAC,GAAG2E,eAAe,CAAC;IAC1C;;IAEA;IACA,IAAIJ,YAAY,EAAE;MAChBvD,MAAM,CAACkC,KAAK,CAAC,CAAC0B,IAAI,CAACL,YAAY,CAAC;IAClC;;IAEA;IACA,IAAIF,KAAK,KAAKxP,SAAS,EAAE;MACvB,IAAIwP,KAAK,KAAK,CAAC,EAAE;QACfrD,MAAM,CAACkC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;MACtB,CAAC,MAAM,IAAImB,KAAK,GAAG,CAAC,EAAE;QACpBrD,MAAM,CAACkC,KAAK,CAAC,GAAGlC,MAAM,CAACkC,KAAK,CAAC,CAACmB,KAAK,CAACA,KAAK,CAAC;MAC5C,CAAC,MAAM;QACLrD,MAAM,CAACkC,KAAK,CAAC,GAAGlC,MAAM,CAACkC,KAAK,CAAC,CAACmB,KAAK,CAAC,CAAC,EAAEA,KAAK,CAAC;MAC/C;IACF;EACF,CAAC;EACDQ,QAAQA,CAAC7D,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IAC3B,IAAI,EAAE,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,YAAYzH,KAAK,CAAC,EAAE;MACtD,MAAMtD,cAAc,CAAC,mDAAmD,CAAC;IAC3E;IAEAT,wBAAwB,CAACwL,GAAG,CAAC;IAE7B,MAAMqD,MAAM,GAAGlD,MAAM,CAACkC,KAAK,CAAC;IAE5B,IAAIgB,MAAM,KAAKrP,SAAS,EAAE;MACxBmM,MAAM,CAACkC,KAAK,CAAC,GAAGrC,GAAG;IACrB,CAAC,MAAM,IAAI,EAAEqD,MAAM,YAAY9K,KAAK,CAAC,EAAE;MACrC,MAAMtD,cAAc,CAClB,6CAA6C,EAC7C;QAACoN;MAAK,CACR,CAAC;IACH,CAAC,MAAM;MACLgB,MAAM,CAAClN,IAAI,CAAC,GAAG6J,GAAG,CAAC;IACrB;EACF,CAAC;EACDiE,SAASA,CAAC9D,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IAC5B,IAAIkE,MAAM,GAAG,KAAK;IAElB,IAAI,OAAOlE,GAAG,KAAK,QAAQ,EAAE;MAC3B;MACA,MAAM1K,IAAI,GAAGnC,MAAM,CAACmC,IAAI,CAAC0K,GAAG,CAAC;MAC7B,IAAI1K,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;QACvB4O,MAAM,GAAG,IAAI;MACf;IACF;IAEA,MAAMC,MAAM,GAAGD,MAAM,GAAGlE,GAAG,CAACoD,KAAK,GAAG,CAACpD,GAAG,CAAC;IAEzCxL,wBAAwB,CAAC2P,MAAM,CAAC;IAEhC,MAAMC,KAAK,GAAGjE,MAAM,CAACkC,KAAK,CAAC;IAC3B,IAAI+B,KAAK,KAAKpQ,SAAS,EAAE;MACvBmM,MAAM,CAACkC,KAAK,CAAC,GAAG8B,MAAM;IACxB,CAAC,MAAM,IAAI,EAAEC,KAAK,YAAY7L,KAAK,CAAC,EAAE;MACpC,MAAMtD,cAAc,CAClB,8CAA8C,EAC9C;QAACoN;MAAK,CACR,CAAC;IACH,CAAC,MAAM;MACL8B,MAAM,CAAC5O,OAAO,CAAC2G,KAAK,IAAI;QACtB,IAAIkI,KAAK,CAAC1L,IAAI,CAACmL,OAAO,IAAI5R,eAAe,CAACsN,EAAE,CAAC8E,MAAM,CAACnI,KAAK,EAAE2H,OAAO,CAAC,CAAC,EAAE;UACpE;QACF;QAEAO,KAAK,CAACjO,IAAI,CAAC+F,KAAK,CAAC;MACnB,CAAC,CAAC;IACJ;EACF,CAAC;EACDoI,IAAIA,CAACnE,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB,IAAIG,MAAM,KAAKnM,SAAS,EAAE;MACxB;IACF;IAEA,MAAMuQ,KAAK,GAAGpE,MAAM,CAACkC,KAAK,CAAC;IAE3B,IAAIkC,KAAK,KAAKvQ,SAAS,EAAE;MACvB;IACF;IAEA,IAAI,EAAEuQ,KAAK,YAAYhM,KAAK,CAAC,EAAE;MAC7B,MAAMtD,cAAc,CAAC,yCAAyC,EAAE;QAACoN;MAAK,CAAC,CAAC;IAC1E;IAEA,IAAI,OAAOrC,GAAG,KAAK,QAAQ,IAAIA,GAAG,GAAG,CAAC,EAAE;MACtCuE,KAAK,CAACpF,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IACpB,CAAC,MAAM;MACLoF,KAAK,CAAC/D,GAAG,CAAC,CAAC;IACb;EACF,CAAC;EACDgE,KAAKA,CAACrE,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACxB,IAAIG,MAAM,KAAKnM,SAAS,EAAE;MACxB;IACF;IAEA,MAAMyQ,MAAM,GAAGtE,MAAM,CAACkC,KAAK,CAAC;IAC5B,IAAIoC,MAAM,KAAKzQ,SAAS,EAAE;MACxB;IACF;IAEA,IAAI,EAAEyQ,MAAM,YAAYlM,KAAK,CAAC,EAAE;MAC9B,MAAMtD,cAAc,CAClB,kDAAkD,EAClD;QAACoN;MAAK,CACR,CAAC;IACH;IAEA,IAAIqC,GAAG;IACP,IAAI1E,GAAG,IAAI,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,EAAEA,GAAG,YAAYzH,KAAK,CAAC,EAAE;MACrE;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA,MAAM3C,OAAO,GAAG,IAAIoB,SAAS,CAACC,OAAO,CAAC+I,GAAG,CAAC;MAE1C0E,GAAG,GAAGD,MAAM,CAACE,MAAM,CAACd,OAAO,IAAI,CAACjO,OAAO,CAACC,eAAe,CAACgO,OAAO,CAAC,CAAC/N,MAAM,CAAC;IAC1E,CAAC,MAAM;MACL4O,GAAG,GAAGD,MAAM,CAACE,MAAM,CAACd,OAAO,IAAI,CAAC5R,eAAe,CAACsN,EAAE,CAAC8E,MAAM,CAACR,OAAO,EAAE7D,GAAG,CAAC,CAAC;IAC1E;IAEAG,MAAM,CAACkC,KAAK,CAAC,GAAGqC,GAAG;EACrB,CAAC;EACDE,QAAQA,CAACzE,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IAC3B,IAAI,EAAE,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,YAAYzH,KAAK,CAAC,EAAE;MACtD,MAAMtD,cAAc,CAClB,mDAAmD,EACnD;QAACoN;MAAK,CACR,CAAC;IACH;IAEA,IAAIlC,MAAM,KAAKnM,SAAS,EAAE;MACxB;IACF;IAEA,MAAMyQ,MAAM,GAAGtE,MAAM,CAACkC,KAAK,CAAC;IAE5B,IAAIoC,MAAM,KAAKzQ,SAAS,EAAE;MACxB;IACF;IAEA,IAAI,EAAEyQ,MAAM,YAAYlM,KAAK,CAAC,EAAE;MAC9B,MAAMtD,cAAc,CAClB,kDAAkD,EAClD;QAACoN;MAAK,CACR,CAAC;IACH;IAEAlC,MAAM,CAACkC,KAAK,CAAC,GAAGoC,MAAM,CAACE,MAAM,CAAC9B,MAAM,IAClC,CAAC7C,GAAG,CAACtH,IAAI,CAACmL,OAAO,IAAI5R,eAAe,CAACsN,EAAE,CAAC8E,MAAM,CAACxB,MAAM,EAAEgB,OAAO,CAAC,CACjE,CAAC;EACH,CAAC;EACDgB,IAAIA,CAAC1E,MAAM,EAAEkC,KAAK,EAAErC,GAAG,EAAE;IACvB;IACA;IACA,MAAM/K,cAAc,CAAC,uBAAuB,EAAE;MAACoN;IAAK,CAAC,CAAC;EACxD,CAAC;EACDyC,EAAEA,CAAA,EAAG;IACH;IACA;IACA;IACA;EAAA;AAEJ,CAAC;AAED,MAAMvE,mBAAmB,GAAG;EAC1B+D,IAAI,EAAE,IAAI;EACVE,KAAK,EAAE,IAAI;EACXI,QAAQ,EAAE,IAAI;EACdhC,OAAO,EAAE,IAAI;EACbM,MAAM,EAAE;AACV,CAAC;;AAED;AACA;AACA;AACA,MAAM6B,cAAc,GAAG;EACrBC,CAAC,EAAE,kBAAkB;EACrB,GAAG,EAAE,eAAe;EACpB,IAAI,EAAE;AACR,CAAC;;AAED;AACA,SAASxQ,wBAAwBA,CAACJ,GAAG,EAAE;EACrC,IAAIA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAClC6Q,IAAI,CAACC,SAAS,CAAC9Q,GAAG,EAAE,CAACyI,GAAG,EAAEX,KAAK,KAAK;MAClCiJ,sBAAsB,CAACtI,GAAG,CAAC;MAC3B,OAAOX,KAAK;IACd,CAAC,CAAC;EACJ;AACF;AAEA,SAASiJ,sBAAsBA,CAACtI,GAAG,EAAE;EACnC,IAAIuI,KAAK;EACT,IAAI,OAAOvI,GAAG,KAAK,QAAQ,KAAKuI,KAAK,GAAGvI,GAAG,CAACuI,KAAK,CAAC,WAAW,CAAC,CAAC,EAAE;IAC/D,MAAMnQ,cAAc,QAAAC,MAAA,CAAQ2H,GAAG,gBAAA3H,MAAA,CAAa6P,cAAc,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC;EACzE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShF,aAAaA,CAAChM,GAAG,EAAE6L,QAAQ,EAAgB;EAAA,IAAdxM,OAAO,GAAAI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAG,SAAA,GAAAH,SAAA,MAAG,CAAC,CAAC;EAChD,IAAIwR,cAAc,GAAG,KAAK;EAE1B,KAAK,IAAIjO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6I,QAAQ,CAACnM,MAAM,EAAEsD,CAAC,EAAE,EAAE;IACxC,MAAMkO,IAAI,GAAGlO,CAAC,KAAK6I,QAAQ,CAACnM,MAAM,GAAG,CAAC;IACtC,IAAIyR,OAAO,GAAGtF,QAAQ,CAAC7I,CAAC,CAAC;IAEzB,IAAI,CAAC/E,WAAW,CAAC+B,GAAG,CAAC,EAAE;MACrB,IAAIX,OAAO,CAAC6M,QAAQ,EAAE;QACpB,OAAOtM,SAAS;MAClB;MAEA,MAAM+O,KAAK,GAAG9N,cAAc,yBAAAC,MAAA,CACFqQ,OAAO,oBAAArQ,MAAA,CAAiBd,GAAG,CACrD,CAAC;MACD2O,KAAK,CAACC,gBAAgB,GAAG,IAAI;MAC7B,MAAMD,KAAK;IACb;IAEA,IAAI3O,GAAG,YAAYmE,KAAK,EAAE;MACxB,IAAI9E,OAAO,CAAC4M,WAAW,EAAE;QACvB,OAAO,IAAI;MACb;MAEA,IAAIkF,OAAO,KAAK,GAAG,EAAE;QACnB,IAAIF,cAAc,EAAE;UAClB,MAAMpQ,cAAc,CAAC,2CAA2C,CAAC;QACnE;QAEA,IAAI,CAACxB,OAAO,CAACuF,YAAY,IAAI,CAACvF,OAAO,CAACuF,YAAY,CAAClF,MAAM,EAAE;UACzD,MAAMmB,cAAc,CAClB,iEAAiE,GACjE,OACF,CAAC;QACH;QAEAsQ,OAAO,GAAG9R,OAAO,CAACuF,YAAY,CAAC,CAAC,CAAC;QACjCqM,cAAc,GAAG,IAAI;MACvB,CAAC,MAAM,IAAI/S,YAAY,CAACiT,OAAO,CAAC,EAAE;QAChCA,OAAO,GAAGC,QAAQ,CAACD,OAAO,CAAC;MAC7B,CAAC,MAAM;QACL,IAAI9R,OAAO,CAAC6M,QAAQ,EAAE;UACpB,OAAOtM,SAAS;QAClB;QAEA,MAAMiB,cAAc,mDAAAC,MAAA,CACgCqQ,OAAO,MAC3D,CAAC;MACH;MAEA,IAAID,IAAI,EAAE;QACRrF,QAAQ,CAAC7I,CAAC,CAAC,GAAGmO,OAAO,CAAC,CAAC;MACzB;MAEA,IAAI9R,OAAO,CAAC6M,QAAQ,IAAIiF,OAAO,IAAInR,GAAG,CAACN,MAAM,EAAE;QAC7C,OAAOE,SAAS;MAClB;MAEA,OAAOI,GAAG,CAACN,MAAM,GAAGyR,OAAO,EAAE;QAC3BnR,GAAG,CAAC+B,IAAI,CAAC,IAAI,CAAC;MAChB;MAEA,IAAI,CAACmP,IAAI,EAAE;QACT,IAAIlR,GAAG,CAACN,MAAM,KAAKyR,OAAO,EAAE;UAC1BnR,GAAG,CAAC+B,IAAI,CAAC,CAAC,CAAC,CAAC;QACd,CAAC,MAAM,IAAI,OAAO/B,GAAG,CAACmR,OAAO,CAAC,KAAK,QAAQ,EAAE;UAC3C,MAAMtQ,cAAc,CAClB,uBAAAC,MAAA,CAAuB+K,QAAQ,CAAC7I,CAAC,GAAG,CAAC,CAAC,wBACtC6N,IAAI,CAACC,SAAS,CAAC9Q,GAAG,CAACmR,OAAO,CAAC,CAC7B,CAAC;QACH;MACF;IACF,CAAC,MAAM;MACLJ,sBAAsB,CAACI,OAAO,CAAC;MAE/B,IAAI,EAAEA,OAAO,IAAInR,GAAG,CAAC,EAAE;QACrB,IAAIX,OAAO,CAAC6M,QAAQ,EAAE;UACpB,OAAOtM,SAAS;QAClB;QAEA,IAAI,CAACsR,IAAI,EAAE;UACTlR,GAAG,CAACmR,OAAO,CAAC,GAAG,CAAC,CAAC;QACnB;MACF;IACF;IAEA,IAAID,IAAI,EAAE;MACR,OAAOlR,GAAG;IACZ;IAEAA,GAAG,GAAGA,GAAG,CAACmR,OAAO,CAAC;EACpB;;EAEA;AACF"},"sourceType":"module","externalDependencies":{},"hash":"f6f493f2d635af9f2af7e518e4c0f2400894b689"}
