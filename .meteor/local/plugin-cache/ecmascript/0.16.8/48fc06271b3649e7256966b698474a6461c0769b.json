{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/oplog_observe_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/mongo/oplog_observe_driver.js","filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/oplog_observe_driver.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/nicholas/Desktop/projects/local-legends/styles","root":"/Users/nicholas/Desktop/projects/local-legends/styles","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/nicholas/Desktop/projects/local-legends/styles/packages/mongo/oplog_observe_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_observe_driver.js"}},"code":"let oplogV2V1Converter;\nmodule.link(\"./oplog_v2_converter\", {\n  oplogV2V1Converter(v) {\n    oplogV2V1Converter = v;\n  }\n}, 0);\nvar Future = Npm.require('fibers/future');\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function () {};\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery)) throw e;\n    }\n  };\n};\nvar currentId = 0;\n\n// OplogObserveDriver is an alternative to PollingObserveDriver which follows\n// the Mongo operation log instead of just re-polling the query. It obeys the\n// same simple interface: constructing it starts sending observeChanges\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop\n// it by calling the stop() method.\nOplogObserveDriver = function (options) {\n  var self = this;\n  self._usesOplog = true; // tests look at this\n\n  self._id = currentId;\n  currentId++;\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n  var sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  var comparator = sorter && sorter.getComparator();\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Max Heap (also implements IdMap methods)\n\n    var heapOptions = {\n      IdMap: LocalCollection._IdMap\n    };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    self._published = new LocalCollection._IdMap();\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n  self._stopped = false;\n  self._stopHandles = [];\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", 1);\n  self._registerPhaseChange(PHASE.QUERYING);\n  self._matcher = options.matcher;\n  // we are now using projection, not fields in the cursor description even if you pass {fields}\n  // in the cursor construction\n  var projection = self._cursorDescription.options.fields || self._cursorDescription.options.projection || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter) self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(self._sharedProjection);\n  self._needToFetch = new LocalCollection._IdMap();\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n\n  // If the oplog handle tells us that it skipped some entries (because it got\n  // behind, say), re-poll.\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(finishIfNeedToPollQuery(function () {\n    self._needToPollQuery();\n  })));\n  forEachTrigger(self._cursorDescription, function (trigger) {\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(trigger, function (notification) {\n      Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n        var op = notification.op;\n        if (notification.dropCollection || notification.dropDatabase) {\n          // Note: this call is not allowed to block on anything (especially\n          // on waiting for oplog entries to catch up) because that will block\n          // onOplogEntry!\n          self._needToPollQuery();\n        } else {\n          // All other operators should be handled depending on phase\n          if (self._phase === PHASE.QUERYING) {\n            self._handleOplogEntryQuerying(op);\n          } else {\n            self._handleOplogEntrySteadyOrFetching(op);\n          }\n        }\n      }));\n    }));\n  });\n\n  // XXX ordering w.r.t. everything else?\n  self._stopHandles.push(listenAll(self._cursorDescription, function (notification) {\n    // If we're not in a pre-fire write fence, we don't have to do anything.\n    var fence = DDPServer._CurrentWriteFence.get();\n    if (!fence || fence.fired) return;\n    if (fence._oplogObserveDrivers) {\n      fence._oplogObserveDrivers[self._id] = self;\n      return;\n    }\n    fence._oplogObserveDrivers = {};\n    fence._oplogObserveDrivers[self._id] = self;\n    fence.onBeforeFire(function () {\n      var drivers = fence._oplogObserveDrivers;\n      delete fence._oplogObserveDrivers;\n\n      // This fence cannot fire until we've caught up to \"this point\" in the\n      // oplog, and all observers made it back to the steady state.\n      self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n      _.each(drivers, function (driver) {\n        if (driver._stopped) return;\n        var write = fence.beginWrite();\n        if (driver._phase === PHASE.STEADY) {\n          // Make sure that all of the callbacks have made it through the\n          // multiplexer and been delivered to ObserveHandles before committing\n          // writes.\n          driver._multiplexer.onFlush(function () {\n            write.committed();\n          });\n        } else {\n          driver._writesToCommitWhenWeReachSteady.push(write);\n        }\n      });\n    });\n  }));\n\n  // When Mongo fails over, we need to repoll the query, in case we processed an\n  // oplog entry that got rolled back.\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(function () {\n    self._needToPollQuery();\n  })));\n\n  // Give _observeChanges a chance to add the new ObserveHandle to our\n  // multiplexer, so that the added calls get streamed.\n  Meteor.defer(finishIfNeedToPollQuery(function () {\n    self._runInitialQuery();\n  }));\n};\n_.extend(OplogObserveDriver.prototype, {\n  _addPublished: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var fields = _.clone(doc);\n      delete fields._id;\n      self._published.set(id, self._sharedProjectionFn(doc));\n      self._multiplexer.added(id, self._projectionFn(fields));\n\n      // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" + (self._published.size() - self._limit) + \" documents are overflowing the set\");\n        }\n        var overflowingDocId = self._published.maxElementId();\n        var overflowingDoc = self._published.get(overflowingDocId);\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n        self._published.remove(overflowingDocId);\n        self._multiplexer.removed(overflowingDocId);\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n      self._multiplexer.removed(id);\n      if (!self._limit || self._published.size() === self._limit) return;\n      if (self._published.size() > self._limit) throw Error(\"self._published got too big\");\n\n      // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n        self._removeBuffered(newDocId);\n        self._addPublished(newDocId, newDoc);\n        return;\n      }\n\n      // There's nothing in the buffer.  This could mean one of a few things.\n\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n      if (self._phase === PHASE.QUERYING) return;\n\n      // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n      if (self._safeAppendToBuffer) return;\n\n      // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n      var projectedNew = self._projectionFn(newDoc);\n      var projectedOld = self._projectionFn(oldDoc);\n      var changed = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n      if (!_.isEmpty(changed)) self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n      // If something is overflowing the buffer, we just remove it from cache\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n        self._unpublishedBuffer.remove(maxBufferedId);\n\n        // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id);\n      // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n      if (!self._unpublishedBuffer.size() && !self._safeAppendToBuffer) self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id)) throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id)) throw Error(\"tried to add something already existed in buffer \" + id);\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = limit && self._published.size() > 0 ? self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = limit && self._unpublishedBuffer.size() > 0 ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()) : null;\n      // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n      var toPublish = !limit || self._published.size() < limit || comparator(doc, maxPublished) < 0;\n\n      // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer && self._unpublishedBuffer.size() < limit;\n\n      // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n      var canInsertIntoBuffer = !toPublish && maxBuffered && comparator(doc, maxBuffered) <= 0;\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (!self._published.has(id) && !self._limit) throw Error(\"tried to remove something matching but not cached \" + id);\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n      var publishedBefore = self._published.has(id);\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n      var cachedBefore = publishedBefore || bufferedBefore;\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n        var comparator = self._comparator;\n        var minBuffered = self._limit && self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n        var maxBuffered;\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = !self._limit || self._unpublishedBuffer.size() === 0 || comparator(newDoc, minBuffered) <= 0;\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id);\n            // but it can move into buffered now, check it\n            maxBuffered = self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n            var toBuffer = self._safeAppendToBuffer || maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id);\n          // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n          self._unpublishedBuffer.remove(id);\n          var maxPublished = self._published.get(self._published.maxElementId());\n          maxBuffered = self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n\n          // the buffered doc was updated, it could move to published\n          var toPublish = comparator(newDoc, maxPublished) < 0;\n\n          // or stays in buffer even after the change\n          var staysInBuffer = !toPublish && self._safeAppendToBuffer || !toPublish && maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false;\n            // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n            if (!self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.FETCHING);\n      // Defer, because nothing called from the oplog entry handler may yield,\n      // but fetch() yields.\n      Meteor.defer(finishIfNeedToPollQuery(function () {\n        while (!self._stopped && !self._needToFetch.empty()) {\n          if (self._phase === PHASE.QUERYING) {\n            // While fetching, we decided to go into QUERYING mode, and then we\n            // saw another oplog entry, so _needToFetch is not empty. But we\n            // shouldn't fetch these documents until AFTER the query is done.\n            break;\n          }\n\n          // Being in steady phase here would be surprising.\n          if (self._phase !== PHASE.FETCHING) throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n          self._currentlyFetching = self._needToFetch;\n          var thisGeneration = ++self._fetchGeneration;\n          self._needToFetch = new LocalCollection._IdMap();\n          var waiting = 0;\n          var fut = new Future();\n          // This loop is safe, because _currentlyFetching will not be updated\n          // during this loop (in fact, it is never mutated).\n          self._currentlyFetching.forEach(function (op, id) {\n            waiting++;\n            self._mongoHandle._docFetcher.fetch(self._cursorDescription.collectionName, id, op, finishIfNeedToPollQuery(function (err, doc) {\n              try {\n                if (err) {\n                  Meteor._debug(\"Got exception while fetching documents\", err);\n                  // If we get an error from the fetcher (eg, trouble\n                  // connecting to Mongo), let's just abandon the fetch phase\n                  // altogether and fall back to polling. It's not like we're\n                  // getting live updates anyway.\n                  if (self._phase !== PHASE.QUERYING) {\n                    self._needToPollQuery();\n                  }\n                } else if (!self._stopped && self._phase === PHASE.FETCHING && self._fetchGeneration === thisGeneration) {\n                  // We re-check the generation in case we've had an explicit\n                  // _pollQuery call (eg, in another fiber) which should\n                  // effectively cancel this round of fetches.  (_pollQuery\n                  // increments the generation.)\n                  self._handleDoc(id, doc);\n                }\n              } finally {\n                waiting--;\n                // Because fetch() never calls its callback synchronously,\n                // this is safe (ie, we won't call fut.return() before the\n                // forEach is done).\n                if (waiting === 0) fut.return();\n              }\n            }));\n          });\n          fut.wait();\n          // Exit now if we've had a _pollQuery call (here or in another fiber).\n          if (self._phase === PHASE.QUERYING) return;\n          self._currentlyFetching = null;\n        }\n        // We're done fetching, so we can be steady, unless we've had a\n        // _pollQuery call (here or in another fiber).\n        if (self._phase !== PHASE.QUERYING) self._beSteady();\n      }));\n    });\n  },\n  _beSteady: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.STEADY);\n      var writes = self._writesToCommitWhenWeReachSteady;\n      self._writesToCommitWhenWeReachSteady = [];\n      self._multiplexer.onFlush(function () {\n        _.each(writes, function (w) {\n          w.committed();\n        });\n      });\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op);\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op);\n      // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n      if (self._phase === PHASE.FETCHING && (self._currentlyFetching && self._currentlyFetching.has(id) || self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op);\n        return;\n      }\n      if (op.op === 'd') {\n        if (self._published.has(id) || self._limit && self._unpublishedBuffer.has(id)) self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id)) throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id)) throw new Error(\"insert found for already-existing ID in buffer\");\n\n        // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n        if (self._matcher.documentMatches(op.o).result) self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // we are mapping the new oplog format on mongo 5\n        // to what we know better, $set\n        op.o = oplogV2V1Converter(op.o);\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        // oplog format has changed on mongodb 5, we have to support both now\n        // diff is the format in Mongo 5+ (oplog v2)\n        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, 'diff') && !_.has(op.o, '$unset');\n        // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n        var canDirectlyModifyDoc = !isReplace && modifierCanBeDirectlyApplied(op.o);\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n        if (isReplace) {\n          self._handleDoc(id, _.extend({\n            _id: id\n          }, op.o));\n        } else if ((publishedBefore || bufferedBefore) && canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id) ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n          newDoc._id = id;\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\") throw e;\n            // We didn't understand the modifier.  Re-fetch.\n            self._needToFetch.set(id, op);\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n            return;\n          }\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc || self._matcher.canBecomeTrueByModifier(op.o) || self._sorter && self._sorter.affectedByModifier(op.o)) {\n          self._needToFetch.set(id, op);\n          if (self._phase === PHASE.STEADY) self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n  // Yields!\n  _runInitialQuery: function () {\n    var self = this;\n    if (self._stopped) throw new Error(\"oplog stopped surprisingly early\");\n    self._runQuery({\n      initial: true\n    }); // yields\n\n    if (self._stopped) return; // can happen on queryError\n\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n    self._multiplexer.ready();\n    self._doneQuerying(); // yields\n  },\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped) return;\n\n      // Yay, we get to forget about all the things we thought we had to fetch.\n      self._needToFetch = new LocalCollection._IdMap();\n      self._currentlyFetching = null;\n      ++self._fetchGeneration; // ignore any in-flight fetches\n      self._registerPhaseChange(PHASE.QUERYING);\n\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n      Meteor.defer(function () {\n        self._runQuery();\n        self._doneQuerying();\n      });\n    });\n  },\n  // Yields!\n  _runQuery: function (options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer;\n\n    // This while loop is just to retry failures.\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped) return;\n      newResults = new LocalCollection._IdMap();\n      newBuffer = new LocalCollection._IdMap();\n\n      // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n      var cursor = self._cursorForQuery({\n        limit: self._limit * 2\n      });\n      try {\n        cursor.forEach(function (doc, i) {\n          // yields\n          if (!self._limit || i < self._limit) {\n            newResults.set(doc._id, doc);\n          } else {\n            newBuffer.set(doc._id, doc);\n          }\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof e.code === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          self._multiplexer.queryError(e);\n          return;\n        }\n\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while polling query\", e);\n        Meteor._sleepForMs(100);\n      }\n    }\n    if (self._stopped) return;\n    self._publishNewResults(newResults, newBuffer);\n  },\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped) return;\n\n      // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n        throw new SwitchedToQuery();\n      }\n\n      // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n  // Yields!\n  _doneQuerying: function () {\n    var self = this;\n    if (self._stopped) return;\n    self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // yields\n    if (self._stopped) return;\n    if (self._phase !== PHASE.QUERYING) throw Error(\"Phase unexpectedly \" + self._phase);\n    Meteor._noYieldsAllowed(function () {\n      if (self._requeryWhenDoneThisQuery) {\n        self._requeryWhenDoneThisQuery = false;\n        self._pollQuery();\n      } else if (self._needToFetch.empty()) {\n        self._beSteady();\n      } else {\n        self._fetchModifiedDocuments();\n      }\n    });\n  },\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = _.clone(self._cursorDescription.options);\n\n      // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n      _.extend(options, optionsOverwrite);\n      options.fields = self._sharedProjection;\n      delete options.transform;\n      // We are NOT deep cloning fields or selector here, which should be OK.\n      var description = new CursorDescription(self._cursorDescription.collectionName, self._cursorDescription.selector, options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      }\n\n      // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n      var idsToRemove = [];\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id)) idsToRemove.push(id);\n      });\n      _.each(idsToRemove, function (id) {\n        self._removePublished(id);\n      });\n\n      // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      });\n\n      // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n      if (self._published.size() !== newResults.size()) {\n        Meteor._debug('The Mongo server and the Meteor query disagree on how ' + 'many documents match your query. Cursor description: ', self._cursorDescription);\n      }\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id)) throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      });\n\n      // Finally, replace the buffer\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  stop: function () {\n    var self = this;\n    if (self._stopped) return;\n    self._stopped = true;\n    _.each(self._stopHandles, function (handle) {\n      handle.stop();\n    });\n\n    // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n    _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n      w.committed(); // maybe yields?\n    });\n    self._writesToCommitWhenWeReachSteady = null;\n\n    // Proactively drop references to potentially big things.\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", -1);\n  },\n  _registerPhaseChange: function (phase) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date();\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog) return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || options.limit && !options.sort) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  const fields = options.fields || options.projection;\n  if (fields) {\n    try {\n      LocalCollection._checkSupportedProjection(fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return _.all(modifier, function (fields, operation) {\n    return _.all(fields, function (value, field) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};\nMongoInternals.OplogObserveDriver = OplogObserveDriver;","map":{"version":3,"names":["oplogV2V1Converter","module","link","v","Future","Npm","require","PHASE","QUERYING","FETCHING","STEADY","SwitchedToQuery","finishIfNeedToPollQuery","f","apply","arguments","e","currentId","OplogObserveDriver","options","self","_usesOplog","_id","_cursorDescription","cursorDescription","_mongoHandle","mongoHandle","_multiplexer","multiplexer","ordered","Error","sorter","comparator","getComparator","limit","heapOptions","IdMap","LocalCollection","_IdMap","_limit","_comparator","_sorter","_unpublishedBuffer","MinMaxHeap","_published","MaxHeap","_safeAppendToBuffer","_stopped","_stopHandles","Package","Facts","incrementServerFact","_registerPhaseChange","_matcher","matcher","projection","fields","_projectionFn","_compileProjection","_sharedProjection","combineIntoProjection","_sharedProjectionFn","_needToFetch","_currentlyFetching","_fetchGeneration","_requeryWhenDoneThisQuery","_writesToCommitWhenWeReachSteady","push","_oplogHandle","onSkippedEntries","_needToPollQuery","forEachTrigger","trigger","onOplogEntry","notification","Meteor","_noYieldsAllowed","op","dropCollection","dropDatabase","_phase","_handleOplogEntryQuerying","_handleOplogEntrySteadyOrFetching","listenAll","fence","DDPServer","_CurrentWriteFence","get","fired","_oplogObserveDrivers","onBeforeFire","drivers","waitUntilCaughtUp","_","each","driver","write","beginWrite","onFlush","committed","_onFailover","defer","_runInitialQuery","extend","prototype","_addPublished","id","doc","clone","set","added","size","overflowingDocId","maxElementId","overflowingDoc","EJSON","equals","remove","removed","_addBuffered","_removePublished","empty","newDocId","minElementId","newDoc","_removeBuffered","_changePublished","oldDoc","projectedNew","projectedOld","changed","DiffSequence","makeChangedFields","isEmpty","maxBufferedId","_addMatching","has","maxPublished","maxBuffered","toPublish","canAppendToBuffer","canInsertIntoBuffer","toBuffer","_removeMatching","_handleDoc","matchesNow","documentMatches","result","publishedBefore","bufferedBefore","cachedBefore","minBuffered","staysInPublished","staysInBuffer","_fetchModifiedDocuments","thisGeneration","waiting","fut","forEach","_docFetcher","fetch","collectionName","err","_debug","return","wait","_beSteady","writes","w","idForOp","o","isReplace","canDirectlyModifyDoc","modifierCanBeDirectlyApplied","_modify","name","canBecomeTrueByModifier","affectedByModifier","_runQuery","initial","ready","_doneQuerying","_pollQuery","newResults","newBuffer","cursor","_cursorForQuery","i","code","queryError","_sleepForMs","_publishNewResults","optionsOverwrite","transform","description","CursorDescription","selector","Cursor","clear","idsToRemove","stop","handle","_oplogEntryHandle","_listenersHandle","phase","now","Date","timeDiff","_phaseStartTime","cursorSupported","disableOplog","_disableOplog","skip","sort","_checkSupportedProjection","hasWhere","hasGeoQuery","modifier","all","operation","value","field","test","MongoInternals"],"sources":["packages/mongo/oplog_observe_driver.js"],"sourcesContent":["import { oplogV2V1Converter } from \"./oplog_v2_converter\";\n\nvar Future = Npm.require('fibers/future');\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function () {};\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery))\n        throw e;\n    }\n  };\n};\n\nvar currentId = 0;\n\n// OplogObserveDriver is an alternative to PollingObserveDriver which follows\n// the Mongo operation log instead of just re-polling the query. It obeys the\n// same simple interface: constructing it starts sending observeChanges\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop\n// it by calling the stop() method.\nOplogObserveDriver = function (options) {\n  var self = this;\n  self._usesOplog = true;  // tests look at this\n\n  self._id = currentId;\n  currentId++;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  var sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  var comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Max Heap (also implements IdMap methods)\n\n    var heapOptions = { IdMap: LocalCollection._IdMap };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    self._published = new LocalCollection._IdMap;\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n\n  self._stopped = false;\n  self._stopHandles = [];\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  self._matcher = options.matcher;\n  // we are now using projection, not fields in the cursor description even if you pass {fields}\n  // in the cursor construction\n  var projection = self._cursorDescription.options.fields || self._cursorDescription.options.projection || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter)\n    self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(\n    self._sharedProjection);\n\n  self._needToFetch = new LocalCollection._IdMap;\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n\n  // If the oplog handle tells us that it skipped some entries (because it got\n  // behind, say), re-poll.\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(\n    finishIfNeedToPollQuery(function () {\n      self._needToPollQuery();\n    })\n  ));\n\n  forEachTrigger(self._cursorDescription, function (trigger) {\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(\n      trigger, function (notification) {\n        Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n          var op = notification.op;\n          if (notification.dropCollection || notification.dropDatabase) {\n            // Note: this call is not allowed to block on anything (especially\n            // on waiting for oplog entries to catch up) because that will block\n            // onOplogEntry!\n            self._needToPollQuery();\n          } else {\n            // All other operators should be handled depending on phase\n            if (self._phase === PHASE.QUERYING) {\n              self._handleOplogEntryQuerying(op);\n            } else {\n              self._handleOplogEntrySteadyOrFetching(op);\n            }\n          }\n        }));\n      }\n    ));\n  });\n\n  // XXX ordering w.r.t. everything else?\n  self._stopHandles.push(listenAll(\n    self._cursorDescription, function (notification) {\n      // If we're not in a pre-fire write fence, we don't have to do anything.\n      var fence = DDPServer._CurrentWriteFence.get();\n      if (!fence || fence.fired)\n        return;\n\n      if (fence._oplogObserveDrivers) {\n        fence._oplogObserveDrivers[self._id] = self;\n        return;\n      }\n\n      fence._oplogObserveDrivers = {};\n      fence._oplogObserveDrivers[self._id] = self;\n\n      fence.onBeforeFire(function () {\n        var drivers = fence._oplogObserveDrivers;\n        delete fence._oplogObserveDrivers;\n\n        // This fence cannot fire until we've caught up to \"this point\" in the\n        // oplog, and all observers made it back to the steady state.\n        self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n        _.each(drivers, function (driver) {\n          if (driver._stopped)\n            return;\n\n          var write = fence.beginWrite();\n          if (driver._phase === PHASE.STEADY) {\n            // Make sure that all of the callbacks have made it through the\n            // multiplexer and been delivered to ObserveHandles before committing\n            // writes.\n            driver._multiplexer.onFlush(function () {\n              write.committed();\n            });\n          } else {\n            driver._writesToCommitWhenWeReachSteady.push(write);\n          }\n        });\n      });\n    }\n  ));\n\n  // When Mongo fails over, we need to repoll the query, in case we processed an\n  // oplog entry that got rolled back.\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(\n    function () {\n      self._needToPollQuery();\n    })));\n\n  // Give _observeChanges a chance to add the new ObserveHandle to our\n  // multiplexer, so that the added calls get streamed.\n  Meteor.defer(finishIfNeedToPollQuery(function () {\n    self._runInitialQuery();\n  }));\n};\n\n_.extend(OplogObserveDriver.prototype, {\n  _addPublished: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var fields = _.clone(doc);\n      delete fields._id;\n      self._published.set(id, self._sharedProjectionFn(doc));\n      self._multiplexer.added(id, self._projectionFn(fields));\n\n      // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" +\n                          (self._published.size() - self._limit) +\n                          \" documents are overflowing the set\");\n        }\n\n        var overflowingDocId = self._published.maxElementId();\n        var overflowingDoc = self._published.get(overflowingDocId);\n\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n\n        self._published.remove(overflowingDocId);\n        self._multiplexer.removed(overflowingDocId);\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n      self._multiplexer.removed(id);\n      if (! self._limit || self._published.size() === self._limit)\n        return;\n\n      if (self._published.size() > self._limit)\n        throw Error(\"self._published got too big\");\n\n      // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n        self._removeBuffered(newDocId);\n        self._addPublished(newDocId, newDoc);\n        return;\n      }\n\n      // There's nothing in the buffer.  This could mean one of a few things.\n\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n      if (self._phase === PHASE.QUERYING)\n        return;\n\n      // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n      if (self._safeAppendToBuffer)\n        return;\n\n      // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n      var projectedNew = self._projectionFn(newDoc);\n      var projectedOld = self._projectionFn(oldDoc);\n      var changed = DiffSequence.makeChangedFields(\n        projectedNew, projectedOld);\n      if (!_.isEmpty(changed))\n        self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n      // If something is overflowing the buffer, we just remove it from cache\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n        self._unpublishedBuffer.remove(maxBufferedId);\n\n        // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id);\n      // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n      if (! self._unpublishedBuffer.size() && ! self._safeAppendToBuffer)\n        self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id))\n        throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id))\n        throw Error(\"tried to add something already existed in buffer \" + id);\n\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = (limit && self._published.size() > 0) ?\n        self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = (limit && self._unpublishedBuffer.size() > 0)\n        ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId())\n        : null;\n      // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n      var toPublish = ! limit || self._published.size() < limit ||\n        comparator(doc, maxPublished) < 0;\n\n      // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer &&\n        self._unpublishedBuffer.size() < limit;\n\n      // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n      var canInsertIntoBuffer = !toPublish && maxBuffered &&\n        comparator(doc, maxBuffered) <= 0;\n\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (! self._published.has(id) && ! self._limit)\n        throw Error(\"tried to remove something matching but not cached \" + id);\n\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n      var publishedBefore = self._published.has(id);\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n      var cachedBefore = publishedBefore || bufferedBefore;\n\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n        var comparator = self._comparator;\n        var minBuffered = self._limit && self._unpublishedBuffer.size() &&\n          self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n        var maxBuffered;\n\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = ! self._limit ||\n            self._unpublishedBuffer.size() === 0 ||\n            comparator(newDoc, minBuffered) <= 0;\n\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id);\n            // but it can move into buffered now, check it\n            maxBuffered = self._unpublishedBuffer.get(\n              self._unpublishedBuffer.maxElementId());\n\n            var toBuffer = self._safeAppendToBuffer ||\n                  (maxBuffered && comparator(newDoc, maxBuffered) <= 0);\n\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id);\n          // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n          self._unpublishedBuffer.remove(id);\n\n          var maxPublished = self._published.get(\n            self._published.maxElementId());\n          maxBuffered = self._unpublishedBuffer.size() &&\n                self._unpublishedBuffer.get(\n                  self._unpublishedBuffer.maxElementId());\n\n          // the buffered doc was updated, it could move to published\n          var toPublish = comparator(newDoc, maxPublished) < 0;\n\n          // or stays in buffer even after the change\n          var staysInBuffer = (! toPublish && self._safeAppendToBuffer) ||\n                (!toPublish && maxBuffered &&\n                 comparator(newDoc, maxBuffered) <= 0);\n\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false;\n            // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n            if (! self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.FETCHING);\n      // Defer, because nothing called from the oplog entry handler may yield,\n      // but fetch() yields.\n      Meteor.defer(finishIfNeedToPollQuery(function () {\n        while (!self._stopped && !self._needToFetch.empty()) {\n          if (self._phase === PHASE.QUERYING) {\n            // While fetching, we decided to go into QUERYING mode, and then we\n            // saw another oplog entry, so _needToFetch is not empty. But we\n            // shouldn't fetch these documents until AFTER the query is done.\n            break;\n          }\n\n          // Being in steady phase here would be surprising.\n          if (self._phase !== PHASE.FETCHING)\n            throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n\n          self._currentlyFetching = self._needToFetch;\n          var thisGeneration = ++self._fetchGeneration;\n          self._needToFetch = new LocalCollection._IdMap;\n          var waiting = 0;\n          var fut = new Future;\n          // This loop is safe, because _currentlyFetching will not be updated\n          // during this loop (in fact, it is never mutated).\n          self._currentlyFetching.forEach(function (op, id) {\n            waiting++;\n            self._mongoHandle._docFetcher.fetch(\n              self._cursorDescription.collectionName, id, op,\n              finishIfNeedToPollQuery(function (err, doc) {\n                try {\n                  if (err) {\n                    Meteor._debug(\"Got exception while fetching documents\",\n                                  err);\n                    // If we get an error from the fetcher (eg, trouble\n                    // connecting to Mongo), let's just abandon the fetch phase\n                    // altogether and fall back to polling. It's not like we're\n                    // getting live updates anyway.\n                    if (self._phase !== PHASE.QUERYING) {\n                      self._needToPollQuery();\n                    }\n                  } else if (!self._stopped && self._phase === PHASE.FETCHING\n                             && self._fetchGeneration === thisGeneration) {\n                    // We re-check the generation in case we've had an explicit\n                    // _pollQuery call (eg, in another fiber) which should\n                    // effectively cancel this round of fetches.  (_pollQuery\n                    // increments the generation.)\n                    self._handleDoc(id, doc);\n                  }\n                } finally {\n                  waiting--;\n                  // Because fetch() never calls its callback synchronously,\n                  // this is safe (ie, we won't call fut.return() before the\n                  // forEach is done).\n                  if (waiting === 0)\n                    fut.return();\n                }\n              }));\n          });\n          fut.wait();\n          // Exit now if we've had a _pollQuery call (here or in another fiber).\n          if (self._phase === PHASE.QUERYING)\n            return;\n          self._currentlyFetching = null;\n        }\n        // We're done fetching, so we can be steady, unless we've had a\n        // _pollQuery call (here or in another fiber).\n        if (self._phase !== PHASE.QUERYING)\n          self._beSteady();\n      }));\n    });\n  },\n  _beSteady: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.STEADY);\n      var writes = self._writesToCommitWhenWeReachSteady;\n      self._writesToCommitWhenWeReachSteady = [];\n      self._multiplexer.onFlush(function () {\n        _.each(writes, function (w) {\n          w.committed();\n        });\n      });\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op);\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op);\n      // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n      if (self._phase === PHASE.FETCHING &&\n          ((self._currentlyFetching && self._currentlyFetching.has(id)) ||\n           self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op);\n        return;\n      }\n\n      if (op.op === 'd') {\n        if (self._published.has(id) ||\n            (self._limit && self._unpublishedBuffer.has(id)))\n          self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id))\n          throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id))\n          throw new Error(\"insert found for already-existing ID in buffer\");\n\n        // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n        if (self._matcher.documentMatches(op.o).result)\n          self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // we are mapping the new oplog format on mongo 5\n        // to what we know better, $set\n        op.o = oplogV2V1Converter(op.o)\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        // oplog format has changed on mongodb 5, we have to support both now\n        // diff is the format in Mongo 5+ (oplog v2)\n        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, 'diff') && !_.has(op.o, '$unset');\n        // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n        var canDirectlyModifyDoc =\n          !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n        if (isReplace) {\n          self._handleDoc(id, _.extend({_id: id}, op.o));\n        } else if ((publishedBefore || bufferedBefore) &&\n                   canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id)\n            ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n\n          newDoc._id = id;\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\")\n              throw e;\n            // We didn't understand the modifier.  Re-fetch.\n            self._needToFetch.set(id, op);\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n            return;\n          }\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc ||\n                   self._matcher.canBecomeTrueByModifier(op.o) ||\n                   (self._sorter && self._sorter.affectedByModifier(op.o))) {\n          self._needToFetch.set(id, op);\n          if (self._phase === PHASE.STEADY)\n            self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n  // Yields!\n  _runInitialQuery: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"oplog stopped surprisingly early\");\n\n    self._runQuery({initial: true});  // yields\n\n    if (self._stopped)\n      return;  // can happen on queryError\n\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n    self._multiplexer.ready();\n\n    self._doneQuerying();  // yields\n  },\n\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // Yay, we get to forget about all the things we thought we had to fetch.\n      self._needToFetch = new LocalCollection._IdMap;\n      self._currentlyFetching = null;\n      ++self._fetchGeneration;  // ignore any in-flight fetches\n      self._registerPhaseChange(PHASE.QUERYING);\n\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n      Meteor.defer(function () {\n        self._runQuery();\n        self._doneQuerying();\n      });\n    });\n  },\n\n  // Yields!\n  _runQuery: function (options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer;\n\n    // This while loop is just to retry failures.\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped)\n        return;\n\n      newResults = new LocalCollection._IdMap;\n      newBuffer = new LocalCollection._IdMap;\n\n      // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n      var cursor = self._cursorForQuery({ limit: self._limit * 2 });\n      try {\n        cursor.forEach(function (doc, i) {  // yields\n          if (!self._limit || i < self._limit) {\n            newResults.set(doc._id, doc);\n          } else {\n            newBuffer.set(doc._id, doc);\n          }\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof(e.code) === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          self._multiplexer.queryError(e);\n          return;\n        }\n\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while polling query\", e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    self._publishNewResults(newResults, newBuffer);\n  },\n\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n        throw new SwitchedToQuery;\n      }\n\n      // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n\n  // Yields!\n  _doneQuerying: function () {\n    var self = this;\n\n    if (self._stopped)\n      return;\n    self._mongoHandle._oplogHandle.waitUntilCaughtUp();  // yields\n    if (self._stopped)\n      return;\n    if (self._phase !== PHASE.QUERYING)\n      throw Error(\"Phase unexpectedly \" + self._phase);\n\n    Meteor._noYieldsAllowed(function () {\n      if (self._requeryWhenDoneThisQuery) {\n        self._requeryWhenDoneThisQuery = false;\n        self._pollQuery();\n      } else if (self._needToFetch.empty()) {\n        self._beSteady();\n      } else {\n        self._fetchModifiedDocuments();\n      }\n    });\n  },\n\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = _.clone(self._cursorDescription.options);\n\n      // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n      _.extend(options, optionsOverwrite);\n\n      options.fields = self._sharedProjection;\n      delete options.transform;\n      // We are NOT deep cloning fields or selector here, which should be OK.\n      var description = new CursorDescription(\n        self._cursorDescription.collectionName,\n        self._cursorDescription.selector,\n        options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n\n\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      }\n\n      // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n      var idsToRemove = [];\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          idsToRemove.push(id);\n      });\n      _.each(idsToRemove, function (id) {\n        self._removePublished(id);\n      });\n\n      // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      });\n\n      // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n      if (self._published.size() !== newResults.size()) {\n        Meteor._debug('The Mongo server and the Meteor query disagree on how ' +\n          'many documents match your query. Cursor description: ',\n          self._cursorDescription);\n      }\n      \n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      });\n\n      // Finally, replace the buffer\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    _.each(self._stopHandles, function (handle) {\n      handle.stop();\n    });\n\n    // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n    _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n      w.committed();  // maybe yields?\n    });\n    self._writesToCommitWhenWeReachSteady = null;\n\n    // Proactively drop references to potentially big things.\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-oplog\", -1);\n  },\n\n  _registerPhaseChange: function (phase) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date;\n\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n          \"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog)\n    return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || (options.limit && !options.sort)) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  const fields = options.fields || options.projection;\n  if (fields) {\n    try {\n      LocalCollection._checkSupportedProjection(fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return _.all(modifier, function (fields, operation) {\n    return _.all(fields, function (value, field) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};\n\nMongoInternals.OplogObserveDriver = OplogObserveDriver;\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"48fc06271b3649e7256966b698474a6461c0769b"}
