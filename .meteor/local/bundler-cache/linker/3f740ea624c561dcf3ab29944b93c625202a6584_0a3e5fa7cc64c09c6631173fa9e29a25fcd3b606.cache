[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar meteorInstall = Package.modules.meteorInstall;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"hot-module-replacement\":{\"hot-api.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/hot-module-replacement/hot-api.js                                                              //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\n/**\n * @summary The Hot API used to configure HMR\n * @memberof module\n * @name hot\n */\nObject.defineProperty(meteorInstall.Module.prototype, \"hot\", {\n  get: function () {\n    if (!this._hotState) {\n      this._hotState = {\n        // if null, whether it accepts depends on all of the modules that\n        // required it\n        _hotAccepts: null,\n        _disposeHandlers: [],\n        data: null\n      };\n    }\n\n    var hotState = this._hotState;\n    var module = this;\n\n    return {\n      /**\n       * @summary Accept updates to this module. Also applies to its dependencies,\n       * as long as the other modules that import the dependencies also accept\n       * updates.\n       * @locus Client\n       * @memberOf module.hot\n       * @instance\n       * @name accept\n       */\n      accept: function () {\n        if (arguments.length > 0) {\n          console.warn('hot.accept does not support any arguments.');\n        }\n\n        if (hotState._hotAccepts === false) {\n          return;\n        }\n\n        hotState._hotAccepts = true;\n      },\n      /**\n        * @summary Disable updating this module or its dependencies with HMR.\n        * Hot code push will be used instead. Can not be overridden by calling\n        * module.hot.accept later.\n        * @locus Client\n        * @memberOf module.hot\n        * @instance\n        * @name decline\n        */\n      decline: function () {\n        if (arguments.length > 0) {\n          throw new Error('hot.decline does not support any arguments.');\n        }\n\n        hotState._hotAccepts = false;\n      },\n      /**\n        * @summary Add a call back to clean up the module before replacing it\n        * @locus Client\n        * @memberOf module.hot\n        * @instance\n        * @name dispose\n        * @param {module.hot.DisposeFunction} callback Called before replacing the old module.\n        */\n      dispose: function (cb) {\n        hotState._disposeHandlers.push(cb);\n      },\n      /**\n        * @summary Add callbacks to run before and after a module is required\n        * @locus Client\n        * @memberOf module.hot\n        * @instance\n        * @name onRequire\n        * @param {Object} callbacks Can have before and after methods, called before a module is required,\n        * and after it finished being evaluated\n        */\n      onRequire: function (callbacks) {\n        return module._onRequire(callbacks);\n      },\n      _canAcceptUpdate: function () {\n        return hotState._hotAccepts;\n      },\n      /**\n       * @summary Defaults to null. When the module is replaced,\n       * this is set to the object passed to dispose handlers.\n       * @locus Client\n       * @memberOf module.hot\n       * @instance\n       * @name data\n       */\n      data: hotState.data\n    }\n  },\n  set: function () { }\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"client.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/hot-module-replacement/client.js                                                               //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// TODO: add an api to Reify to update cached exports for a module\nvar ReifyEntry = require('/node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime/entry.js')\n\nvar SOURCE_URL_PREFIX = \"meteor://\\ud83d\\udcbbapp\";\n\nvar appliedChangeSets = [];\nvar removeErrorMessage = null;\n\nvar arch = Meteor.isCordova ? \"web.cordova\" :\n  Meteor.isModern ? \"web.browser\" : \"web.browser.legacy\";\n\nvar initialVersions = __meteor_runtime_config__.autoupdate.versions[arch];\nvar lastUpdated = initialVersions.versionHmr;\nvar hmrSecret = __meteor_runtime_config__._hmrSecret;\n\n// Cordova doesn't need the hmrSecret, though cordova is also unable to tell\n// if Meteor needs to be restarted to enable HMR;\nvar enabled = Meteor.isCordova || !!hmrSecret;\n\nif (!enabled) {\n  console.log('Restart Meteor to enable HMR');\n}\n\nvar imported = Object.create(null);\nvar importedBy = Object.create(null);\n\nif (module._onRequire) {\n  module._onRequire({\n    before: function (importedModule, parentId) {\n      if (parentId === module.id) {\n        // While applying updates we import modules to re-run them.\n        // Don't track those imports since we don't want them to affect\n        // if a future change to the file can be accepted\n        return;\n      }\n      imported[parentId] = imported[parentId] || new Set();\n      imported[parentId].add(importedModule.id);\n\n      importedBy[importedModule.id] = importedBy[importedModule.id] || new Set();\n      importedBy[importedModule.id].add(parentId);\n    },\n  });\n}\n\n// On web, we can reload the page any time to get the new version. On cordova,\n// we have to wait until Reload._onMigrate is called\nvar hotCodePushReady = arch !== 'web.cordova';\n\nvar useHotCodePush = false;\nvar forceReload = function () {\n  useHotCodePush = true;\n  // Wait until Reload package has been loaded\n  Meteor.startup(function () {\n    if (hotCodePushReady) {\n      Package['reload'].Reload._reload();\n    }\n  });\n};\n\n// Once an eager update fails, we stop processing future updates since they\n// might depend on the failed update. This gets reset when we re-try applying\n// the changes as non-eager updates.\nvar applyEagerUpdates = true;\n\nfunction handleMessage(message) {\n  if (message.type === 'register-failed') {\n    if (message.reason === 'wrong-app') {\n      console.log('HMR: A different app is running on', Meteor.absoluteUrl());\n      console.log('HMR: Once you start this app again reload the page to re-enable HMR');\n    } else if (message.reason === 'wrong-secret') {\n      console.log('HMR: Have the wrong secret, probably because Meteor was restarted');\n      console.log('HMR: Will enable HMR the next time the page is loaded');\n      useHotCodePush = true;\n    } else {\n      console.log('HMR: Register failed for unknown reason', message);\n    }\n    return;\n  } else if (message.type === 'app-state') {\n    if (removeErrorMessage) {\n      removeErrorMessage();\n    }\n\n    if (message.state === 'error' && Package['dev-error-overlay']) {\n      removeErrorMessage = Package['dev-error-overlay']\n        .DevErrorOverlay\n        .showMessage('Your app is crashing. Here are the latest logs:', message.log.join('\\n'));\n    }\n\n    return;\n  }\n\n  if (message.type !== 'changes') {\n    throw new Error('Unknown HMR message type ' + message.type);\n  }\n\n  if (message.eager && !applyEagerUpdates) {\n    return;\n  } else if (!message.eager) {\n    // Now that the build has finished, we will finish handling any updates\n    // that failed while being eagerly applied. Afterwards, we will either\n    // fall back to hot code push, or be in a state where we can start handling\n    // eager updates again\n    applyEagerUpdates = true;\n  }\n\n  var hasUnreloadable = message.changeSets.find(function (changeSet) {\n    return !changeSet.reloadable;\n  });\n\n  if (\n    hasUnreloadable ||\n    message.changeSets.length === 0\n  ) {\n    if (message.eager) {\n      // This was an attempt to reload before the build finishes\n      // If we can't, we will wait until the build finishes to properly handle it\n      // For now, we will disable eager updates in case future updates depended\n      // on these\n      applyEagerUpdates = false;\n      return;\n    }\n\n    console.log('HMR: Unable to do HMR. Falling back to hot code push.');\n    // Complete hot code push if we can not do hot module reload\n    return forceReload();\n  }\n\n  // In case the user changed how a module works with HMR\n  // in one of the earlier change sets, we want to apply each\n  // change set one at a time in order.\n  var succeeded = message.changeSets.filter(function (changeSet) {\n    return !appliedChangeSets.includes(changeSet.id)\n  }).every(function (changeSet) {\n    var applied = applyChangeset(changeSet, message.eager);\n\n    // We don't record if a module is unreplaceable\n    // during an eager update so we can retry and\n    // handle the failure after the build finishes\n    if (applied || !message.eager) {\n      appliedChangeSets.push(changeSet.id);\n    }\n\n    return applied;\n  });\n\n  if (message.eager) {\n    // If there were any failures, we will stop applying eager updates for now\n    // and wait until after the build finishes to handle the failures\n    applyEagerUpdates = succeeded;\n    return;\n  }\n\n  if (!succeeded) {\n    console.log('HMR: Some changes can not be applied with HMR. Using hot code push.')\n\n    forceReload();\n    return;\n  }\n\n  if (message.changeSets.length > 0) {\n    lastUpdated = message.changeSets[message.changeSets.length - 1].linkedAt;\n  }\n}\n\nvar socket;\nvar disconnected = false;\nvar pendingMessages = [];\n\nfunction send(message) {\n  if (socket) {\n    socket.send(JSON.stringify(message));\n  } else {\n    pendingMessages.push(message);\n  }\n}\n\nfunction connect() {\n  if (useHotCodePush) {\n    // The page will reload, no reason to\n    // connect and show more logs in the console\n    return;\n  }\n\n  // If we've successfully connected and then was disconnected, we avoid showing\n  // any more connection errors in the console until we've connected again\n  var logDisconnect = !disconnected;\n  var wsUrl = Meteor.absoluteUrl('__meteor__hmr__/websocket');\n  var protocol = wsUrl.startsWith('https://') ? 'wss://' : 'ws://';\n  wsUrl = wsUrl.replace(/^.+\\/\\//, protocol);\n  socket = new WebSocket(wsUrl);\n\n  socket.addEventListener('close', function () {\n    socket = null;\n\n    if (logDisconnect && !useHotCodePush) {\n      console.log('HMR: websocket closed');\n    }\n\n    disconnected = true;\n    setTimeout(connect, 2000);\n  });\n\n  socket.addEventListener('open', function () {\n    logDisconnect = true;\n    disconnected = false;\n\n    console.log('HMR: connected');\n    socket.send(JSON.stringify({\n      type: 'register',\n      arch: arch,\n      secret: hmrSecret,\n      appId: __meteor_runtime_config__.appId,\n    }));\n\n    var toSend = pendingMessages.slice();\n    pendingMessages = [];\n\n    toSend.forEach(function (message) {\n      send(message);\n    });\n  });\n\n  socket.addEventListener('message', function (event) {\n    handleMessage(JSON.parse(event.data));\n  });\n}\n\nif (enabled) {\n  connect();\n} else {\n  useHotCodePush = true;\n}\n\nfunction requestChanges() {\n  send({\n    type: 'request-changes',\n    arch: arch,\n    after: lastUpdated\n  });\n}\n\nfunction walkTree(pathParts, tree) {\n  var part = pathParts.shift();\n  var _module = tree.contents[part];\n\n  if (!_module) {\n    console.log('HMR: file does not exist', part, pathParts, _module, tree);\n    throw new Error('not-exist');\n  }\n\n  if (pathParts.length === 0) {\n    return _module;\n  }\n\n  return walkTree(pathParts, _module);\n}\n\nfunction findFile(moduleId) {\n  return walkTree(moduleId.split('/').slice(1), module._getRoot());\n}\n\n// btoa with unicode support\nfunction utoa(data) {\n  return btoa(unescape(encodeURIComponent(data)));\n}\n\nfunction createInlineSourceMap(map) {\n  return \"//# sourceMappingURL=data:application/json;base64,\" + utoa(JSON.stringify(map));\n}\n\nfunction createModuleContent (code, map) {\n  return function () {\n    return eval(\n      // Wrap the function(require,exports,module){...} expression in\n      // parentheses to force it to be parsed as an expression.\n      // The sourceURL is treated as a prefix for the sources array\n      // in the source map\n      \"(\" + code + \")\\n//# sourceURL=\" + SOURCE_URL_PREFIX +\n      \"\\n\" + createInlineSourceMap(map)\n    ).apply(this, arguments);\n  }\n}\n\nfunction replaceFileContent(file, contents) {\n  // TODO: to replace content in packages, we need an eval function that runs\n  // within the package scope, like dynamic imports does.\n  var moduleFunction = createModuleContent(contents.code, contents.map, file.module.id);\n\n  file.contents = moduleFunction;\n}\n\nfunction checkModuleAcceptsUpdate(moduleId, checked) {\n  checked.add(moduleId);\n\n  if (moduleId === '/' ) {\n    return false;\n  }\n\n  var file = findFile(moduleId);\n  var moduleHot = file.module.hot;\n  var moduleAccepts = moduleHot ? moduleHot._canAcceptUpdate() : false;\n\n  if (moduleAccepts !== null) {\n    return moduleAccepts;\n  }\n\n  var accepts = null;\n\n  // The module did not accept the update. If the update is accepted depends\n  // on if the modules that imported this module accept the update.\n  importedBy[moduleId].forEach(function (depId) {\n    if (depId === '/' && importedBy[moduleId].size > 1) {\n      // This module was eagerly required by Meteor.\n      // Meteor won't know if the module can be updated\n      // but we can check with the other modules that imported it.\n      return;\n    }\n\n    if (checked.has(depId)) {\n      // There is a circular dependency\n      return;\n    }\n\n    var depResult = checkModuleAcceptsUpdate(depId, checked);\n\n    if (accepts !== false) {\n      accepts = depResult;\n    }\n  });\n\n  return accepts === null ? false : accepts;\n}\n\nfunction addFiles(addedFiles) {\n  addedFiles.forEach(function (file) {\n    var tree = {};\n    var segments = file.path.split('/').slice(1);\n    var fileName = segments.pop();\n\n    var previous = tree;\n    segments.forEach(function (segment) {\n      previous[segment] = previous[segment] || {}\n      previous = previous[segment]\n    });\n    previous[fileName] = createModuleContent(\n      file.content.code,\n      file.content.map,\n      file.path\n    );\n\n    meteorInstall(tree, file.meteorInstallOptions);\n  });\n}\n\nmodule.constructor.prototype._reset = function (id) {\n  var moduleId = id || this.id;\n  var file = findFile(moduleId);\n\n  var hotState = file.module._hotState;\n\n  var hotData = {};\n  hotState._disposeHandlers.forEach(function (cb) {\n    cb(hotData);\n  });\n\n  hotState.data = hotData;\n  hotState._disposeHandlers = [];\n  hotState._hotAccepts = null;\n\n\n  // Clear cached exports\n  // TODO: check how this affects live bindings for ecmascript modules\n  delete file.module.exports;\n  var entry = ReifyEntry.getOrCreate(moduleId);\n  entry.getters = {};\n  entry.setters = {};\n  entry.module = null;\n  Object.keys(entry.namespace).forEach(function (key) {\n    if (key !== '__esModule') {\n      delete entry.namespace[key];\n    }\n  });\n\n  if (imported[moduleId]) {\n    imported[moduleId].forEach(function (depId) {\n      importedBy[depId].delete(moduleId);\n    });\n    imported[moduleId] = new Set();\n  }\n}\n\nmodule.constructor.prototype._replaceModule = function (id, contents) {\n  var moduleId = id || this.id;\n  var root = this._getRoot();\n\n  var file;\n  try {\n    file = walkTree(moduleId.split('/').slice(1), root);\n  } catch (e) {\n    if (e.message === 'not-exist') {\n      return null;\n    }\n\n    throw e;\n  }\n\n  if (!file.contents) {\n    // File is a dynamic import that hasn't been loaded\n    return;\n  }\n\n  replaceFileContent(file, contents);\n\n  if (!file.module.exports) {\n    // File hasn't been imported.\n    return;\n  }\n}\n\nfunction applyChangeset(options) {\n  var changedFiles = options.changedFiles;\n  var addedFiles = options.addedFiles;\n\n  var canApply = true;\n  var toRerun = new Set();\n\n  changedFiles.forEach(function (changed) {\n    var path = changed.path;\n    var file = findFile(path);\n\n    // Check if the file has been imported. If it hasn't been,\n    // we can assume update to it can be accepted\n    if (file.module.exports) {\n      var checked = new Set();\n      var accepts = checkModuleAcceptsUpdate(path, checked);\n\n      if (canApply) {\n        canApply = accepts;\n        checked.forEach(function (moduleId) {\n          toRerun.add(moduleId);\n        });\n      }\n    }\n  });\n\n  if (!canApply) {\n    return false;\n  }\n\n  changedFiles.forEach(function (changedFile) {\n    module._replaceModule(changedFile.path, changedFile.content);\n  });\n\n  if (addedFiles.length > 0) {\n    addFiles(addedFiles);\n  }\n\n  toRerun.forEach(function (moduleId) {\n    var file = findFile(moduleId);\n    // clear module caches and hot state\n    file.module._reset();\n    file.module.loaded = false;\n  });\n\n  try {\n    toRerun.forEach(function (moduleId) {\n      require(moduleId);\n    });\n  } catch (error) {\n    console.error('HMR: Error while applying changes:', error);\n  }\n\n  var updateCount = changedFiles.length + addedFiles.length;\n  console.log('HMR: updated ' + updateCount + ' ' + (updateCount === 1 ? 'file' : 'files'));\n  return true;\n}\n\nvar nonRefreshableVersion = initialVersions.versionNonRefreshable;\nvar replaceableVersion = initialVersions.versionReplaceable;\n\nMeteor.startup(function () {\n  if (!enabled) {\n    return;\n  }\n\n  Package['autoupdate'].Autoupdate._clientVersions.watch(function (doc) {\n    if (doc._id !== arch) {\n      return;\n    }\n\n    if (nonRefreshableVersion !== doc.versionNonRefreshable) {\n      nonRefreshableVersion = doc.versionNonRefreshable;\n      console.log('HMR: Some changes can not be applied with HMR. Using hot code push.')\n      forceReload();\n    } else if (doc.versionReplaceable !== replaceableVersion) {\n      replaceableVersion = doc.versionReplaceable;\n\n      if (useHotCodePush) {\n        return forceReload();\n      }\n\n      requestChanges();\n    }\n  });\n\n  Package['reload'].Reload._onMigrate(function () {\n    if (useHotCodePush) {\n      return [true];\n    }\n\n    hotCodePushReady = true;\n    return [false];\n  });\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/hot-module-replacement/hot-api.js\");\nrequire(\"/node_modules/meteor/hot-module-replacement/client.js\");\n\n/* Exports */\nPackage._define(\"hot-module-replacement\");\n\n})();\n","servePath":"/packages/hot-module-replacement.js"}]